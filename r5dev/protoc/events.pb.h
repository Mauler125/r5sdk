// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_events_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_events_2eproto

#include <limits>
#include <string>

#include <thirdparty/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <thirdparty/protobuf/port_undef.inc>
#include <thirdparty/protobuf/io/coded_stream.h>
#include <thirdparty/protobuf/arena.h>
#include <thirdparty/protobuf/arenastring.h>
#include <thirdparty/protobuf/generated_message_bases.h>
#include <thirdparty/protobuf/generated_message_util.h>
#include <thirdparty/protobuf/metadata_lite.h>
#include <thirdparty/protobuf/generated_message_reflection.h>
#include <thirdparty/protobuf/message.h>
#include <thirdparty/protobuf/repeated_field.h>  // IWYU pragma: export
#include <thirdparty/protobuf/extension_set.h>  // IWYU pragma: export
#include <thirdparty/protobuf/generated_enum_reflection.h>
#include <thirdparty/protobuf/unknown_field_set.h>
#include <thirdparty/protobuf/struct.pb.h>
#include <thirdparty/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <thirdparty/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_events_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_events_2eproto;
namespace rtech {
namespace liveapi {
class AmmoUsed;
struct AmmoUsedDefaultTypeInternal;
extern AmmoUsedDefaultTypeInternal _AmmoUsed_default_instance_;
class ArenasItemDeselected;
struct ArenasItemDeselectedDefaultTypeInternal;
extern ArenasItemDeselectedDefaultTypeInternal _ArenasItemDeselected_default_instance_;
class ArenasItemSelected;
struct ArenasItemSelectedDefaultTypeInternal;
extern ArenasItemSelectedDefaultTypeInternal _ArenasItemSelected_default_instance_;
class BannerCollected;
struct BannerCollectedDefaultTypeInternal;
extern BannerCollectedDefaultTypeInternal _BannerCollected_default_instance_;
class BlackMarketAction;
struct BlackMarketActionDefaultTypeInternal;
extern BlackMarketActionDefaultTypeInternal _BlackMarketAction_default_instance_;
class ChangeCamera;
struct ChangeCameraDefaultTypeInternal;
extern ChangeCameraDefaultTypeInternal _ChangeCamera_default_instance_;
class CharacterSelected;
struct CharacterSelectedDefaultTypeInternal;
extern CharacterSelectedDefaultTypeInternal _CharacterSelected_default_instance_;
class CustomEvent;
struct CustomEventDefaultTypeInternal;
extern CustomEventDefaultTypeInternal _CustomEvent_default_instance_;
class CustomMatch_CreateLobby;
struct CustomMatch_CreateLobbyDefaultTypeInternal;
extern CustomMatch_CreateLobbyDefaultTypeInternal _CustomMatch_CreateLobby_default_instance_;
class CustomMatch_GetLobbyPlayers;
struct CustomMatch_GetLobbyPlayersDefaultTypeInternal;
extern CustomMatch_GetLobbyPlayersDefaultTypeInternal _CustomMatch_GetLobbyPlayers_default_instance_;
class CustomMatch_GetSettings;
struct CustomMatch_GetSettingsDefaultTypeInternal;
extern CustomMatch_GetSettingsDefaultTypeInternal _CustomMatch_GetSettings_default_instance_;
class CustomMatch_JoinLobby;
struct CustomMatch_JoinLobbyDefaultTypeInternal;
extern CustomMatch_JoinLobbyDefaultTypeInternal _CustomMatch_JoinLobby_default_instance_;
class CustomMatch_KickPlayer;
struct CustomMatch_KickPlayerDefaultTypeInternal;
extern CustomMatch_KickPlayerDefaultTypeInternal _CustomMatch_KickPlayer_default_instance_;
class CustomMatch_LeaveLobby;
struct CustomMatch_LeaveLobbyDefaultTypeInternal;
extern CustomMatch_LeaveLobbyDefaultTypeInternal _CustomMatch_LeaveLobby_default_instance_;
class CustomMatch_LobbyPlayer;
struct CustomMatch_LobbyPlayerDefaultTypeInternal;
extern CustomMatch_LobbyPlayerDefaultTypeInternal _CustomMatch_LobbyPlayer_default_instance_;
class CustomMatch_LobbyPlayers;
struct CustomMatch_LobbyPlayersDefaultTypeInternal;
extern CustomMatch_LobbyPlayersDefaultTypeInternal _CustomMatch_LobbyPlayers_default_instance_;
class CustomMatch_SendChat;
struct CustomMatch_SendChatDefaultTypeInternal;
extern CustomMatch_SendChatDefaultTypeInternal _CustomMatch_SendChat_default_instance_;
class CustomMatch_SetMatchmaking;
struct CustomMatch_SetMatchmakingDefaultTypeInternal;
extern CustomMatch_SetMatchmakingDefaultTypeInternal _CustomMatch_SetMatchmaking_default_instance_;
class CustomMatch_SetReady;
struct CustomMatch_SetReadyDefaultTypeInternal;
extern CustomMatch_SetReadyDefaultTypeInternal _CustomMatch_SetReady_default_instance_;
class CustomMatch_SetSettings;
struct CustomMatch_SetSettingsDefaultTypeInternal;
extern CustomMatch_SetSettingsDefaultTypeInternal _CustomMatch_SetSettings_default_instance_;
class CustomMatch_SetTeam;
struct CustomMatch_SetTeamDefaultTypeInternal;
extern CustomMatch_SetTeamDefaultTypeInternal _CustomMatch_SetTeam_default_instance_;
class CustomMatch_SetTeamName;
struct CustomMatch_SetTeamNameDefaultTypeInternal;
extern CustomMatch_SetTeamNameDefaultTypeInternal _CustomMatch_SetTeamName_default_instance_;
class Datacenter;
struct DatacenterDefaultTypeInternal;
extern DatacenterDefaultTypeInternal _Datacenter_default_instance_;
class GameStateChanged;
struct GameStateChangedDefaultTypeInternal;
extern GameStateChangedDefaultTypeInternal _GameStateChanged_default_instance_;
class GibraltarShieldAbsorbed;
struct GibraltarShieldAbsorbedDefaultTypeInternal;
extern GibraltarShieldAbsorbedDefaultTypeInternal _GibraltarShieldAbsorbed_default_instance_;
class GrenadeThrown;
struct GrenadeThrownDefaultTypeInternal;
extern GrenadeThrownDefaultTypeInternal _GrenadeThrown_default_instance_;
class Init;
struct InitDefaultTypeInternal;
extern InitDefaultTypeInternal _Init_default_instance_;
class InventoryDrop;
struct InventoryDropDefaultTypeInternal;
extern InventoryDropDefaultTypeInternal _InventoryDrop_default_instance_;
class InventoryItem;
struct InventoryItemDefaultTypeInternal;
extern InventoryItemDefaultTypeInternal _InventoryItem_default_instance_;
class InventoryPickUp;
struct InventoryPickUpDefaultTypeInternal;
extern InventoryPickUpDefaultTypeInternal _InventoryPickUp_default_instance_;
class InventoryUse;
struct InventoryUseDefaultTypeInternal;
extern InventoryUseDefaultTypeInternal _InventoryUse_default_instance_;
class LegendUpgradeSelected;
struct LegendUpgradeSelectedDefaultTypeInternal;
extern LegendUpgradeSelectedDefaultTypeInternal _LegendUpgradeSelected_default_instance_;
class LiveAPIEvent;
struct LiveAPIEventDefaultTypeInternal;
extern LiveAPIEventDefaultTypeInternal _LiveAPIEvent_default_instance_;
class LoadoutConfiguration;
struct LoadoutConfigurationDefaultTypeInternal;
extern LoadoutConfigurationDefaultTypeInternal _LoadoutConfiguration_default_instance_;
class MatchSetup;
struct MatchSetupDefaultTypeInternal;
extern MatchSetupDefaultTypeInternal _MatchSetup_default_instance_;
class MatchStateEnd;
struct MatchStateEndDefaultTypeInternal;
extern MatchStateEndDefaultTypeInternal _MatchStateEnd_default_instance_;
class ObserverAnnotation;
struct ObserverAnnotationDefaultTypeInternal;
extern ObserverAnnotationDefaultTypeInternal _ObserverAnnotation_default_instance_;
class ObserverSwitched;
struct ObserverSwitchedDefaultTypeInternal;
extern ObserverSwitchedDefaultTypeInternal _ObserverSwitched_default_instance_;
class PauseToggle;
struct PauseToggleDefaultTypeInternal;
extern PauseToggleDefaultTypeInternal _PauseToggle_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerAbilityUsed;
struct PlayerAbilityUsedDefaultTypeInternal;
extern PlayerAbilityUsedDefaultTypeInternal _PlayerAbilityUsed_default_instance_;
class PlayerAssist;
struct PlayerAssistDefaultTypeInternal;
extern PlayerAssistDefaultTypeInternal _PlayerAssist_default_instance_;
class PlayerConnected;
struct PlayerConnectedDefaultTypeInternal;
extern PlayerConnectedDefaultTypeInternal _PlayerConnected_default_instance_;
class PlayerDamaged;
struct PlayerDamagedDefaultTypeInternal;
extern PlayerDamagedDefaultTypeInternal _PlayerDamaged_default_instance_;
class PlayerDisconnected;
struct PlayerDisconnectedDefaultTypeInternal;
extern PlayerDisconnectedDefaultTypeInternal _PlayerDisconnected_default_instance_;
class PlayerDowned;
struct PlayerDownedDefaultTypeInternal;
extern PlayerDownedDefaultTypeInternal _PlayerDowned_default_instance_;
class PlayerKilled;
struct PlayerKilledDefaultTypeInternal;
extern PlayerKilledDefaultTypeInternal _PlayerKilled_default_instance_;
class PlayerRespawnTeam;
struct PlayerRespawnTeamDefaultTypeInternal;
extern PlayerRespawnTeamDefaultTypeInternal _PlayerRespawnTeam_default_instance_;
class PlayerRevive;
struct PlayerReviveDefaultTypeInternal;
extern PlayerReviveDefaultTypeInternal _PlayerRevive_default_instance_;
class PlayerStatChanged;
struct PlayerStatChangedDefaultTypeInternal;
extern PlayerStatChangedDefaultTypeInternal _PlayerStatChanged_default_instance_;
class PlayerUpgradeTierChanged;
struct PlayerUpgradeTierChangedDefaultTypeInternal;
extern PlayerUpgradeTierChangedDefaultTypeInternal _PlayerUpgradeTierChanged_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestStatus;
struct RequestStatusDefaultTypeInternal;
extern RequestStatusDefaultTypeInternal _RequestStatus_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RevenantForgedShadowDamaged;
struct RevenantForgedShadowDamagedDefaultTypeInternal;
extern RevenantForgedShadowDamagedDefaultTypeInternal _RevenantForgedShadowDamaged_default_instance_;
class RingFinishedClosing;
struct RingFinishedClosingDefaultTypeInternal;
extern RingFinishedClosingDefaultTypeInternal _RingFinishedClosing_default_instance_;
class RingStartClosing;
struct RingStartClosingDefaultTypeInternal;
extern RingStartClosingDefaultTypeInternal _RingStartClosing_default_instance_;
class SquadEliminated;
struct SquadEliminatedDefaultTypeInternal;
extern SquadEliminatedDefaultTypeInternal _SquadEliminated_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class WarpGateUsed;
struct WarpGateUsedDefaultTypeInternal;
extern WarpGateUsedDefaultTypeInternal _WarpGateUsed_default_instance_;
class WeaponSwitched;
struct WeaponSwitchedDefaultTypeInternal;
extern WeaponSwitchedDefaultTypeInternal _WeaponSwitched_default_instance_;
class WraithPortal;
struct WraithPortalDefaultTypeInternal;
extern WraithPortalDefaultTypeInternal _WraithPortal_default_instance_;
class ZiplineUsed;
struct ZiplineUsedDefaultTypeInternal;
extern ZiplineUsedDefaultTypeInternal _ZiplineUsed_default_instance_;
}  // namespace liveapi
}  // namespace rtech
PROTOBUF_NAMESPACE_OPEN
template<> ::rtech::liveapi::AmmoUsed* Arena::CreateMaybeMessage<::rtech::liveapi::AmmoUsed>(Arena*);
template<> ::rtech::liveapi::ArenasItemDeselected* Arena::CreateMaybeMessage<::rtech::liveapi::ArenasItemDeselected>(Arena*);
template<> ::rtech::liveapi::ArenasItemSelected* Arena::CreateMaybeMessage<::rtech::liveapi::ArenasItemSelected>(Arena*);
template<> ::rtech::liveapi::BannerCollected* Arena::CreateMaybeMessage<::rtech::liveapi::BannerCollected>(Arena*);
template<> ::rtech::liveapi::BlackMarketAction* Arena::CreateMaybeMessage<::rtech::liveapi::BlackMarketAction>(Arena*);
template<> ::rtech::liveapi::ChangeCamera* Arena::CreateMaybeMessage<::rtech::liveapi::ChangeCamera>(Arena*);
template<> ::rtech::liveapi::CharacterSelected* Arena::CreateMaybeMessage<::rtech::liveapi::CharacterSelected>(Arena*);
template<> ::rtech::liveapi::CustomEvent* Arena::CreateMaybeMessage<::rtech::liveapi::CustomEvent>(Arena*);
template<> ::rtech::liveapi::CustomMatch_CreateLobby* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_CreateLobby>(Arena*);
template<> ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_GetLobbyPlayers>(Arena*);
template<> ::rtech::liveapi::CustomMatch_GetSettings* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_GetSettings>(Arena*);
template<> ::rtech::liveapi::CustomMatch_JoinLobby* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_JoinLobby>(Arena*);
template<> ::rtech::liveapi::CustomMatch_KickPlayer* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_KickPlayer>(Arena*);
template<> ::rtech::liveapi::CustomMatch_LeaveLobby* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_LeaveLobby>(Arena*);
template<> ::rtech::liveapi::CustomMatch_LobbyPlayer* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_LobbyPlayer>(Arena*);
template<> ::rtech::liveapi::CustomMatch_LobbyPlayers* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_LobbyPlayers>(Arena*);
template<> ::rtech::liveapi::CustomMatch_SendChat* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_SendChat>(Arena*);
template<> ::rtech::liveapi::CustomMatch_SetMatchmaking* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetMatchmaking>(Arena*);
template<> ::rtech::liveapi::CustomMatch_SetReady* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetReady>(Arena*);
template<> ::rtech::liveapi::CustomMatch_SetSettings* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetSettings>(Arena*);
template<> ::rtech::liveapi::CustomMatch_SetTeam* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetTeam>(Arena*);
template<> ::rtech::liveapi::CustomMatch_SetTeamName* Arena::CreateMaybeMessage<::rtech::liveapi::CustomMatch_SetTeamName>(Arena*);
template<> ::rtech::liveapi::Datacenter* Arena::CreateMaybeMessage<::rtech::liveapi::Datacenter>(Arena*);
template<> ::rtech::liveapi::GameStateChanged* Arena::CreateMaybeMessage<::rtech::liveapi::GameStateChanged>(Arena*);
template<> ::rtech::liveapi::GibraltarShieldAbsorbed* Arena::CreateMaybeMessage<::rtech::liveapi::GibraltarShieldAbsorbed>(Arena*);
template<> ::rtech::liveapi::GrenadeThrown* Arena::CreateMaybeMessage<::rtech::liveapi::GrenadeThrown>(Arena*);
template<> ::rtech::liveapi::Init* Arena::CreateMaybeMessage<::rtech::liveapi::Init>(Arena*);
template<> ::rtech::liveapi::InventoryDrop* Arena::CreateMaybeMessage<::rtech::liveapi::InventoryDrop>(Arena*);
template<> ::rtech::liveapi::InventoryItem* Arena::CreateMaybeMessage<::rtech::liveapi::InventoryItem>(Arena*);
template<> ::rtech::liveapi::InventoryPickUp* Arena::CreateMaybeMessage<::rtech::liveapi::InventoryPickUp>(Arena*);
template<> ::rtech::liveapi::InventoryUse* Arena::CreateMaybeMessage<::rtech::liveapi::InventoryUse>(Arena*);
template<> ::rtech::liveapi::LegendUpgradeSelected* Arena::CreateMaybeMessage<::rtech::liveapi::LegendUpgradeSelected>(Arena*);
template<> ::rtech::liveapi::LiveAPIEvent* Arena::CreateMaybeMessage<::rtech::liveapi::LiveAPIEvent>(Arena*);
template<> ::rtech::liveapi::LoadoutConfiguration* Arena::CreateMaybeMessage<::rtech::liveapi::LoadoutConfiguration>(Arena*);
template<> ::rtech::liveapi::MatchSetup* Arena::CreateMaybeMessage<::rtech::liveapi::MatchSetup>(Arena*);
template<> ::rtech::liveapi::MatchStateEnd* Arena::CreateMaybeMessage<::rtech::liveapi::MatchStateEnd>(Arena*);
template<> ::rtech::liveapi::ObserverAnnotation* Arena::CreateMaybeMessage<::rtech::liveapi::ObserverAnnotation>(Arena*);
template<> ::rtech::liveapi::ObserverSwitched* Arena::CreateMaybeMessage<::rtech::liveapi::ObserverSwitched>(Arena*);
template<> ::rtech::liveapi::PauseToggle* Arena::CreateMaybeMessage<::rtech::liveapi::PauseToggle>(Arena*);
template<> ::rtech::liveapi::Player* Arena::CreateMaybeMessage<::rtech::liveapi::Player>(Arena*);
template<> ::rtech::liveapi::PlayerAbilityUsed* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerAbilityUsed>(Arena*);
template<> ::rtech::liveapi::PlayerAssist* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerAssist>(Arena*);
template<> ::rtech::liveapi::PlayerConnected* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerConnected>(Arena*);
template<> ::rtech::liveapi::PlayerDamaged* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerDamaged>(Arena*);
template<> ::rtech::liveapi::PlayerDisconnected* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerDisconnected>(Arena*);
template<> ::rtech::liveapi::PlayerDowned* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerDowned>(Arena*);
template<> ::rtech::liveapi::PlayerKilled* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerKilled>(Arena*);
template<> ::rtech::liveapi::PlayerRespawnTeam* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerRespawnTeam>(Arena*);
template<> ::rtech::liveapi::PlayerRevive* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerRevive>(Arena*);
template<> ::rtech::liveapi::PlayerStatChanged* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerStatChanged>(Arena*);
template<> ::rtech::liveapi::PlayerUpgradeTierChanged* Arena::CreateMaybeMessage<::rtech::liveapi::PlayerUpgradeTierChanged>(Arena*);
template<> ::rtech::liveapi::Request* Arena::CreateMaybeMessage<::rtech::liveapi::Request>(Arena*);
template<> ::rtech::liveapi::RequestStatus* Arena::CreateMaybeMessage<::rtech::liveapi::RequestStatus>(Arena*);
template<> ::rtech::liveapi::Response* Arena::CreateMaybeMessage<::rtech::liveapi::Response>(Arena*);
template<> ::rtech::liveapi::RevenantForgedShadowDamaged* Arena::CreateMaybeMessage<::rtech::liveapi::RevenantForgedShadowDamaged>(Arena*);
template<> ::rtech::liveapi::RingFinishedClosing* Arena::CreateMaybeMessage<::rtech::liveapi::RingFinishedClosing>(Arena*);
template<> ::rtech::liveapi::RingStartClosing* Arena::CreateMaybeMessage<::rtech::liveapi::RingStartClosing>(Arena*);
template<> ::rtech::liveapi::SquadEliminated* Arena::CreateMaybeMessage<::rtech::liveapi::SquadEliminated>(Arena*);
template<> ::rtech::liveapi::Vector3* Arena::CreateMaybeMessage<::rtech::liveapi::Vector3>(Arena*);
template<> ::rtech::liveapi::Version* Arena::CreateMaybeMessage<::rtech::liveapi::Version>(Arena*);
template<> ::rtech::liveapi::WarpGateUsed* Arena::CreateMaybeMessage<::rtech::liveapi::WarpGateUsed>(Arena*);
template<> ::rtech::liveapi::WeaponSwitched* Arena::CreateMaybeMessage<::rtech::liveapi::WeaponSwitched>(Arena*);
template<> ::rtech::liveapi::WraithPortal* Arena::CreateMaybeMessage<::rtech::liveapi::WraithPortal>(Arena*);
template<> ::rtech::liveapi::ZiplineUsed* Arena::CreateMaybeMessage<::rtech::liveapi::ZiplineUsed>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rtech {
namespace liveapi {

enum PlayerOfInterest : int {
  UNSPECIFIED = 0,
  NEXT = 1,
  PREVIOUS = 2,
  KILL_LEADER = 3,
  CLOSEST_ENEMY = 4,
  CLOSEST_PLAYER = 5,
  LATEST_ATTACKER = 6,
  PlayerOfInterest_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerOfInterest_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerOfInterest_IsValid(int value);
constexpr PlayerOfInterest PlayerOfInterest_MIN = UNSPECIFIED;
constexpr PlayerOfInterest PlayerOfInterest_MAX = LATEST_ATTACKER;
constexpr int PlayerOfInterest_ARRAYSIZE = PlayerOfInterest_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerOfInterest_descriptor();
template<typename T>
inline const std::string& PlayerOfInterest_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerOfInterest>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerOfInterest_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerOfInterest_descriptor(), enum_t_value);
}
inline bool PlayerOfInterest_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerOfInterest* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerOfInterest>(
    PlayerOfInterest_descriptor(), name, value);
}
// ===================================================================

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNucleusHashFieldNumber = 9,
    kHardwareNameFieldNumber = 10,
    kTeamNameFieldNumber = 11,
    kCharacterFieldNumber = 13,
    kSkinFieldNumber = 14,
    kPosFieldNumber = 3,
    kAnglesFieldNumber = 4,
    kTeamIdFieldNumber = 2,
    kCurrentHealthFieldNumber = 5,
    kMaxHealthFieldNumber = 6,
    kShieldHealthFieldNumber = 7,
    kShieldMaxHealthFieldNumber = 8,
    kSquadIndexFieldNumber = 12,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string nucleusHash = 9;
  void clear_nucleushash();
  const std::string& nucleushash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nucleushash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nucleushash();
  PROTOBUF_NODISCARD std::string* release_nucleushash();
  void set_allocated_nucleushash(std::string* nucleushash);
  private:
  const std::string& _internal_nucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nucleushash(const std::string& value);
  std::string* _internal_mutable_nucleushash();
  public:

  // string hardwareName = 10;
  void clear_hardwarename();
  const std::string& hardwarename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardwarename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardwarename();
  PROTOBUF_NODISCARD std::string* release_hardwarename();
  void set_allocated_hardwarename(std::string* hardwarename);
  private:
  const std::string& _internal_hardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardwarename(const std::string& value);
  std::string* _internal_mutable_hardwarename();
  public:

  // string teamName = 11;
  void clear_teamname();
  const std::string& teamname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_teamname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_teamname();
  PROTOBUF_NODISCARD std::string* release_teamname();
  void set_allocated_teamname(std::string* teamname);
  private:
  const std::string& _internal_teamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_teamname(const std::string& value);
  std::string* _internal_mutable_teamname();
  public:

  // string character = 13;
  void clear_character();
  const std::string& character() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_character(ArgT0&& arg0, ArgT... args);
  std::string* mutable_character();
  PROTOBUF_NODISCARD std::string* release_character();
  void set_allocated_character(std::string* character);
  private:
  const std::string& _internal_character() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character(const std::string& value);
  std::string* _internal_mutable_character();
  public:

  // string skin = 14;
  void clear_skin();
  const std::string& skin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skin();
  PROTOBUF_NODISCARD std::string* release_skin();
  void set_allocated_skin(std::string* skin);
  private:
  const std::string& _internal_skin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skin(const std::string& value);
  std::string* _internal_mutable_skin();
  public:

  // .rtech.liveapi.Vector3 pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::rtech::liveapi::Vector3& pos() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_pos();
  ::rtech::liveapi::Vector3* mutable_pos();
  void set_allocated_pos(::rtech::liveapi::Vector3* pos);
  private:
  const ::rtech::liveapi::Vector3& _internal_pos() const;
  ::rtech::liveapi::Vector3* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::rtech::liveapi::Vector3* pos);
  ::rtech::liveapi::Vector3* unsafe_arena_release_pos();

  // .rtech.liveapi.Vector3 angles = 4;
  bool has_angles() const;
  private:
  bool _internal_has_angles() const;
  public:
  void clear_angles();
  const ::rtech::liveapi::Vector3& angles() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_angles();
  ::rtech::liveapi::Vector3* mutable_angles();
  void set_allocated_angles(::rtech::liveapi::Vector3* angles);
  private:
  const ::rtech::liveapi::Vector3& _internal_angles() const;
  ::rtech::liveapi::Vector3* _internal_mutable_angles();
  public:
  void unsafe_arena_set_allocated_angles(
      ::rtech::liveapi::Vector3* angles);
  ::rtech::liveapi::Vector3* unsafe_arena_release_angles();

  // uint32 teamId = 2;
  void clear_teamid();
  uint32_t teamid() const;
  void set_teamid(uint32_t value);
  private:
  uint32_t _internal_teamid() const;
  void _internal_set_teamid(uint32_t value);
  public:

  // uint32 currentHealth = 5;
  void clear_currenthealth();
  uint32_t currenthealth() const;
  void set_currenthealth(uint32_t value);
  private:
  uint32_t _internal_currenthealth() const;
  void _internal_set_currenthealth(uint32_t value);
  public:

  // uint32 maxHealth = 6;
  void clear_maxhealth();
  uint32_t maxhealth() const;
  void set_maxhealth(uint32_t value);
  private:
  uint32_t _internal_maxhealth() const;
  void _internal_set_maxhealth(uint32_t value);
  public:

  // uint32 shieldHealth = 7;
  void clear_shieldhealth();
  uint32_t shieldhealth() const;
  void set_shieldhealth(uint32_t value);
  private:
  uint32_t _internal_shieldhealth() const;
  void _internal_set_shieldhealth(uint32_t value);
  public:

  // uint32 shieldMaxHealth = 8;
  void clear_shieldmaxhealth();
  uint32_t shieldmaxhealth() const;
  void set_shieldmaxhealth(uint32_t value);
  private:
  uint32_t _internal_shieldmaxhealth() const;
  void _internal_set_shieldmaxhealth(uint32_t value);
  public:

  // uint32 squadIndex = 12;
  void clear_squadindex();
  uint32_t squadindex() const;
  void set_squadindex(uint32_t value);
  private:
  uint32_t _internal_squadindex() const;
  void _internal_set_squadindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nucleushash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardwarename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr teamname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skin_;
    ::rtech::liveapi::Vector3* pos_;
    ::rtech::liveapi::Vector3* angles_;
    uint32_t teamid_;
    uint32_t currenthealth_;
    uint32_t maxhealth_;
    uint32_t shieldhealth_;
    uint32_t shieldmaxhealth_;
    uint32_t squadindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_LobbyPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_LobbyPlayer) */ {
 public:
  inline CustomMatch_LobbyPlayer() : CustomMatch_LobbyPlayer(nullptr) {}
  ~CustomMatch_LobbyPlayer() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_LobbyPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_LobbyPlayer(const CustomMatch_LobbyPlayer& from);
  CustomMatch_LobbyPlayer(CustomMatch_LobbyPlayer&& from) noexcept
    : CustomMatch_LobbyPlayer() {
    *this = ::std::move(from);
  }

  inline CustomMatch_LobbyPlayer& operator=(const CustomMatch_LobbyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_LobbyPlayer& operator=(CustomMatch_LobbyPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_LobbyPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_LobbyPlayer* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_LobbyPlayer*>(
               &_CustomMatch_LobbyPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CustomMatch_LobbyPlayer& a, CustomMatch_LobbyPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_LobbyPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_LobbyPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_LobbyPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_LobbyPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_LobbyPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_LobbyPlayer& from) {
    CustomMatch_LobbyPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_LobbyPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_LobbyPlayer";
  }
  protected:
  explicit CustomMatch_LobbyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNucleusHashFieldNumber = 3,
    kHardwareNameFieldNumber = 4,
    kTeamIdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string nucleusHash = 3;
  void clear_nucleushash();
  const std::string& nucleushash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nucleushash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nucleushash();
  PROTOBUF_NODISCARD std::string* release_nucleushash();
  void set_allocated_nucleushash(std::string* nucleushash);
  private:
  const std::string& _internal_nucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nucleushash(const std::string& value);
  std::string* _internal_mutable_nucleushash();
  public:

  // string hardwareName = 4;
  void clear_hardwarename();
  const std::string& hardwarename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardwarename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardwarename();
  PROTOBUF_NODISCARD std::string* release_hardwarename();
  void set_allocated_hardwarename(std::string* hardwarename);
  private:
  const std::string& _internal_hardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardwarename(const std::string& value);
  std::string* _internal_mutable_hardwarename();
  public:

  // uint32 teamId = 2;
  void clear_teamid();
  uint32_t teamid() const;
  void set_teamid(uint32_t value);
  private:
  uint32_t _internal_teamid() const;
  void _internal_set_teamid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_LobbyPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nucleushash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardwarename_;
    uint32_t teamid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class Datacenter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Datacenter) */ {
 public:
  inline Datacenter() : Datacenter(nullptr) {}
  ~Datacenter() override;
  explicit PROTOBUF_CONSTEXPR Datacenter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Datacenter(const Datacenter& from);
  Datacenter(Datacenter&& from) noexcept
    : Datacenter() {
    *this = ::std::move(from);
  }

  inline Datacenter& operator=(const Datacenter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datacenter& operator=(Datacenter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datacenter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Datacenter* internal_default_instance() {
    return reinterpret_cast<const Datacenter*>(
               &_Datacenter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Datacenter& a, Datacenter& b) {
    a.Swap(&b);
  }
  inline void Swap(Datacenter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datacenter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Datacenter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Datacenter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Datacenter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Datacenter& from) {
    Datacenter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datacenter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Datacenter";
  }
  protected:
  explicit Datacenter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kNameFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.Datacenter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRevisionFieldNumber = 4,
    kMajorNumFieldNumber = 1,
    kMinorNumFieldNumber = 2,
    kBuildStampFieldNumber = 3,
  };
  // string revision = 4;
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // uint32 major_num = 1;
  void clear_major_num();
  uint32_t major_num() const;
  void set_major_num(uint32_t value);
  private:
  uint32_t _internal_major_num() const;
  void _internal_set_major_num(uint32_t value);
  public:

  // uint32 minor_num = 2;
  void clear_minor_num();
  uint32_t minor_num() const;
  void set_minor_num(uint32_t value);
  private:
  uint32_t _internal_minor_num() const;
  void _internal_set_minor_num(uint32_t value);
  public:

  // uint32 build_stamp = 3;
  void clear_build_stamp();
  uint32_t build_stamp() const;
  void set_build_stamp(uint32_t value);
  private:
  uint32_t _internal_build_stamp() const;
  void _internal_set_build_stamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
    uint32_t major_num_;
    uint32_t minor_num_;
    uint32_t build_stamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class InventoryItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryItem) */ {
 public:
  inline InventoryItem() : InventoryItem(nullptr) {}
  ~InventoryItem() override;
  explicit PROTOBUF_CONSTEXPR InventoryItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryItem(const InventoryItem& from);
  InventoryItem(InventoryItem&& from) noexcept
    : InventoryItem() {
    *this = ::std::move(from);
  }

  inline InventoryItem& operator=(const InventoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryItem& operator=(InventoryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryItem* internal_default_instance() {
    return reinterpret_cast<const InventoryItem*>(
               &_InventoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InventoryItem& a, InventoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InventoryItem& from) {
    InventoryItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.InventoryItem";
  }
  protected:
  explicit InventoryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 2,
    kExtraDataFieldNumber = 3,
    kQuantityFieldNumber = 1,
  };
  // string item = 2;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // string extraData = 3;
  void clear_extradata();
  const std::string& extradata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extradata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extradata();
  PROTOBUF_NODISCARD std::string* release_extradata();
  void set_allocated_extradata(std::string* extradata);
  private:
  const std::string& _internal_extradata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extradata(const std::string& value);
  std::string* _internal_mutable_extradata();
  public:

  // int32 quantity = 1;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extradata_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class LoadoutConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.LoadoutConfiguration) */ {
 public:
  inline LoadoutConfiguration() : LoadoutConfiguration(nullptr) {}
  ~LoadoutConfiguration() override;
  explicit PROTOBUF_CONSTEXPR LoadoutConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadoutConfiguration(const LoadoutConfiguration& from);
  LoadoutConfiguration(LoadoutConfiguration&& from) noexcept
    : LoadoutConfiguration() {
    *this = ::std::move(from);
  }

  inline LoadoutConfiguration& operator=(const LoadoutConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadoutConfiguration& operator=(LoadoutConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadoutConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadoutConfiguration* internal_default_instance() {
    return reinterpret_cast<const LoadoutConfiguration*>(
               &_LoadoutConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadoutConfiguration& a, LoadoutConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadoutConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadoutConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadoutConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadoutConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadoutConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadoutConfiguration& from) {
    LoadoutConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadoutConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.LoadoutConfiguration";
  }
  protected:
  explicit LoadoutConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponsFieldNumber = 1,
    kEquipmentFieldNumber = 2,
  };
  // repeated .rtech.liveapi.InventoryItem weapons = 1;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;
  public:
  void clear_weapons();
  ::rtech::liveapi::InventoryItem* mutable_weapons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >*
      mutable_weapons();
  private:
  const ::rtech::liveapi::InventoryItem& _internal_weapons(int index) const;
  ::rtech::liveapi::InventoryItem* _internal_add_weapons();
  public:
  const ::rtech::liveapi::InventoryItem& weapons(int index) const;
  ::rtech::liveapi::InventoryItem* add_weapons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >&
      weapons() const;

  // repeated .rtech.liveapi.InventoryItem equipment = 2;
  int equipment_size() const;
  private:
  int _internal_equipment_size() const;
  public:
  void clear_equipment();
  ::rtech::liveapi::InventoryItem* mutable_equipment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >*
      mutable_equipment();
  private:
  const ::rtech::liveapi::InventoryItem& _internal_equipment(int index) const;
  ::rtech::liveapi::InventoryItem* _internal_add_equipment();
  public:
  const ::rtech::liveapi::InventoryItem& equipment(int index) const;
  ::rtech::liveapi::InventoryItem* add_equipment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >&
      equipment() const;

  // @@protoc_insertion_point(class_scope:rtech.liveapi.LoadoutConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem > weapons_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem > equipment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class Init final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Init) */ {
 public:
  inline Init() : Init(nullptr) {}
  ~Init() override;
  explicit PROTOBUF_CONSTEXPR Init(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Init(const Init& from);
  Init(Init&& from) noexcept
    : Init() {
    *this = ::std::move(from);
  }

  inline Init& operator=(const Init& from) {
    CopyFrom(from);
    return *this;
  }
  inline Init& operator=(Init&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Init& default_instance() {
    return *internal_default_instance();
  }
  static inline const Init* internal_default_instance() {
    return reinterpret_cast<const Init*>(
               &_Init_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Init& a, Init& b) {
    a.Swap(&b);
  }
  inline void Swap(Init* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Init* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Init* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Init>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Init& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Init& from) {
    Init::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Init* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Init";
  }
  protected:
  explicit Init(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kGameVersionFieldNumber = 3,
    kPlatformFieldNumber = 5,
    kNameFieldNumber = 6,
    kApiVersionFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string gameVersion = 3;
  void clear_gameversion();
  const std::string& gameversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gameversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gameversion();
  PROTOBUF_NODISCARD std::string* release_gameversion();
  void set_allocated_gameversion(std::string* gameversion);
  private:
  const std::string& _internal_gameversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gameversion(const std::string& value);
  std::string* _internal_mutable_gameversion();
  public:

  // string platform = 5;
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .rtech.liveapi.Version apiVersion = 4;
  bool has_apiversion() const;
  private:
  bool _internal_has_apiversion() const;
  public:
  void clear_apiversion();
  const ::rtech::liveapi::Version& apiversion() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Version* release_apiversion();
  ::rtech::liveapi::Version* mutable_apiversion();
  void set_allocated_apiversion(::rtech::liveapi::Version* apiversion);
  private:
  const ::rtech::liveapi::Version& _internal_apiversion() const;
  ::rtech::liveapi::Version* _internal_mutable_apiversion();
  public:
  void unsafe_arena_set_allocated_apiversion(
      ::rtech::liveapi::Version* apiversion);
  ::rtech::liveapi::Version* unsafe_arena_release_apiversion();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.Init)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::rtech::liveapi::Version* apiversion_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_LobbyPlayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_LobbyPlayers) */ {
 public:
  inline CustomMatch_LobbyPlayers() : CustomMatch_LobbyPlayers(nullptr) {}
  ~CustomMatch_LobbyPlayers() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_LobbyPlayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_LobbyPlayers(const CustomMatch_LobbyPlayers& from);
  CustomMatch_LobbyPlayers(CustomMatch_LobbyPlayers&& from) noexcept
    : CustomMatch_LobbyPlayers() {
    *this = ::std::move(from);
  }

  inline CustomMatch_LobbyPlayers& operator=(const CustomMatch_LobbyPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_LobbyPlayers& operator=(CustomMatch_LobbyPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_LobbyPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_LobbyPlayers* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_LobbyPlayers*>(
               &_CustomMatch_LobbyPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CustomMatch_LobbyPlayers& a, CustomMatch_LobbyPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_LobbyPlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_LobbyPlayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_LobbyPlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_LobbyPlayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_LobbyPlayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_LobbyPlayers& from) {
    CustomMatch_LobbyPlayers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_LobbyPlayers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_LobbyPlayers";
  }
  protected:
  explicit CustomMatch_LobbyPlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kPlayerTokenFieldNumber = 1,
  };
  // repeated .rtech.liveapi.CustomMatch_LobbyPlayer players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::rtech::liveapi::CustomMatch_LobbyPlayer* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer >*
      mutable_players();
  private:
  const ::rtech::liveapi::CustomMatch_LobbyPlayer& _internal_players(int index) const;
  ::rtech::liveapi::CustomMatch_LobbyPlayer* _internal_add_players();
  public:
  const ::rtech::liveapi::CustomMatch_LobbyPlayer& players(int index) const;
  ::rtech::liveapi::CustomMatch_LobbyPlayer* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer >&
      players() const;

  // string playerToken = 1;
  void clear_playertoken();
  const std::string& playertoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playertoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playertoken();
  PROTOBUF_NODISCARD std::string* release_playertoken();
  void set_allocated_playertoken(std::string* playertoken);
  private:
  const std::string& _internal_playertoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playertoken(const std::string& value);
  std::string* _internal_mutable_playertoken();
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_LobbyPlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer > players_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playertoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class ObserverSwitched final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ObserverSwitched) */ {
 public:
  inline ObserverSwitched() : ObserverSwitched(nullptr) {}
  ~ObserverSwitched() override;
  explicit PROTOBUF_CONSTEXPR ObserverSwitched(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObserverSwitched(const ObserverSwitched& from);
  ObserverSwitched(ObserverSwitched&& from) noexcept
    : ObserverSwitched() {
    *this = ::std::move(from);
  }

  inline ObserverSwitched& operator=(const ObserverSwitched& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObserverSwitched& operator=(ObserverSwitched&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObserverSwitched& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObserverSwitched* internal_default_instance() {
    return reinterpret_cast<const ObserverSwitched*>(
               &_ObserverSwitched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObserverSwitched& a, ObserverSwitched& b) {
    a.Swap(&b);
  }
  inline void Swap(ObserverSwitched* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObserverSwitched* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObserverSwitched* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObserverSwitched>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObserverSwitched& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObserverSwitched& from) {
    ObserverSwitched::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObserverSwitched* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.ObserverSwitched";
  }
  protected:
  explicit ObserverSwitched(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTeamFieldNumber = 5,
    kCategoryFieldNumber = 2,
    kObserverFieldNumber = 3,
    kTargetFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player targetTeam = 5;
  int targetteam_size() const;
  private:
  int _internal_targetteam_size() const;
  public:
  void clear_targetteam();
  ::rtech::liveapi::Player* mutable_targetteam(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_targetteam();
  private:
  const ::rtech::liveapi::Player& _internal_targetteam(int index) const;
  ::rtech::liveapi::Player* _internal_add_targetteam();
  public:
  const ::rtech::liveapi::Player& targetteam(int index) const;
  ::rtech::liveapi::Player* add_targetteam();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
      targetteam() const;

  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player observer = 3;
  bool has_observer() const;
  private:
  bool _internal_has_observer() const;
  public:
  void clear_observer();
  const ::rtech::liveapi::Player& observer() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_observer();
  ::rtech::liveapi::Player* mutable_observer();
  void set_allocated_observer(::rtech::liveapi::Player* observer);
  private:
  const ::rtech::liveapi::Player& _internal_observer() const;
  ::rtech::liveapi::Player* _internal_mutable_observer();
  public:
  void unsafe_arena_set_allocated_observer(
      ::rtech::liveapi::Player* observer);
  ::rtech::liveapi::Player* unsafe_arena_release_observer();

  // .rtech.liveapi.Player target = 4;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::rtech::liveapi::Player& target() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_target();
  ::rtech::liveapi::Player* mutable_target();
  void set_allocated_target(::rtech::liveapi::Player* target);
  private:
  const ::rtech::liveapi::Player& _internal_target() const;
  ::rtech::liveapi::Player* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::rtech::liveapi::Player* target);
  ::rtech::liveapi::Player* unsafe_arena_release_target();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.ObserverSwitched)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player > targetteam_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* observer_;
    ::rtech::liveapi::Player* target_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class ObserverAnnotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ObserverAnnotation) */ {
 public:
  inline ObserverAnnotation() : ObserverAnnotation(nullptr) {}
  ~ObserverAnnotation() override;
  explicit PROTOBUF_CONSTEXPR ObserverAnnotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObserverAnnotation(const ObserverAnnotation& from);
  ObserverAnnotation(ObserverAnnotation&& from) noexcept
    : ObserverAnnotation() {
    *this = ::std::move(from);
  }

  inline ObserverAnnotation& operator=(const ObserverAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObserverAnnotation& operator=(ObserverAnnotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObserverAnnotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObserverAnnotation* internal_default_instance() {
    return reinterpret_cast<const ObserverAnnotation*>(
               &_ObserverAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ObserverAnnotation& a, ObserverAnnotation& b) {
    a.Swap(&b);
  }
  inline void Swap(ObserverAnnotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObserverAnnotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObserverAnnotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObserverAnnotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObserverAnnotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObserverAnnotation& from) {
    ObserverAnnotation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObserverAnnotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.ObserverAnnotation";
  }
  protected:
  explicit ObserverAnnotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kAnnotationSerialFieldNumber = 3,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 annotationSerial = 3;
  void clear_annotationserial();
  int32_t annotationserial() const;
  void set_annotationserial(int32_t value);
  private:
  int32_t _internal_annotationserial() const;
  void _internal_set_annotationserial(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.ObserverAnnotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    uint64_t timestamp_;
    int32_t annotationserial_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class MatchSetup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.MatchSetup) */ {
 public:
  inline MatchSetup() : MatchSetup(nullptr) {}
  ~MatchSetup() override;
  explicit PROTOBUF_CONSTEXPR MatchSetup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchSetup(const MatchSetup& from);
  MatchSetup(MatchSetup&& from) noexcept
    : MatchSetup() {
    *this = ::std::move(from);
  }

  inline MatchSetup& operator=(const MatchSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchSetup& operator=(MatchSetup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchSetup& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchSetup* internal_default_instance() {
    return reinterpret_cast<const MatchSetup*>(
               &_MatchSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MatchSetup& a, MatchSetup& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchSetup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchSetup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchSetup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchSetup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchSetup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatchSetup& from) {
    MatchSetup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchSetup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.MatchSetup";
  }
  protected:
  explicit MatchSetup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kMapFieldNumber = 3,
    kPlaylistNameFieldNumber = 4,
    kPlaylistDescFieldNumber = 5,
    kServerIdFieldNumber = 9,
    kDatacenterFieldNumber = 6,
    kStartingLoadoutFieldNumber = 10,
    kTimestampFieldNumber = 1,
    kAimAssistOnFieldNumber = 7,
    kAnonymousModeFieldNumber = 8,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string map = 3;
  void clear_map();
  const std::string& map() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map();
  PROTOBUF_NODISCARD std::string* release_map();
  void set_allocated_map(std::string* map);
  private:
  const std::string& _internal_map() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map(const std::string& value);
  std::string* _internal_mutable_map();
  public:

  // string playlistName = 4;
  void clear_playlistname();
  const std::string& playlistname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playlistname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playlistname();
  PROTOBUF_NODISCARD std::string* release_playlistname();
  void set_allocated_playlistname(std::string* playlistname);
  private:
  const std::string& _internal_playlistname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlistname(const std::string& value);
  std::string* _internal_mutable_playlistname();
  public:

  // string playlistDesc = 5;
  void clear_playlistdesc();
  const std::string& playlistdesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playlistdesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playlistdesc();
  PROTOBUF_NODISCARD std::string* release_playlistdesc();
  void set_allocated_playlistdesc(std::string* playlistdesc);
  private:
  const std::string& _internal_playlistdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlistdesc(const std::string& value);
  std::string* _internal_mutable_playlistdesc();
  public:

  // string serverId = 9;
  void clear_serverid();
  const std::string& serverid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverid();
  PROTOBUF_NODISCARD std::string* release_serverid();
  void set_allocated_serverid(std::string* serverid);
  private:
  const std::string& _internal_serverid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverid(const std::string& value);
  std::string* _internal_mutable_serverid();
  public:

  // .rtech.liveapi.Datacenter datacenter = 6;
  bool has_datacenter() const;
  private:
  bool _internal_has_datacenter() const;
  public:
  void clear_datacenter();
  const ::rtech::liveapi::Datacenter& datacenter() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Datacenter* release_datacenter();
  ::rtech::liveapi::Datacenter* mutable_datacenter();
  void set_allocated_datacenter(::rtech::liveapi::Datacenter* datacenter);
  private:
  const ::rtech::liveapi::Datacenter& _internal_datacenter() const;
  ::rtech::liveapi::Datacenter* _internal_mutable_datacenter();
  public:
  void unsafe_arena_set_allocated_datacenter(
      ::rtech::liveapi::Datacenter* datacenter);
  ::rtech::liveapi::Datacenter* unsafe_arena_release_datacenter();

  // .rtech.liveapi.LoadoutConfiguration startingLoadout = 10;
  bool has_startingloadout() const;
  private:
  bool _internal_has_startingloadout() const;
  public:
  void clear_startingloadout();
  const ::rtech::liveapi::LoadoutConfiguration& startingloadout() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::LoadoutConfiguration* release_startingloadout();
  ::rtech::liveapi::LoadoutConfiguration* mutable_startingloadout();
  void set_allocated_startingloadout(::rtech::liveapi::LoadoutConfiguration* startingloadout);
  private:
  const ::rtech::liveapi::LoadoutConfiguration& _internal_startingloadout() const;
  ::rtech::liveapi::LoadoutConfiguration* _internal_mutable_startingloadout();
  public:
  void unsafe_arena_set_allocated_startingloadout(
      ::rtech::liveapi::LoadoutConfiguration* startingloadout);
  ::rtech::liveapi::LoadoutConfiguration* unsafe_arena_release_startingloadout();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // bool aimAssistOn = 7;
  void clear_aimassiston();
  bool aimassiston() const;
  void set_aimassiston(bool value);
  private:
  bool _internal_aimassiston() const;
  void _internal_set_aimassiston(bool value);
  public:

  // bool anonymousMode = 8;
  void clear_anonymousmode();
  bool anonymousmode() const;
  void set_anonymousmode(bool value);
  private:
  bool _internal_anonymousmode() const;
  void _internal_set_anonymousmode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.MatchSetup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playlistname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playlistdesc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverid_;
    ::rtech::liveapi::Datacenter* datacenter_;
    ::rtech::liveapi::LoadoutConfiguration* startingloadout_;
    uint64_t timestamp_;
    bool aimassiston_;
    bool anonymousmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class GameStateChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.GameStateChanged) */ {
 public:
  inline GameStateChanged() : GameStateChanged(nullptr) {}
  ~GameStateChanged() override;
  explicit PROTOBUF_CONSTEXPR GameStateChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStateChanged(const GameStateChanged& from);
  GameStateChanged(GameStateChanged&& from) noexcept
    : GameStateChanged() {
    *this = ::std::move(from);
  }

  inline GameStateChanged& operator=(const GameStateChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStateChanged& operator=(GameStateChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStateChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStateChanged* internal_default_instance() {
    return reinterpret_cast<const GameStateChanged*>(
               &_GameStateChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GameStateChanged& a, GameStateChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStateChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStateChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStateChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStateChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameStateChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameStateChanged& from) {
    GameStateChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStateChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.GameStateChanged";
  }
  protected:
  explicit GameStateChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kStateFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string state = 3;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.GameStateChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CharacterSelected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CharacterSelected) */ {
 public:
  inline CharacterSelected() : CharacterSelected(nullptr) {}
  ~CharacterSelected() override;
  explicit PROTOBUF_CONSTEXPR CharacterSelected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterSelected(const CharacterSelected& from);
  CharacterSelected(CharacterSelected&& from) noexcept
    : CharacterSelected() {
    *this = ::std::move(from);
  }

  inline CharacterSelected& operator=(const CharacterSelected& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterSelected& operator=(CharacterSelected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterSelected& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterSelected* internal_default_instance() {
    return reinterpret_cast<const CharacterSelected*>(
               &_CharacterSelected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CharacterSelected& a, CharacterSelected& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterSelected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterSelected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterSelected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterSelected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterSelected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterSelected& from) {
    CharacterSelected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterSelected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CharacterSelected";
  }
  protected:
  explicit CharacterSelected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CharacterSelected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class MatchStateEnd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.MatchStateEnd) */ {
 public:
  inline MatchStateEnd() : MatchStateEnd(nullptr) {}
  ~MatchStateEnd() override;
  explicit PROTOBUF_CONSTEXPR MatchStateEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchStateEnd(const MatchStateEnd& from);
  MatchStateEnd(MatchStateEnd&& from) noexcept
    : MatchStateEnd() {
    *this = ::std::move(from);
  }

  inline MatchStateEnd& operator=(const MatchStateEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchStateEnd& operator=(MatchStateEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchStateEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchStateEnd* internal_default_instance() {
    return reinterpret_cast<const MatchStateEnd*>(
               &_MatchStateEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MatchStateEnd& a, MatchStateEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchStateEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchStateEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchStateEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchStateEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchStateEnd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatchStateEnd& from) {
    MatchStateEnd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchStateEnd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.MatchStateEnd";
  }
  protected:
  explicit MatchStateEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWinnersFieldNumber = 4,
    kCategoryFieldNumber = 2,
    kStateFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player winners = 4;
  int winners_size() const;
  private:
  int _internal_winners_size() const;
  public:
  void clear_winners();
  ::rtech::liveapi::Player* mutable_winners(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_winners();
  private:
  const ::rtech::liveapi::Player& _internal_winners(int index) const;
  ::rtech::liveapi::Player* _internal_add_winners();
  public:
  const ::rtech::liveapi::Player& winners(int index) const;
  ::rtech::liveapi::Player* add_winners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
      winners() const;

  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string state = 3;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.MatchStateEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player > winners_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class RingStartClosing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RingStartClosing) */ {
 public:
  inline RingStartClosing() : RingStartClosing(nullptr) {}
  ~RingStartClosing() override;
  explicit PROTOBUF_CONSTEXPR RingStartClosing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RingStartClosing(const RingStartClosing& from);
  RingStartClosing(RingStartClosing&& from) noexcept
    : RingStartClosing() {
    *this = ::std::move(from);
  }

  inline RingStartClosing& operator=(const RingStartClosing& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingStartClosing& operator=(RingStartClosing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RingStartClosing& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingStartClosing* internal_default_instance() {
    return reinterpret_cast<const RingStartClosing*>(
               &_RingStartClosing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RingStartClosing& a, RingStartClosing& b) {
    a.Swap(&b);
  }
  inline void Swap(RingStartClosing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingStartClosing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingStartClosing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingStartClosing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RingStartClosing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RingStartClosing& from) {
    RingStartClosing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RingStartClosing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.RingStartClosing";
  }
  protected:
  explicit RingStartClosing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kCenterFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kStageFieldNumber = 3,
    kCurrentRadiusFieldNumber = 5,
    kEndRadiusFieldNumber = 6,
    kShrinkDurationFieldNumber = 7,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Vector3 center = 4;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::rtech::liveapi::Vector3& center() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_center();
  ::rtech::liveapi::Vector3* mutable_center();
  void set_allocated_center(::rtech::liveapi::Vector3* center);
  private:
  const ::rtech::liveapi::Vector3& _internal_center() const;
  ::rtech::liveapi::Vector3* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::rtech::liveapi::Vector3* center);
  ::rtech::liveapi::Vector3* unsafe_arena_release_center();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 stage = 3;
  void clear_stage();
  uint32_t stage() const;
  void set_stage(uint32_t value);
  private:
  uint32_t _internal_stage() const;
  void _internal_set_stage(uint32_t value);
  public:

  // float currentRadius = 5;
  void clear_currentradius();
  float currentradius() const;
  void set_currentradius(float value);
  private:
  float _internal_currentradius() const;
  void _internal_set_currentradius(float value);
  public:

  // float endRadius = 6;
  void clear_endradius();
  float endradius() const;
  void set_endradius(float value);
  private:
  float _internal_endradius() const;
  void _internal_set_endradius(float value);
  public:

  // float shrinkDuration = 7;
  void clear_shrinkduration();
  float shrinkduration() const;
  void set_shrinkduration(float value);
  private:
  float _internal_shrinkduration() const;
  void _internal_set_shrinkduration(float value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.RingStartClosing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Vector3* center_;
    uint64_t timestamp_;
    uint32_t stage_;
    float currentradius_;
    float endradius_;
    float shrinkduration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class RingFinishedClosing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RingFinishedClosing) */ {
 public:
  inline RingFinishedClosing() : RingFinishedClosing(nullptr) {}
  ~RingFinishedClosing() override;
  explicit PROTOBUF_CONSTEXPR RingFinishedClosing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RingFinishedClosing(const RingFinishedClosing& from);
  RingFinishedClosing(RingFinishedClosing&& from) noexcept
    : RingFinishedClosing() {
    *this = ::std::move(from);
  }

  inline RingFinishedClosing& operator=(const RingFinishedClosing& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingFinishedClosing& operator=(RingFinishedClosing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RingFinishedClosing& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingFinishedClosing* internal_default_instance() {
    return reinterpret_cast<const RingFinishedClosing*>(
               &_RingFinishedClosing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RingFinishedClosing& a, RingFinishedClosing& b) {
    a.Swap(&b);
  }
  inline void Swap(RingFinishedClosing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingFinishedClosing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingFinishedClosing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingFinishedClosing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RingFinishedClosing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RingFinishedClosing& from) {
    RingFinishedClosing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RingFinishedClosing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.RingFinishedClosing";
  }
  protected:
  explicit RingFinishedClosing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kCenterFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kStageFieldNumber = 3,
    kCurrentRadiusFieldNumber = 5,
    kShrinkDurationFieldNumber = 7,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Vector3 center = 4;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::rtech::liveapi::Vector3& center() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Vector3* release_center();
  ::rtech::liveapi::Vector3* mutable_center();
  void set_allocated_center(::rtech::liveapi::Vector3* center);
  private:
  const ::rtech::liveapi::Vector3& _internal_center() const;
  ::rtech::liveapi::Vector3* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::rtech::liveapi::Vector3* center);
  ::rtech::liveapi::Vector3* unsafe_arena_release_center();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 stage = 3;
  void clear_stage();
  uint32_t stage() const;
  void set_stage(uint32_t value);
  private:
  uint32_t _internal_stage() const;
  void _internal_set_stage(uint32_t value);
  public:

  // float currentRadius = 5;
  void clear_currentradius();
  float currentradius() const;
  void set_currentradius(float value);
  private:
  float _internal_currentradius() const;
  void _internal_set_currentradius(float value);
  public:

  // float shrinkDuration = 7;
  void clear_shrinkduration();
  float shrinkduration() const;
  void set_shrinkduration(float value);
  private:
  float _internal_shrinkduration() const;
  void _internal_set_shrinkduration(float value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.RingFinishedClosing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Vector3* center_;
    uint64_t timestamp_;
    uint32_t stage_;
    float currentradius_;
    float shrinkduration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerConnected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerConnected) */ {
 public:
  inline PlayerConnected() : PlayerConnected(nullptr) {}
  ~PlayerConnected() override;
  explicit PROTOBUF_CONSTEXPR PlayerConnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerConnected(const PlayerConnected& from);
  PlayerConnected(PlayerConnected&& from) noexcept
    : PlayerConnected() {
    *this = ::std::move(from);
  }

  inline PlayerConnected& operator=(const PlayerConnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerConnected& operator=(PlayerConnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerConnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerConnected* internal_default_instance() {
    return reinterpret_cast<const PlayerConnected*>(
               &_PlayerConnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PlayerConnected& a, PlayerConnected& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerConnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerConnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerConnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerConnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerConnected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerConnected& from) {
    PlayerConnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerConnected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerConnected";
  }
  protected:
  explicit PlayerConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerConnected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerDisconnected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerDisconnected) */ {
 public:
  inline PlayerDisconnected() : PlayerDisconnected(nullptr) {}
  ~PlayerDisconnected() override;
  explicit PROTOBUF_CONSTEXPR PlayerDisconnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerDisconnected(const PlayerDisconnected& from);
  PlayerDisconnected(PlayerDisconnected&& from) noexcept
    : PlayerDisconnected() {
    *this = ::std::move(from);
  }

  inline PlayerDisconnected& operator=(const PlayerDisconnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDisconnected& operator=(PlayerDisconnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDisconnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDisconnected* internal_default_instance() {
    return reinterpret_cast<const PlayerDisconnected*>(
               &_PlayerDisconnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PlayerDisconnected& a, PlayerDisconnected& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDisconnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDisconnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDisconnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDisconnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerDisconnected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerDisconnected& from) {
    PlayerDisconnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerDisconnected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerDisconnected";
  }
  protected:
  explicit PlayerDisconnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kCanReconnectFieldNumber = 4,
    kIsAliveFieldNumber = 5,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // bool canReconnect = 4;
  void clear_canreconnect();
  bool canreconnect() const;
  void set_canreconnect(bool value);
  private:
  bool _internal_canreconnect() const;
  void _internal_set_canreconnect(bool value);
  public:

  // bool isAlive = 5;
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool value);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerDisconnected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    bool canreconnect_;
    bool isalive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerStatChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerStatChanged) */ {
 public:
  inline PlayerStatChanged() : PlayerStatChanged(nullptr) {}
  ~PlayerStatChanged() override;
  explicit PROTOBUF_CONSTEXPR PlayerStatChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerStatChanged(const PlayerStatChanged& from);
  PlayerStatChanged(PlayerStatChanged&& from) noexcept
    : PlayerStatChanged() {
    *this = ::std::move(from);
  }

  inline PlayerStatChanged& operator=(const PlayerStatChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerStatChanged& operator=(PlayerStatChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerStatChanged& default_instance() {
    return *internal_default_instance();
  }
  enum NewValueCase {
    kIntValue = 5,
    kFloatValue = 6,
    kBoolValue = 7,
    NEWVALUE_NOT_SET = 0,
  };

  static inline const PlayerStatChanged* internal_default_instance() {
    return reinterpret_cast<const PlayerStatChanged*>(
               &_PlayerStatChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PlayerStatChanged& a, PlayerStatChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerStatChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerStatChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerStatChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerStatChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerStatChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerStatChanged& from) {
    PlayerStatChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerStatChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerStatChanged";
  }
  protected:
  explicit PlayerStatChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kStatNameFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kIntValueFieldNumber = 5,
    kFloatValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string statName = 4;
  void clear_statname();
  const std::string& statname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_statname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_statname();
  PROTOBUF_NODISCARD std::string* release_statname();
  void set_allocated_statname(std::string* statname);
  private:
  const std::string& _internal_statname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statname(const std::string& value);
  std::string* _internal_mutable_statname();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 intValue = 5;
  bool has_intvalue() const;
  private:
  bool _internal_has_intvalue() const;
  public:
  void clear_intvalue();
  uint32_t intvalue() const;
  void set_intvalue(uint32_t value);
  private:
  uint32_t _internal_intvalue() const;
  void _internal_set_intvalue(uint32_t value);
  public:

  // float floatValue = 6;
  bool has_floatvalue() const;
  private:
  bool _internal_has_floatvalue() const;
  public:
  void clear_floatvalue();
  float floatvalue() const;
  void set_floatvalue(float value);
  private:
  float _internal_floatvalue() const;
  void _internal_set_floatvalue(float value);
  public:

  // bool boolValue = 7;
  bool has_boolvalue() const;
  private:
  bool _internal_has_boolvalue() const;
  public:
  void clear_boolvalue();
  bool boolvalue() const;
  void set_boolvalue(bool value);
  private:
  bool _internal_boolvalue() const;
  void _internal_set_boolvalue(bool value);
  public:

  void clear_newValue();
  NewValueCase newValue_case() const;
  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerStatChanged)
 private:
  class _Internal;
  void set_has_intvalue();
  void set_has_floatvalue();
  void set_has_boolvalue();

  inline bool has_newValue() const;
  inline void clear_has_newValue();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr statname_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    union NewValueUnion {
      constexpr NewValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t intvalue_;
      float floatvalue_;
      bool boolvalue_;
    } newValue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerUpgradeTierChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerUpgradeTierChanged) */ {
 public:
  inline PlayerUpgradeTierChanged() : PlayerUpgradeTierChanged(nullptr) {}
  ~PlayerUpgradeTierChanged() override;
  explicit PROTOBUF_CONSTEXPR PlayerUpgradeTierChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerUpgradeTierChanged(const PlayerUpgradeTierChanged& from);
  PlayerUpgradeTierChanged(PlayerUpgradeTierChanged&& from) noexcept
    : PlayerUpgradeTierChanged() {
    *this = ::std::move(from);
  }

  inline PlayerUpgradeTierChanged& operator=(const PlayerUpgradeTierChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerUpgradeTierChanged& operator=(PlayerUpgradeTierChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerUpgradeTierChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerUpgradeTierChanged* internal_default_instance() {
    return reinterpret_cast<const PlayerUpgradeTierChanged*>(
               &_PlayerUpgradeTierChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PlayerUpgradeTierChanged& a, PlayerUpgradeTierChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerUpgradeTierChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerUpgradeTierChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerUpgradeTierChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerUpgradeTierChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerUpgradeTierChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerUpgradeTierChanged& from) {
    PlayerUpgradeTierChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerUpgradeTierChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerUpgradeTierChanged";
  }
  protected:
  explicit PlayerUpgradeTierChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kLevelFieldNumber = 4,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 level = 4;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerUpgradeTierChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerDamaged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerDamaged) */ {
 public:
  inline PlayerDamaged() : PlayerDamaged(nullptr) {}
  ~PlayerDamaged() override;
  explicit PROTOBUF_CONSTEXPR PlayerDamaged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerDamaged(const PlayerDamaged& from);
  PlayerDamaged(PlayerDamaged&& from) noexcept
    : PlayerDamaged() {
    *this = ::std::move(from);
  }

  inline PlayerDamaged& operator=(const PlayerDamaged& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDamaged& operator=(PlayerDamaged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDamaged& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDamaged* internal_default_instance() {
    return reinterpret_cast<const PlayerDamaged*>(
               &_PlayerDamaged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlayerDamaged& a, PlayerDamaged& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDamaged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDamaged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDamaged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDamaged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerDamaged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerDamaged& from) {
    PlayerDamaged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerDamaged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerDamaged";
  }
  protected:
  explicit PlayerDamaged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 5,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kDamageInflictedFieldNumber = 6,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string weapon = 5;
  void clear_weapon();
  const std::string& weapon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weapon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* weapon);
  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(const std::string& value);
  std::string* _internal_mutable_weapon();
  public:

  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  private:
  bool _internal_has_attacker() const;
  public:
  void clear_attacker();
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* attacker);
  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();
  public:
  void unsafe_arena_set_allocated_attacker(
      ::rtech::liveapi::Player* attacker);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* victim);
  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::rtech::liveapi::Player* victim);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 damageInflicted = 6;
  void clear_damageinflicted();
  uint32_t damageinflicted() const;
  void set_damageinflicted(uint32_t value);
  private:
  uint32_t _internal_damageinflicted() const;
  void _internal_set_damageinflicted(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerDamaged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    uint64_t timestamp_;
    uint32_t damageinflicted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerKilled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerKilled) */ {
 public:
  inline PlayerKilled() : PlayerKilled(nullptr) {}
  ~PlayerKilled() override;
  explicit PROTOBUF_CONSTEXPR PlayerKilled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerKilled(const PlayerKilled& from);
  PlayerKilled(PlayerKilled&& from) noexcept
    : PlayerKilled() {
    *this = ::std::move(from);
  }

  inline PlayerKilled& operator=(const PlayerKilled& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerKilled& operator=(PlayerKilled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerKilled& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerKilled* internal_default_instance() {
    return reinterpret_cast<const PlayerKilled*>(
               &_PlayerKilled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlayerKilled& a, PlayerKilled& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerKilled* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerKilled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerKilled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerKilled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerKilled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerKilled& from) {
    PlayerKilled::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerKilled* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerKilled";
  }
  protected:
  explicit PlayerKilled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 6,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kAwardedToFieldNumber = 5,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string weapon = 6;
  void clear_weapon();
  const std::string& weapon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weapon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* weapon);
  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(const std::string& value);
  std::string* _internal_mutable_weapon();
  public:

  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  private:
  bool _internal_has_attacker() const;
  public:
  void clear_attacker();
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* attacker);
  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();
  public:
  void unsafe_arena_set_allocated_attacker(
      ::rtech::liveapi::Player* attacker);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* victim);
  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::rtech::liveapi::Player* victim);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  // .rtech.liveapi.Player awardedTo = 5;
  bool has_awardedto() const;
  private:
  bool _internal_has_awardedto() const;
  public:
  void clear_awardedto();
  const ::rtech::liveapi::Player& awardedto() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_awardedto();
  ::rtech::liveapi::Player* mutable_awardedto();
  void set_allocated_awardedto(::rtech::liveapi::Player* awardedto);
  private:
  const ::rtech::liveapi::Player& _internal_awardedto() const;
  ::rtech::liveapi::Player* _internal_mutable_awardedto();
  public:
  void unsafe_arena_set_allocated_awardedto(
      ::rtech::liveapi::Player* awardedto);
  ::rtech::liveapi::Player* unsafe_arena_release_awardedto();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerKilled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    ::rtech::liveapi::Player* awardedto_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerDowned final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerDowned) */ {
 public:
  inline PlayerDowned() : PlayerDowned(nullptr) {}
  ~PlayerDowned() override;
  explicit PROTOBUF_CONSTEXPR PlayerDowned(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerDowned(const PlayerDowned& from);
  PlayerDowned(PlayerDowned&& from) noexcept
    : PlayerDowned() {
    *this = ::std::move(from);
  }

  inline PlayerDowned& operator=(const PlayerDowned& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerDowned& operator=(PlayerDowned&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerDowned& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerDowned* internal_default_instance() {
    return reinterpret_cast<const PlayerDowned*>(
               &_PlayerDowned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayerDowned& a, PlayerDowned& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerDowned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerDowned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerDowned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerDowned>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerDowned& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerDowned& from) {
    PlayerDowned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerDowned* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerDowned";
  }
  protected:
  explicit PlayerDowned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 5,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string weapon = 5;
  void clear_weapon();
  const std::string& weapon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weapon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* weapon);
  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(const std::string& value);
  std::string* _internal_mutable_weapon();
  public:

  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  private:
  bool _internal_has_attacker() const;
  public:
  void clear_attacker();
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* attacker);
  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();
  public:
  void unsafe_arena_set_allocated_attacker(
      ::rtech::liveapi::Player* attacker);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* victim);
  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::rtech::liveapi::Player* victim);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerDowned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerAssist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerAssist) */ {
 public:
  inline PlayerAssist() : PlayerAssist(nullptr) {}
  ~PlayerAssist() override;
  explicit PROTOBUF_CONSTEXPR PlayerAssist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerAssist(const PlayerAssist& from);
  PlayerAssist(PlayerAssist&& from) noexcept
    : PlayerAssist() {
    *this = ::std::move(from);
  }

  inline PlayerAssist& operator=(const PlayerAssist& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAssist& operator=(PlayerAssist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAssist& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAssist* internal_default_instance() {
    return reinterpret_cast<const PlayerAssist*>(
               &_PlayerAssist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PlayerAssist& a, PlayerAssist& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAssist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAssist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAssist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerAssist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerAssist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerAssist& from) {
    PlayerAssist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerAssist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerAssist";
  }
  protected:
  explicit PlayerAssist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kWeaponFieldNumber = 5,
    kAssistantFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string weapon = 5;
  void clear_weapon();
  const std::string& weapon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weapon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weapon();
  PROTOBUF_NODISCARD std::string* release_weapon();
  void set_allocated_weapon(std::string* weapon);
  private:
  const std::string& _internal_weapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weapon(const std::string& value);
  std::string* _internal_mutable_weapon();
  public:

  // .rtech.liveapi.Player assistant = 3;
  bool has_assistant() const;
  private:
  bool _internal_has_assistant() const;
  public:
  void clear_assistant();
  const ::rtech::liveapi::Player& assistant() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_assistant();
  ::rtech::liveapi::Player* mutable_assistant();
  void set_allocated_assistant(::rtech::liveapi::Player* assistant);
  private:
  const ::rtech::liveapi::Player& _internal_assistant() const;
  ::rtech::liveapi::Player* _internal_mutable_assistant();
  public:
  void unsafe_arena_set_allocated_assistant(
      ::rtech::liveapi::Player* assistant);
  ::rtech::liveapi::Player* unsafe_arena_release_assistant();

  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* victim);
  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::rtech::liveapi::Player* victim);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerAssist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weapon_;
    ::rtech::liveapi::Player* assistant_;
    ::rtech::liveapi::Player* victim_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class SquadEliminated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.SquadEliminated) */ {
 public:
  inline SquadEliminated() : SquadEliminated(nullptr) {}
  ~SquadEliminated() override;
  explicit PROTOBUF_CONSTEXPR SquadEliminated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SquadEliminated(const SquadEliminated& from);
  SquadEliminated(SquadEliminated&& from) noexcept
    : SquadEliminated() {
    *this = ::std::move(from);
  }

  inline SquadEliminated& operator=(const SquadEliminated& from) {
    CopyFrom(from);
    return *this;
  }
  inline SquadEliminated& operator=(SquadEliminated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SquadEliminated& default_instance() {
    return *internal_default_instance();
  }
  static inline const SquadEliminated* internal_default_instance() {
    return reinterpret_cast<const SquadEliminated*>(
               &_SquadEliminated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SquadEliminated& a, SquadEliminated& b) {
    a.Swap(&b);
  }
  inline void Swap(SquadEliminated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SquadEliminated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SquadEliminated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SquadEliminated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SquadEliminated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SquadEliminated& from) {
    SquadEliminated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SquadEliminated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.SquadEliminated";
  }
  protected:
  explicit SquadEliminated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kCategoryFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::rtech::liveapi::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_players();
  private:
  const ::rtech::liveapi::Player& _internal_players(int index) const;
  ::rtech::liveapi::Player* _internal_add_players();
  public:
  const ::rtech::liveapi::Player& players(int index) const;
  ::rtech::liveapi::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
      players() const;

  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.SquadEliminated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player > players_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class GibraltarShieldAbsorbed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.GibraltarShieldAbsorbed) */ {
 public:
  inline GibraltarShieldAbsorbed() : GibraltarShieldAbsorbed(nullptr) {}
  ~GibraltarShieldAbsorbed() override;
  explicit PROTOBUF_CONSTEXPR GibraltarShieldAbsorbed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GibraltarShieldAbsorbed(const GibraltarShieldAbsorbed& from);
  GibraltarShieldAbsorbed(GibraltarShieldAbsorbed&& from) noexcept
    : GibraltarShieldAbsorbed() {
    *this = ::std::move(from);
  }

  inline GibraltarShieldAbsorbed& operator=(const GibraltarShieldAbsorbed& from) {
    CopyFrom(from);
    return *this;
  }
  inline GibraltarShieldAbsorbed& operator=(GibraltarShieldAbsorbed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GibraltarShieldAbsorbed& default_instance() {
    return *internal_default_instance();
  }
  static inline const GibraltarShieldAbsorbed* internal_default_instance() {
    return reinterpret_cast<const GibraltarShieldAbsorbed*>(
               &_GibraltarShieldAbsorbed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GibraltarShieldAbsorbed& a, GibraltarShieldAbsorbed& b) {
    a.Swap(&b);
  }
  inline void Swap(GibraltarShieldAbsorbed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GibraltarShieldAbsorbed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GibraltarShieldAbsorbed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GibraltarShieldAbsorbed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GibraltarShieldAbsorbed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GibraltarShieldAbsorbed& from) {
    GibraltarShieldAbsorbed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GibraltarShieldAbsorbed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.GibraltarShieldAbsorbed";
  }
  protected:
  explicit GibraltarShieldAbsorbed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kDamageInflictedFieldNumber = 6,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  private:
  bool _internal_has_attacker() const;
  public:
  void clear_attacker();
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* attacker);
  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();
  public:
  void unsafe_arena_set_allocated_attacker(
      ::rtech::liveapi::Player* attacker);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* victim);
  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::rtech::liveapi::Player* victim);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 damageInflicted = 6;
  void clear_damageinflicted();
  uint32_t damageinflicted() const;
  void set_damageinflicted(uint32_t value);
  private:
  uint32_t _internal_damageinflicted() const;
  void _internal_set_damageinflicted(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.GibraltarShieldAbsorbed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    uint64_t timestamp_;
    uint32_t damageinflicted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class RevenantForgedShadowDamaged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RevenantForgedShadowDamaged) */ {
 public:
  inline RevenantForgedShadowDamaged() : RevenantForgedShadowDamaged(nullptr) {}
  ~RevenantForgedShadowDamaged() override;
  explicit PROTOBUF_CONSTEXPR RevenantForgedShadowDamaged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RevenantForgedShadowDamaged(const RevenantForgedShadowDamaged& from);
  RevenantForgedShadowDamaged(RevenantForgedShadowDamaged&& from) noexcept
    : RevenantForgedShadowDamaged() {
    *this = ::std::move(from);
  }

  inline RevenantForgedShadowDamaged& operator=(const RevenantForgedShadowDamaged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevenantForgedShadowDamaged& operator=(RevenantForgedShadowDamaged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RevenantForgedShadowDamaged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RevenantForgedShadowDamaged* internal_default_instance() {
    return reinterpret_cast<const RevenantForgedShadowDamaged*>(
               &_RevenantForgedShadowDamaged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RevenantForgedShadowDamaged& a, RevenantForgedShadowDamaged& b) {
    a.Swap(&b);
  }
  inline void Swap(RevenantForgedShadowDamaged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RevenantForgedShadowDamaged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RevenantForgedShadowDamaged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RevenantForgedShadowDamaged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RevenantForgedShadowDamaged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RevenantForgedShadowDamaged& from) {
    RevenantForgedShadowDamaged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevenantForgedShadowDamaged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.RevenantForgedShadowDamaged";
  }
  protected:
  explicit RevenantForgedShadowDamaged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kAttackerFieldNumber = 3,
    kVictimFieldNumber = 4,
    kTimestampFieldNumber = 1,
    kDamageInflictedFieldNumber = 6,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player attacker = 3;
  bool has_attacker() const;
  private:
  bool _internal_has_attacker() const;
  public:
  void clear_attacker();
  const ::rtech::liveapi::Player& attacker() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_attacker();
  ::rtech::liveapi::Player* mutable_attacker();
  void set_allocated_attacker(::rtech::liveapi::Player* attacker);
  private:
  const ::rtech::liveapi::Player& _internal_attacker() const;
  ::rtech::liveapi::Player* _internal_mutable_attacker();
  public:
  void unsafe_arena_set_allocated_attacker(
      ::rtech::liveapi::Player* attacker);
  ::rtech::liveapi::Player* unsafe_arena_release_attacker();

  // .rtech.liveapi.Player victim = 4;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::rtech::liveapi::Player& victim() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_victim();
  ::rtech::liveapi::Player* mutable_victim();
  void set_allocated_victim(::rtech::liveapi::Player* victim);
  private:
  const ::rtech::liveapi::Player& _internal_victim() const;
  ::rtech::liveapi::Player* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::rtech::liveapi::Player* victim);
  ::rtech::liveapi::Player* unsafe_arena_release_victim();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 damageInflicted = 6;
  void clear_damageinflicted();
  uint32_t damageinflicted() const;
  void set_damageinflicted(uint32_t value);
  private:
  uint32_t _internal_damageinflicted() const;
  void _internal_set_damageinflicted(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.RevenantForgedShadowDamaged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* attacker_;
    ::rtech::liveapi::Player* victim_;
    uint64_t timestamp_;
    uint32_t damageinflicted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerRespawnTeam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerRespawnTeam) */ {
 public:
  inline PlayerRespawnTeam() : PlayerRespawnTeam(nullptr) {}
  ~PlayerRespawnTeam() override;
  explicit PROTOBUF_CONSTEXPR PlayerRespawnTeam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerRespawnTeam(const PlayerRespawnTeam& from);
  PlayerRespawnTeam(PlayerRespawnTeam&& from) noexcept
    : PlayerRespawnTeam() {
    *this = ::std::move(from);
  }

  inline PlayerRespawnTeam& operator=(const PlayerRespawnTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRespawnTeam& operator=(PlayerRespawnTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRespawnTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerRespawnTeam* internal_default_instance() {
    return reinterpret_cast<const PlayerRespawnTeam*>(
               &_PlayerRespawnTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PlayerRespawnTeam& a, PlayerRespawnTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRespawnTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRespawnTeam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRespawnTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerRespawnTeam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerRespawnTeam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerRespawnTeam& from) {
    PlayerRespawnTeam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRespawnTeam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerRespawnTeam";
  }
  protected:
  explicit PlayerRespawnTeam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRespawnedFieldNumber = 4,
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // repeated .rtech.liveapi.Player respawned = 4;
  int respawned_size() const;
  private:
  int _internal_respawned_size() const;
  public:
  void clear_respawned();
  ::rtech::liveapi::Player* mutable_respawned(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
      mutable_respawned();
  private:
  const ::rtech::liveapi::Player& _internal_respawned(int index) const;
  ::rtech::liveapi::Player* _internal_add_respawned();
  public:
  const ::rtech::liveapi::Player& respawned(int index) const;
  ::rtech::liveapi::Player* add_respawned();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
      respawned() const;

  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerRespawnTeam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player > respawned_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerRevive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerRevive) */ {
 public:
  inline PlayerRevive() : PlayerRevive(nullptr) {}
  ~PlayerRevive() override;
  explicit PROTOBUF_CONSTEXPR PlayerRevive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerRevive(const PlayerRevive& from);
  PlayerRevive(PlayerRevive&& from) noexcept
    : PlayerRevive() {
    *this = ::std::move(from);
  }

  inline PlayerRevive& operator=(const PlayerRevive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRevive& operator=(PlayerRevive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRevive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerRevive* internal_default_instance() {
    return reinterpret_cast<const PlayerRevive*>(
               &_PlayerRevive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PlayerRevive& a, PlayerRevive& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRevive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRevive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRevive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerRevive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerRevive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerRevive& from) {
    PlayerRevive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRevive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerRevive";
  }
  protected:
  explicit PlayerRevive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kRevivedFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // .rtech.liveapi.Player revived = 4;
  bool has_revived() const;
  private:
  bool _internal_has_revived() const;
  public:
  void clear_revived();
  const ::rtech::liveapi::Player& revived() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_revived();
  ::rtech::liveapi::Player* mutable_revived();
  void set_allocated_revived(::rtech::liveapi::Player* revived);
  private:
  const ::rtech::liveapi::Player& _internal_revived() const;
  ::rtech::liveapi::Player* _internal_mutable_revived();
  public:
  void unsafe_arena_set_allocated_revived(
      ::rtech::liveapi::Player* revived);
  ::rtech::liveapi::Player* unsafe_arena_release_revived();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerRevive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::rtech::liveapi::Player* revived_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class ArenasItemSelected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ArenasItemSelected) */ {
 public:
  inline ArenasItemSelected() : ArenasItemSelected(nullptr) {}
  ~ArenasItemSelected() override;
  explicit PROTOBUF_CONSTEXPR ArenasItemSelected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArenasItemSelected(const ArenasItemSelected& from);
  ArenasItemSelected(ArenasItemSelected&& from) noexcept
    : ArenasItemSelected() {
    *this = ::std::move(from);
  }

  inline ArenasItemSelected& operator=(const ArenasItemSelected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenasItemSelected& operator=(ArenasItemSelected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenasItemSelected& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenasItemSelected* internal_default_instance() {
    return reinterpret_cast<const ArenasItemSelected*>(
               &_ArenasItemSelected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ArenasItemSelected& a, ArenasItemSelected& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenasItemSelected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenasItemSelected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenasItemSelected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenasItemSelected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArenasItemSelected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArenasItemSelected& from) {
    ArenasItemSelected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArenasItemSelected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.ArenasItemSelected";
  }
  protected:
  explicit ArenasItemSelected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string item = 4;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 quantity = 5;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.ArenasItemSelected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class ArenasItemDeselected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ArenasItemDeselected) */ {
 public:
  inline ArenasItemDeselected() : ArenasItemDeselected(nullptr) {}
  ~ArenasItemDeselected() override;
  explicit PROTOBUF_CONSTEXPR ArenasItemDeselected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArenasItemDeselected(const ArenasItemDeselected& from);
  ArenasItemDeselected(ArenasItemDeselected&& from) noexcept
    : ArenasItemDeselected() {
    *this = ::std::move(from);
  }

  inline ArenasItemDeselected& operator=(const ArenasItemDeselected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenasItemDeselected& operator=(ArenasItemDeselected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenasItemDeselected& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenasItemDeselected* internal_default_instance() {
    return reinterpret_cast<const ArenasItemDeselected*>(
               &_ArenasItemDeselected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ArenasItemDeselected& a, ArenasItemDeselected& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenasItemDeselected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenasItemDeselected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenasItemDeselected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenasItemDeselected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArenasItemDeselected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArenasItemDeselected& from) {
    ArenasItemDeselected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArenasItemDeselected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.ArenasItemDeselected";
  }
  protected:
  explicit ArenasItemDeselected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string item = 4;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 quantity = 5;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.ArenasItemDeselected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class InventoryPickUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryPickUp) */ {
 public:
  inline InventoryPickUp() : InventoryPickUp(nullptr) {}
  ~InventoryPickUp() override;
  explicit PROTOBUF_CONSTEXPR InventoryPickUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryPickUp(const InventoryPickUp& from);
  InventoryPickUp(InventoryPickUp&& from) noexcept
    : InventoryPickUp() {
    *this = ::std::move(from);
  }

  inline InventoryPickUp& operator=(const InventoryPickUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryPickUp& operator=(InventoryPickUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryPickUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryPickUp* internal_default_instance() {
    return reinterpret_cast<const InventoryPickUp*>(
               &_InventoryPickUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(InventoryPickUp& a, InventoryPickUp& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryPickUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryPickUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryPickUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryPickUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryPickUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InventoryPickUp& from) {
    InventoryPickUp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryPickUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.InventoryPickUp";
  }
  protected:
  explicit InventoryPickUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string item = 4;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 quantity = 5;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryPickUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class InventoryDrop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryDrop) */ {
 public:
  inline InventoryDrop() : InventoryDrop(nullptr) {}
  ~InventoryDrop() override;
  explicit PROTOBUF_CONSTEXPR InventoryDrop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryDrop(const InventoryDrop& from);
  InventoryDrop(InventoryDrop&& from) noexcept
    : InventoryDrop() {
    *this = ::std::move(from);
  }

  inline InventoryDrop& operator=(const InventoryDrop& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryDrop& operator=(InventoryDrop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryDrop& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryDrop* internal_default_instance() {
    return reinterpret_cast<const InventoryDrop*>(
               &_InventoryDrop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(InventoryDrop& a, InventoryDrop& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryDrop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryDrop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryDrop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryDrop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryDrop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InventoryDrop& from) {
    InventoryDrop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryDrop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.InventoryDrop";
  }
  protected:
  explicit InventoryDrop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 6,
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // repeated string extraData = 6;
  int extradata_size() const;
  private:
  int _internal_extradata_size() const;
  public:
  void clear_extradata();
  const std::string& extradata(int index) const;
  std::string* mutable_extradata(int index);
  void set_extradata(int index, const std::string& value);
  void set_extradata(int index, std::string&& value);
  void set_extradata(int index, const char* value);
  void set_extradata(int index, const char* value, size_t size);
  std::string* add_extradata();
  void add_extradata(const std::string& value);
  void add_extradata(std::string&& value);
  void add_extradata(const char* value);
  void add_extradata(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extradata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extradata();
  private:
  const std::string& _internal_extradata(int index) const;
  std::string* _internal_add_extradata();
  public:

  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string item = 4;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 quantity = 5;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryDrop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extradata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class InventoryUse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.InventoryUse) */ {
 public:
  inline InventoryUse() : InventoryUse(nullptr) {}
  ~InventoryUse() override;
  explicit PROTOBUF_CONSTEXPR InventoryUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryUse(const InventoryUse& from);
  InventoryUse(InventoryUse&& from) noexcept
    : InventoryUse() {
    *this = ::std::move(from);
  }

  inline InventoryUse& operator=(const InventoryUse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryUse& operator=(InventoryUse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryUse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryUse* internal_default_instance() {
    return reinterpret_cast<const InventoryUse*>(
               &_InventoryUse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(InventoryUse& a, InventoryUse& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryUse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryUse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryUse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryUse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryUse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InventoryUse& from) {
    InventoryUse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryUse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.InventoryUse";
  }
  protected:
  explicit InventoryUse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kQuantityFieldNumber = 5,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string item = 4;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 quantity = 5;
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.InventoryUse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t quantity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class BannerCollected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.BannerCollected) */ {
 public:
  inline BannerCollected() : BannerCollected(nullptr) {}
  ~BannerCollected() override;
  explicit PROTOBUF_CONSTEXPR BannerCollected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BannerCollected(const BannerCollected& from);
  BannerCollected(BannerCollected&& from) noexcept
    : BannerCollected() {
    *this = ::std::move(from);
  }

  inline BannerCollected& operator=(const BannerCollected& from) {
    CopyFrom(from);
    return *this;
  }
  inline BannerCollected& operator=(BannerCollected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BannerCollected& default_instance() {
    return *internal_default_instance();
  }
  static inline const BannerCollected* internal_default_instance() {
    return reinterpret_cast<const BannerCollected*>(
               &_BannerCollected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(BannerCollected& a, BannerCollected& b) {
    a.Swap(&b);
  }
  inline void Swap(BannerCollected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BannerCollected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BannerCollected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BannerCollected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BannerCollected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BannerCollected& from) {
    BannerCollected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BannerCollected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.BannerCollected";
  }
  protected:
  explicit BannerCollected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kCollectedFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // .rtech.liveapi.Player collected = 4;
  bool has_collected() const;
  private:
  bool _internal_has_collected() const;
  public:
  void clear_collected();
  const ::rtech::liveapi::Player& collected() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_collected();
  ::rtech::liveapi::Player* mutable_collected();
  void set_allocated_collected(::rtech::liveapi::Player* collected);
  private:
  const ::rtech::liveapi::Player& _internal_collected() const;
  ::rtech::liveapi::Player* _internal_mutable_collected();
  public:
  void unsafe_arena_set_allocated_collected(
      ::rtech::liveapi::Player* collected);
  ::rtech::liveapi::Player* unsafe_arena_release_collected();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.BannerCollected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    ::rtech::liveapi::Player* collected_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PlayerAbilityUsed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PlayerAbilityUsed) */ {
 public:
  inline PlayerAbilityUsed() : PlayerAbilityUsed(nullptr) {}
  ~PlayerAbilityUsed() override;
  explicit PROTOBUF_CONSTEXPR PlayerAbilityUsed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerAbilityUsed(const PlayerAbilityUsed& from);
  PlayerAbilityUsed(PlayerAbilityUsed&& from) noexcept
    : PlayerAbilityUsed() {
    *this = ::std::move(from);
  }

  inline PlayerAbilityUsed& operator=(const PlayerAbilityUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAbilityUsed& operator=(PlayerAbilityUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAbilityUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAbilityUsed* internal_default_instance() {
    return reinterpret_cast<const PlayerAbilityUsed*>(
               &_PlayerAbilityUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(PlayerAbilityUsed& a, PlayerAbilityUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAbilityUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAbilityUsed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAbilityUsed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerAbilityUsed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerAbilityUsed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerAbilityUsed& from) {
    PlayerAbilityUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerAbilityUsed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PlayerAbilityUsed";
  }
  protected:
  explicit PlayerAbilityUsed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kLinkedEntityFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string linkedEntity = 4;
  void clear_linkedentity();
  const std::string& linkedentity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkedentity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkedentity();
  PROTOBUF_NODISCARD std::string* release_linkedentity();
  void set_allocated_linkedentity(std::string* linkedentity);
  private:
  const std::string& _internal_linkedentity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedentity(const std::string& value);
  std::string* _internal_mutable_linkedentity();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PlayerAbilityUsed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkedentity_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class LegendUpgradeSelected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.LegendUpgradeSelected) */ {
 public:
  inline LegendUpgradeSelected() : LegendUpgradeSelected(nullptr) {}
  ~LegendUpgradeSelected() override;
  explicit PROTOBUF_CONSTEXPR LegendUpgradeSelected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LegendUpgradeSelected(const LegendUpgradeSelected& from);
  LegendUpgradeSelected(LegendUpgradeSelected&& from) noexcept
    : LegendUpgradeSelected() {
    *this = ::std::move(from);
  }

  inline LegendUpgradeSelected& operator=(const LegendUpgradeSelected& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegendUpgradeSelected& operator=(LegendUpgradeSelected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegendUpgradeSelected& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegendUpgradeSelected* internal_default_instance() {
    return reinterpret_cast<const LegendUpgradeSelected*>(
               &_LegendUpgradeSelected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(LegendUpgradeSelected& a, LegendUpgradeSelected& b) {
    a.Swap(&b);
  }
  inline void Swap(LegendUpgradeSelected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegendUpgradeSelected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegendUpgradeSelected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LegendUpgradeSelected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LegendUpgradeSelected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LegendUpgradeSelected& from) {
    LegendUpgradeSelected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LegendUpgradeSelected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.LegendUpgradeSelected";
  }
  protected:
  explicit LegendUpgradeSelected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kUpgradeNameFieldNumber = 4,
    kUpgradeDescFieldNumber = 5,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kLevelFieldNumber = 6,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string upgradeName = 4;
  void clear_upgradename();
  const std::string& upgradename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upgradename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upgradename();
  PROTOBUF_NODISCARD std::string* release_upgradename();
  void set_allocated_upgradename(std::string* upgradename);
  private:
  const std::string& _internal_upgradename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upgradename(const std::string& value);
  std::string* _internal_mutable_upgradename();
  public:

  // string upgradeDesc = 5;
  void clear_upgradedesc();
  const std::string& upgradedesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upgradedesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upgradedesc();
  PROTOBUF_NODISCARD std::string* release_upgradedesc();
  void set_allocated_upgradedesc(std::string* upgradedesc);
  private:
  const std::string& _internal_upgradedesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upgradedesc(const std::string& value);
  std::string* _internal_mutable_upgradedesc();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 level = 6;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.LegendUpgradeSelected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upgradename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upgradedesc_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class ZiplineUsed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ZiplineUsed) */ {
 public:
  inline ZiplineUsed() : ZiplineUsed(nullptr) {}
  ~ZiplineUsed() override;
  explicit PROTOBUF_CONSTEXPR ZiplineUsed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZiplineUsed(const ZiplineUsed& from);
  ZiplineUsed(ZiplineUsed&& from) noexcept
    : ZiplineUsed() {
    *this = ::std::move(from);
  }

  inline ZiplineUsed& operator=(const ZiplineUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZiplineUsed& operator=(ZiplineUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZiplineUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZiplineUsed* internal_default_instance() {
    return reinterpret_cast<const ZiplineUsed*>(
               &_ZiplineUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ZiplineUsed& a, ZiplineUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(ZiplineUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZiplineUsed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZiplineUsed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZiplineUsed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZiplineUsed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ZiplineUsed& from) {
    ZiplineUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZiplineUsed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.ZiplineUsed";
  }
  protected:
  explicit ZiplineUsed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kLinkedEntityFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string linkedEntity = 4;
  void clear_linkedentity();
  const std::string& linkedentity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkedentity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkedentity();
  PROTOBUF_NODISCARD std::string* release_linkedentity();
  void set_allocated_linkedentity(std::string* linkedentity);
  private:
  const std::string& _internal_linkedentity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedentity(const std::string& value);
  std::string* _internal_mutable_linkedentity();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.ZiplineUsed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkedentity_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class GrenadeThrown final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.GrenadeThrown) */ {
 public:
  inline GrenadeThrown() : GrenadeThrown(nullptr) {}
  ~GrenadeThrown() override;
  explicit PROTOBUF_CONSTEXPR GrenadeThrown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrenadeThrown(const GrenadeThrown& from);
  GrenadeThrown(GrenadeThrown&& from) noexcept
    : GrenadeThrown() {
    *this = ::std::move(from);
  }

  inline GrenadeThrown& operator=(const GrenadeThrown& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrenadeThrown& operator=(GrenadeThrown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrenadeThrown& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrenadeThrown* internal_default_instance() {
    return reinterpret_cast<const GrenadeThrown*>(
               &_GrenadeThrown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GrenadeThrown& a, GrenadeThrown& b) {
    a.Swap(&b);
  }
  inline void Swap(GrenadeThrown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrenadeThrown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrenadeThrown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrenadeThrown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrenadeThrown& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrenadeThrown& from) {
    GrenadeThrown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrenadeThrown* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.GrenadeThrown";
  }
  protected:
  explicit GrenadeThrown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kLinkedEntityFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string linkedEntity = 4;
  void clear_linkedentity();
  const std::string& linkedentity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkedentity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkedentity();
  PROTOBUF_NODISCARD std::string* release_linkedentity();
  void set_allocated_linkedentity(std::string* linkedentity);
  private:
  const std::string& _internal_linkedentity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkedentity(const std::string& value);
  std::string* _internal_mutable_linkedentity();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.GrenadeThrown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkedentity_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class BlackMarketAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.BlackMarketAction) */ {
 public:
  inline BlackMarketAction() : BlackMarketAction(nullptr) {}
  ~BlackMarketAction() override;
  explicit PROTOBUF_CONSTEXPR BlackMarketAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlackMarketAction(const BlackMarketAction& from);
  BlackMarketAction(BlackMarketAction&& from) noexcept
    : BlackMarketAction() {
    *this = ::std::move(from);
  }

  inline BlackMarketAction& operator=(const BlackMarketAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackMarketAction& operator=(BlackMarketAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackMarketAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackMarketAction* internal_default_instance() {
    return reinterpret_cast<const BlackMarketAction*>(
               &_BlackMarketAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(BlackMarketAction& a, BlackMarketAction& b) {
    a.Swap(&b);
  }
  inline void Swap(BlackMarketAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackMarketAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackMarketAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlackMarketAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlackMarketAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlackMarketAction& from) {
    BlackMarketAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlackMarketAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.BlackMarketAction";
  }
  protected:
  explicit BlackMarketAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kItemFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string item = 4;
  void clear_item();
  const std::string& item() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item();
  PROTOBUF_NODISCARD std::string* release_item();
  void set_allocated_item(std::string* item);
  private:
  const std::string& _internal_item() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item(const std::string& value);
  std::string* _internal_mutable_item();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.BlackMarketAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class WraithPortal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.WraithPortal) */ {
 public:
  inline WraithPortal() : WraithPortal(nullptr) {}
  ~WraithPortal() override;
  explicit PROTOBUF_CONSTEXPR WraithPortal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WraithPortal(const WraithPortal& from);
  WraithPortal(WraithPortal&& from) noexcept
    : WraithPortal() {
    *this = ::std::move(from);
  }

  inline WraithPortal& operator=(const WraithPortal& from) {
    CopyFrom(from);
    return *this;
  }
  inline WraithPortal& operator=(WraithPortal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WraithPortal& default_instance() {
    return *internal_default_instance();
  }
  static inline const WraithPortal* internal_default_instance() {
    return reinterpret_cast<const WraithPortal*>(
               &_WraithPortal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(WraithPortal& a, WraithPortal& b) {
    a.Swap(&b);
  }
  inline void Swap(WraithPortal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WraithPortal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WraithPortal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WraithPortal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WraithPortal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WraithPortal& from) {
    WraithPortal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WraithPortal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.WraithPortal";
  }
  protected:
  explicit WraithPortal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.WraithPortal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class WarpGateUsed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.WarpGateUsed) */ {
 public:
  inline WarpGateUsed() : WarpGateUsed(nullptr) {}
  ~WarpGateUsed() override;
  explicit PROTOBUF_CONSTEXPR WarpGateUsed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WarpGateUsed(const WarpGateUsed& from);
  WarpGateUsed(WarpGateUsed&& from) noexcept
    : WarpGateUsed() {
    *this = ::std::move(from);
  }

  inline WarpGateUsed& operator=(const WarpGateUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline WarpGateUsed& operator=(WarpGateUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WarpGateUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const WarpGateUsed* internal_default_instance() {
    return reinterpret_cast<const WarpGateUsed*>(
               &_WarpGateUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(WarpGateUsed& a, WarpGateUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(WarpGateUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WarpGateUsed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WarpGateUsed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WarpGateUsed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WarpGateUsed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WarpGateUsed& from) {
    WarpGateUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WarpGateUsed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.WarpGateUsed";
  }
  protected:
  explicit WarpGateUsed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.WarpGateUsed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class AmmoUsed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.AmmoUsed) */ {
 public:
  inline AmmoUsed() : AmmoUsed(nullptr) {}
  ~AmmoUsed() override;
  explicit PROTOBUF_CONSTEXPR AmmoUsed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AmmoUsed(const AmmoUsed& from);
  AmmoUsed(AmmoUsed&& from) noexcept
    : AmmoUsed() {
    *this = ::std::move(from);
  }

  inline AmmoUsed& operator=(const AmmoUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmmoUsed& operator=(AmmoUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AmmoUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const AmmoUsed* internal_default_instance() {
    return reinterpret_cast<const AmmoUsed*>(
               &_AmmoUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AmmoUsed& a, AmmoUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(AmmoUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmmoUsed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AmmoUsed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AmmoUsed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AmmoUsed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AmmoUsed& from) {
    AmmoUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmmoUsed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.AmmoUsed";
  }
  protected:
  explicit AmmoUsed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kAmmoTypeFieldNumber = 4,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kAmountUsedFieldNumber = 5,
    kOldAmmoCountFieldNumber = 6,
    kNewAmmoCountFieldNumber = 7,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string ammoType = 4;
  void clear_ammotype();
  const std::string& ammotype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ammotype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ammotype();
  PROTOBUF_NODISCARD std::string* release_ammotype();
  void set_allocated_ammotype(std::string* ammotype);
  private:
  const std::string& _internal_ammotype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ammotype(const std::string& value);
  std::string* _internal_mutable_ammotype();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 amountUsed = 5;
  void clear_amountused();
  uint32_t amountused() const;
  void set_amountused(uint32_t value);
  private:
  uint32_t _internal_amountused() const;
  void _internal_set_amountused(uint32_t value);
  public:

  // uint32 oldAmmoCount = 6;
  void clear_oldammocount();
  uint32_t oldammocount() const;
  void set_oldammocount(uint32_t value);
  private:
  uint32_t _internal_oldammocount() const;
  void _internal_set_oldammocount(uint32_t value);
  public:

  // uint32 newAmmoCount = 7;
  void clear_newammocount();
  uint32_t newammocount() const;
  void set_newammocount(uint32_t value);
  private:
  uint32_t _internal_newammocount() const;
  void _internal_set_newammocount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.AmmoUsed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ammotype_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    uint32_t amountused_;
    uint32_t oldammocount_;
    uint32_t newammocount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class WeaponSwitched final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.WeaponSwitched) */ {
 public:
  inline WeaponSwitched() : WeaponSwitched(nullptr) {}
  ~WeaponSwitched() override;
  explicit PROTOBUF_CONSTEXPR WeaponSwitched(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WeaponSwitched(const WeaponSwitched& from);
  WeaponSwitched(WeaponSwitched&& from) noexcept
    : WeaponSwitched() {
    *this = ::std::move(from);
  }

  inline WeaponSwitched& operator=(const WeaponSwitched& from) {
    CopyFrom(from);
    return *this;
  }
  inline WeaponSwitched& operator=(WeaponSwitched&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WeaponSwitched& default_instance() {
    return *internal_default_instance();
  }
  static inline const WeaponSwitched* internal_default_instance() {
    return reinterpret_cast<const WeaponSwitched*>(
               &_WeaponSwitched_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(WeaponSwitched& a, WeaponSwitched& b) {
    a.Swap(&b);
  }
  inline void Swap(WeaponSwitched* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WeaponSwitched* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WeaponSwitched* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WeaponSwitched>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WeaponSwitched& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WeaponSwitched& from) {
    WeaponSwitched::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeaponSwitched* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.WeaponSwitched";
  }
  protected:
  explicit WeaponSwitched(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kOldWeaponFieldNumber = 4,
    kNewWeaponFieldNumber = 5,
    kPlayerFieldNumber = 3,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string oldWeapon = 4;
  void clear_oldweapon();
  const std::string& oldweapon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldweapon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldweapon();
  PROTOBUF_NODISCARD std::string* release_oldweapon();
  void set_allocated_oldweapon(std::string* oldweapon);
  private:
  const std::string& _internal_oldweapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldweapon(const std::string& value);
  std::string* _internal_mutable_oldweapon();
  public:

  // string newWeapon = 5;
  void clear_newweapon();
  const std::string& newweapon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newweapon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newweapon();
  PROTOBUF_NODISCARD std::string* release_newweapon();
  void set_allocated_newweapon(std::string* newweapon);
  private:
  const std::string& _internal_newweapon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newweapon(const std::string& value);
  std::string* _internal_mutable_newweapon();
  public:

  // .rtech.liveapi.Player player = 3;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::rtech::liveapi::Player& player() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::Player* release_player();
  ::rtech::liveapi::Player* mutable_player();
  void set_allocated_player(::rtech::liveapi::Player* player);
  private:
  const ::rtech::liveapi::Player& _internal_player() const;
  ::rtech::liveapi::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::rtech::liveapi::Player* player);
  ::rtech::liveapi::Player* unsafe_arena_release_player();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.WeaponSwitched)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldweapon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newweapon_;
    ::rtech::liveapi::Player* player_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomEvent) */ {
 public:
  inline CustomEvent() : CustomEvent(nullptr) {}
  ~CustomEvent() override;
  explicit PROTOBUF_CONSTEXPR CustomEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomEvent(const CustomEvent& from);
  CustomEvent(CustomEvent&& from) noexcept
    : CustomEvent() {
    *this = ::std::move(from);
  }

  inline CustomEvent& operator=(const CustomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent& operator=(CustomEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomEvent* internal_default_instance() {
    return reinterpret_cast<const CustomEvent*>(
               &_CustomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CustomEvent& a, CustomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomEvent& from) {
    CustomEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomEvent";
  }
  protected:
  explicit CustomEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 2,
    kNameFieldNumber = 3,
    kDataFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string category = 2;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* data_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class ChangeCamera final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.ChangeCamera) */ {
 public:
  inline ChangeCamera() : ChangeCamera(nullptr) {}
  ~ChangeCamera() override;
  explicit PROTOBUF_CONSTEXPR ChangeCamera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeCamera(const ChangeCamera& from);
  ChangeCamera(ChangeCamera&& from) noexcept
    : ChangeCamera() {
    *this = ::std::move(from);
  }

  inline ChangeCamera& operator=(const ChangeCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeCamera& operator=(ChangeCamera&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeCamera& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kPoi = 1,
    kName = 2,
    TARGET_NOT_SET = 0,
  };

  static inline const ChangeCamera* internal_default_instance() {
    return reinterpret_cast<const ChangeCamera*>(
               &_ChangeCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ChangeCamera& a, ChangeCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeCamera* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeCamera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeCamera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeCamera>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeCamera& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeCamera& from) {
    ChangeCamera::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeCamera* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.ChangeCamera";
  }
  protected:
  explicit ChangeCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoiFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // .rtech.liveapi.PlayerOfInterest poi = 1;
  bool has_poi() const;
  private:
  bool _internal_has_poi() const;
  public:
  void clear_poi();
  ::rtech::liveapi::PlayerOfInterest poi() const;
  void set_poi(::rtech::liveapi::PlayerOfInterest value);
  private:
  ::rtech::liveapi::PlayerOfInterest _internal_poi() const;
  void _internal_set_poi(::rtech::liveapi::PlayerOfInterest value);
  public:

  // string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:rtech.liveapi.ChangeCamera)
 private:
  class _Internal;
  void set_has_poi();
  void set_has_name();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TargetUnion {
      constexpr TargetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int poi_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    } target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class PauseToggle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.PauseToggle) */ {
 public:
  inline PauseToggle() : PauseToggle(nullptr) {}
  ~PauseToggle() override;
  explicit PROTOBUF_CONSTEXPR PauseToggle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseToggle(const PauseToggle& from);
  PauseToggle(PauseToggle&& from) noexcept
    : PauseToggle() {
    *this = ::std::move(from);
  }

  inline PauseToggle& operator=(const PauseToggle& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseToggle& operator=(PauseToggle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseToggle& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseToggle* internal_default_instance() {
    return reinterpret_cast<const PauseToggle*>(
               &_PauseToggle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(PauseToggle& a, PauseToggle& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseToggle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseToggle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseToggle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseToggle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseToggle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PauseToggle& from) {
    PauseToggle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseToggle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.PauseToggle";
  }
  protected:
  explicit PauseToggle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreTimerFieldNumber = 1,
  };
  // float preTimer = 1;
  void clear_pretimer();
  float pretimer() const;
  void set_pretimer(float value);
  private:
  float _internal_pretimer() const;
  void _internal_set_pretimer(float value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.PauseToggle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float pretimer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_CreateLobby final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_CreateLobby) */ {
 public:
  inline CustomMatch_CreateLobby() : CustomMatch_CreateLobby(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CustomMatch_CreateLobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_CreateLobby(const CustomMatch_CreateLobby& from);
  CustomMatch_CreateLobby(CustomMatch_CreateLobby&& from) noexcept
    : CustomMatch_CreateLobby() {
    *this = ::std::move(from);
  }

  inline CustomMatch_CreateLobby& operator=(const CustomMatch_CreateLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_CreateLobby& operator=(CustomMatch_CreateLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_CreateLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_CreateLobby* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_CreateLobby*>(
               &_CustomMatch_CreateLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CustomMatch_CreateLobby& a, CustomMatch_CreateLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_CreateLobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_CreateLobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_CreateLobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_CreateLobby>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_CreateLobby& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_CreateLobby& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_CreateLobby";
  }
  protected:
  explicit CustomMatch_CreateLobby(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_CreateLobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_JoinLobby final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_JoinLobby) */ {
 public:
  inline CustomMatch_JoinLobby() : CustomMatch_JoinLobby(nullptr) {}
  ~CustomMatch_JoinLobby() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_JoinLobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_JoinLobby(const CustomMatch_JoinLobby& from);
  CustomMatch_JoinLobby(CustomMatch_JoinLobby&& from) noexcept
    : CustomMatch_JoinLobby() {
    *this = ::std::move(from);
  }

  inline CustomMatch_JoinLobby& operator=(const CustomMatch_JoinLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_JoinLobby& operator=(CustomMatch_JoinLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_JoinLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_JoinLobby* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_JoinLobby*>(
               &_CustomMatch_JoinLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CustomMatch_JoinLobby& a, CustomMatch_JoinLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_JoinLobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_JoinLobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_JoinLobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_JoinLobby>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_JoinLobby& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_JoinLobby& from) {
    CustomMatch_JoinLobby::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_JoinLobby* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_JoinLobby";
  }
  protected:
  explicit CustomMatch_JoinLobby(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleTokenFieldNumber = 1,
  };
  // string roleToken = 1;
  void clear_roletoken();
  const std::string& roletoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roletoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roletoken();
  PROTOBUF_NODISCARD std::string* release_roletoken();
  void set_allocated_roletoken(std::string* roletoken);
  private:
  const std::string& _internal_roletoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roletoken(const std::string& value);
  std::string* _internal_mutable_roletoken();
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_JoinLobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roletoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_LeaveLobby final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_LeaveLobby) */ {
 public:
  inline CustomMatch_LeaveLobby() : CustomMatch_LeaveLobby(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CustomMatch_LeaveLobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_LeaveLobby(const CustomMatch_LeaveLobby& from);
  CustomMatch_LeaveLobby(CustomMatch_LeaveLobby&& from) noexcept
    : CustomMatch_LeaveLobby() {
    *this = ::std::move(from);
  }

  inline CustomMatch_LeaveLobby& operator=(const CustomMatch_LeaveLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_LeaveLobby& operator=(CustomMatch_LeaveLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_LeaveLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_LeaveLobby* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_LeaveLobby*>(
               &_CustomMatch_LeaveLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CustomMatch_LeaveLobby& a, CustomMatch_LeaveLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_LeaveLobby* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_LeaveLobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_LeaveLobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_LeaveLobby>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_LeaveLobby& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_LeaveLobby& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_LeaveLobby";
  }
  protected:
  explicit CustomMatch_LeaveLobby(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_LeaveLobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_SetReady final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetReady) */ {
 public:
  inline CustomMatch_SetReady() : CustomMatch_SetReady(nullptr) {}
  ~CustomMatch_SetReady() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetReady(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_SetReady(const CustomMatch_SetReady& from);
  CustomMatch_SetReady(CustomMatch_SetReady&& from) noexcept
    : CustomMatch_SetReady() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetReady& operator=(const CustomMatch_SetReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetReady& operator=(CustomMatch_SetReady&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetReady& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetReady* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetReady*>(
               &_CustomMatch_SetReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CustomMatch_SetReady& a, CustomMatch_SetReady& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetReady* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetReady* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetReady>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetReady& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetReady& from) {
    CustomMatch_SetReady::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_SetReady* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetReady";
  }
  protected:
  explicit CustomMatch_SetReady(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsReadyFieldNumber = 1,
  };
  // bool isReady = 1;
  void clear_isready();
  bool isready() const;
  void set_isready(bool value);
  private:
  bool _internal_isready() const;
  void _internal_set_isready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetReady)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_GetLobbyPlayers final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_GetLobbyPlayers) */ {
 public:
  inline CustomMatch_GetLobbyPlayers() : CustomMatch_GetLobbyPlayers(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CustomMatch_GetLobbyPlayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_GetLobbyPlayers(const CustomMatch_GetLobbyPlayers& from);
  CustomMatch_GetLobbyPlayers(CustomMatch_GetLobbyPlayers&& from) noexcept
    : CustomMatch_GetLobbyPlayers() {
    *this = ::std::move(from);
  }

  inline CustomMatch_GetLobbyPlayers& operator=(const CustomMatch_GetLobbyPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_GetLobbyPlayers& operator=(CustomMatch_GetLobbyPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_GetLobbyPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_GetLobbyPlayers* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_GetLobbyPlayers*>(
               &_CustomMatch_GetLobbyPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CustomMatch_GetLobbyPlayers& a, CustomMatch_GetLobbyPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_GetLobbyPlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_GetLobbyPlayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_GetLobbyPlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_GetLobbyPlayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_GetLobbyPlayers& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_GetLobbyPlayers& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_GetLobbyPlayers";
  }
  protected:
  explicit CustomMatch_GetLobbyPlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_GetLobbyPlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_SetMatchmaking final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetMatchmaking) */ {
 public:
  inline CustomMatch_SetMatchmaking() : CustomMatch_SetMatchmaking(nullptr) {}
  ~CustomMatch_SetMatchmaking() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetMatchmaking(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_SetMatchmaking(const CustomMatch_SetMatchmaking& from);
  CustomMatch_SetMatchmaking(CustomMatch_SetMatchmaking&& from) noexcept
    : CustomMatch_SetMatchmaking() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetMatchmaking& operator=(const CustomMatch_SetMatchmaking& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetMatchmaking& operator=(CustomMatch_SetMatchmaking&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetMatchmaking& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetMatchmaking* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetMatchmaking*>(
               &_CustomMatch_SetMatchmaking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CustomMatch_SetMatchmaking& a, CustomMatch_SetMatchmaking& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetMatchmaking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetMatchmaking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetMatchmaking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetMatchmaking>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetMatchmaking& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetMatchmaking& from) {
    CustomMatch_SetMatchmaking::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_SetMatchmaking* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetMatchmaking";
  }
  protected:
  explicit CustomMatch_SetMatchmaking(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetMatchmaking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_SetTeam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetTeam) */ {
 public:
  inline CustomMatch_SetTeam() : CustomMatch_SetTeam(nullptr) {}
  ~CustomMatch_SetTeam() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetTeam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_SetTeam(const CustomMatch_SetTeam& from);
  CustomMatch_SetTeam(CustomMatch_SetTeam&& from) noexcept
    : CustomMatch_SetTeam() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetTeam& operator=(const CustomMatch_SetTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetTeam& operator=(CustomMatch_SetTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetTeam* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetTeam*>(
               &_CustomMatch_SetTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CustomMatch_SetTeam& a, CustomMatch_SetTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetTeam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetTeam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetTeam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetTeam& from) {
    CustomMatch_SetTeam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_SetTeam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetTeam";
  }
  protected:
  explicit CustomMatch_SetTeam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetHardwareNameFieldNumber = 2,
    kTargetNucleusHashFieldNumber = 3,
    kTeamIdFieldNumber = 1,
  };
  // string targetHardwareName = 2;
  void clear_targethardwarename();
  const std::string& targethardwarename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targethardwarename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targethardwarename();
  PROTOBUF_NODISCARD std::string* release_targethardwarename();
  void set_allocated_targethardwarename(std::string* targethardwarename);
  private:
  const std::string& _internal_targethardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targethardwarename(const std::string& value);
  std::string* _internal_mutable_targethardwarename();
  public:

  // string targetNucleusHash = 3;
  void clear_targetnucleushash();
  const std::string& targetnucleushash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetnucleushash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetnucleushash();
  PROTOBUF_NODISCARD std::string* release_targetnucleushash();
  void set_allocated_targetnucleushash(std::string* targetnucleushash);
  private:
  const std::string& _internal_targetnucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetnucleushash(const std::string& value);
  std::string* _internal_mutable_targetnucleushash();
  public:

  // int32 teamId = 1;
  void clear_teamid();
  int32_t teamid() const;
  void set_teamid(int32_t value);
  private:
  int32_t _internal_teamid() const;
  void _internal_set_teamid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetTeam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targethardwarename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetnucleushash_;
    int32_t teamid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_KickPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_KickPlayer) */ {
 public:
  inline CustomMatch_KickPlayer() : CustomMatch_KickPlayer(nullptr) {}
  ~CustomMatch_KickPlayer() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_KickPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_KickPlayer(const CustomMatch_KickPlayer& from);
  CustomMatch_KickPlayer(CustomMatch_KickPlayer&& from) noexcept
    : CustomMatch_KickPlayer() {
    *this = ::std::move(from);
  }

  inline CustomMatch_KickPlayer& operator=(const CustomMatch_KickPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_KickPlayer& operator=(CustomMatch_KickPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_KickPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_KickPlayer* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_KickPlayer*>(
               &_CustomMatch_KickPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CustomMatch_KickPlayer& a, CustomMatch_KickPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_KickPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_KickPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_KickPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_KickPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_KickPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_KickPlayer& from) {
    CustomMatch_KickPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_KickPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_KickPlayer";
  }
  protected:
  explicit CustomMatch_KickPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetHardwareNameFieldNumber = 1,
    kTargetNucleusHashFieldNumber = 2,
  };
  // string targetHardwareName = 1;
  void clear_targethardwarename();
  const std::string& targethardwarename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targethardwarename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targethardwarename();
  PROTOBUF_NODISCARD std::string* release_targethardwarename();
  void set_allocated_targethardwarename(std::string* targethardwarename);
  private:
  const std::string& _internal_targethardwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targethardwarename(const std::string& value);
  std::string* _internal_mutable_targethardwarename();
  public:

  // string targetNucleusHash = 2;
  void clear_targetnucleushash();
  const std::string& targetnucleushash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetnucleushash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetnucleushash();
  PROTOBUF_NODISCARD std::string* release_targetnucleushash();
  void set_allocated_targetnucleushash(std::string* targetnucleushash);
  private:
  const std::string& _internal_targetnucleushash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetnucleushash(const std::string& value);
  std::string* _internal_mutable_targetnucleushash();
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_KickPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targethardwarename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetnucleushash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_SetSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetSettings) */ {
 public:
  inline CustomMatch_SetSettings() : CustomMatch_SetSettings(nullptr) {}
  ~CustomMatch_SetSettings() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_SetSettings(const CustomMatch_SetSettings& from);
  CustomMatch_SetSettings(CustomMatch_SetSettings&& from) noexcept
    : CustomMatch_SetSettings() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetSettings& operator=(const CustomMatch_SetSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetSettings& operator=(CustomMatch_SetSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetSettings* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetSettings*>(
               &_CustomMatch_SetSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CustomMatch_SetSettings& a, CustomMatch_SetSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetSettings& from) {
    CustomMatch_SetSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_SetSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetSettings";
  }
  protected:
  explicit CustomMatch_SetSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistNameFieldNumber = 1,
    kAdminChatFieldNumber = 2,
    kTeamRenameFieldNumber = 3,
    kSelfAssignFieldNumber = 4,
    kAimAssistFieldNumber = 5,
    kAnonModeFieldNumber = 6,
  };
  // string playlistName = 1;
  void clear_playlistname();
  const std::string& playlistname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playlistname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playlistname();
  PROTOBUF_NODISCARD std::string* release_playlistname();
  void set_allocated_playlistname(std::string* playlistname);
  private:
  const std::string& _internal_playlistname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlistname(const std::string& value);
  std::string* _internal_mutable_playlistname();
  public:

  // bool adminChat = 2;
  void clear_adminchat();
  bool adminchat() const;
  void set_adminchat(bool value);
  private:
  bool _internal_adminchat() const;
  void _internal_set_adminchat(bool value);
  public:

  // bool teamRename = 3;
  void clear_teamrename();
  bool teamrename() const;
  void set_teamrename(bool value);
  private:
  bool _internal_teamrename() const;
  void _internal_set_teamrename(bool value);
  public:

  // bool selfAssign = 4;
  void clear_selfassign();
  bool selfassign() const;
  void set_selfassign(bool value);
  private:
  bool _internal_selfassign() const;
  void _internal_set_selfassign(bool value);
  public:

  // bool aimAssist = 5;
  void clear_aimassist();
  bool aimassist() const;
  void set_aimassist(bool value);
  private:
  bool _internal_aimassist() const;
  void _internal_set_aimassist(bool value);
  public:

  // bool anonMode = 6;
  void clear_anonmode();
  bool anonmode() const;
  void set_anonmode(bool value);
  private:
  bool _internal_anonmode() const;
  void _internal_set_anonmode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playlistname_;
    bool adminchat_;
    bool teamrename_;
    bool selfassign_;
    bool aimassist_;
    bool anonmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_GetSettings final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_GetSettings) */ {
 public:
  inline CustomMatch_GetSettings() : CustomMatch_GetSettings(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CustomMatch_GetSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_GetSettings(const CustomMatch_GetSettings& from);
  CustomMatch_GetSettings(CustomMatch_GetSettings&& from) noexcept
    : CustomMatch_GetSettings() {
    *this = ::std::move(from);
  }

  inline CustomMatch_GetSettings& operator=(const CustomMatch_GetSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_GetSettings& operator=(CustomMatch_GetSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_GetSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_GetSettings* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_GetSettings*>(
               &_CustomMatch_GetSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CustomMatch_GetSettings& a, CustomMatch_GetSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_GetSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_GetSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_GetSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_GetSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CustomMatch_GetSettings& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CustomMatch_GetSettings& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_GetSettings";
  }
  protected:
  explicit CustomMatch_GetSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_GetSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_SetTeamName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SetTeamName) */ {
 public:
  inline CustomMatch_SetTeamName() : CustomMatch_SetTeamName(nullptr) {}
  ~CustomMatch_SetTeamName() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_SetTeamName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_SetTeamName(const CustomMatch_SetTeamName& from);
  CustomMatch_SetTeamName(CustomMatch_SetTeamName&& from) noexcept
    : CustomMatch_SetTeamName() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SetTeamName& operator=(const CustomMatch_SetTeamName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SetTeamName& operator=(CustomMatch_SetTeamName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SetTeamName& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SetTeamName* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SetTeamName*>(
               &_CustomMatch_SetTeamName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CustomMatch_SetTeamName& a, CustomMatch_SetTeamName& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SetTeamName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SetTeamName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SetTeamName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SetTeamName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SetTeamName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SetTeamName& from) {
    CustomMatch_SetTeamName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_SetTeamName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_SetTeamName";
  }
  protected:
  explicit CustomMatch_SetTeamName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamNameFieldNumber = 2,
    kTeamIdFieldNumber = 1,
  };
  // string teamName = 2;
  void clear_teamname();
  const std::string& teamname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_teamname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_teamname();
  PROTOBUF_NODISCARD std::string* release_teamname();
  void set_allocated_teamname(std::string* teamname);
  private:
  const std::string& _internal_teamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_teamname(const std::string& value);
  std::string* _internal_mutable_teamname();
  public:

  // int32 teamId = 1;
  void clear_teamid();
  int32_t teamid() const;
  void set_teamid(int32_t value);
  private:
  int32_t _internal_teamid() const;
  void _internal_set_teamid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SetTeamName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr teamname_;
    int32_t teamid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class CustomMatch_SendChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.CustomMatch_SendChat) */ {
 public:
  inline CustomMatch_SendChat() : CustomMatch_SendChat(nullptr) {}
  ~CustomMatch_SendChat() override;
  explicit PROTOBUF_CONSTEXPR CustomMatch_SendChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMatch_SendChat(const CustomMatch_SendChat& from);
  CustomMatch_SendChat(CustomMatch_SendChat&& from) noexcept
    : CustomMatch_SendChat() {
    *this = ::std::move(from);
  }

  inline CustomMatch_SendChat& operator=(const CustomMatch_SendChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMatch_SendChat& operator=(CustomMatch_SendChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMatch_SendChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMatch_SendChat* internal_default_instance() {
    return reinterpret_cast<const CustomMatch_SendChat*>(
               &_CustomMatch_SendChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CustomMatch_SendChat& a, CustomMatch_SendChat& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMatch_SendChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMatch_SendChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMatch_SendChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMatch_SendChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMatch_SendChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMatch_SendChat& from) {
    CustomMatch_SendChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMatch_SendChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.CustomMatch_SendChat";
  }
  protected:
  explicit CustomMatch_SendChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.CustomMatch_SendChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum ActionsCase {
    kChangeCam = 4,
    kPauseToggle = 5,
    kCustomMatchCreateLobby = 10,
    kCustomMatchJoinLobby = 11,
    kCustomMatchLeaveLobby = 12,
    kCustomMatchSetReady = 13,
    kCustomMatchSetMatchmaking = 14,
    kCustomMatchSetTeam = 15,
    kCustomMatchKickPlayer = 16,
    kCustomMatchSetSettings = 17,
    kCustomMatchSendChat = 18,
    kCustomMatchGetLobbyPlayers = 19,
    kCustomMatchSetTeamName = 20,
    kCustomMatchGetSettings = 21,
    ACTIONS_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreSharedKeyFieldNumber = 2,
    kWithAckFieldNumber = 1,
    kChangeCamFieldNumber = 4,
    kPauseToggleFieldNumber = 5,
    kCustomMatchCreateLobbyFieldNumber = 10,
    kCustomMatchJoinLobbyFieldNumber = 11,
    kCustomMatchLeaveLobbyFieldNumber = 12,
    kCustomMatchSetReadyFieldNumber = 13,
    kCustomMatchSetMatchmakingFieldNumber = 14,
    kCustomMatchSetTeamFieldNumber = 15,
    kCustomMatchKickPlayerFieldNumber = 16,
    kCustomMatchSetSettingsFieldNumber = 17,
    kCustomMatchSendChatFieldNumber = 18,
    kCustomMatchGetLobbyPlayersFieldNumber = 19,
    kCustomMatchSetTeamNameFieldNumber = 20,
    kCustomMatchGetSettingsFieldNumber = 21,
  };
  // string preSharedKey = 2;
  void clear_presharedkey();
  const std::string& presharedkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_presharedkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_presharedkey();
  PROTOBUF_NODISCARD std::string* release_presharedkey();
  void set_allocated_presharedkey(std::string* presharedkey);
  private:
  const std::string& _internal_presharedkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_presharedkey(const std::string& value);
  std::string* _internal_mutable_presharedkey();
  public:

  // bool withAck = 1;
  void clear_withack();
  bool withack() const;
  void set_withack(bool value);
  private:
  bool _internal_withack() const;
  void _internal_set_withack(bool value);
  public:

  // .rtech.liveapi.ChangeCamera changeCam = 4;
  bool has_changecam() const;
  private:
  bool _internal_has_changecam() const;
  public:
  void clear_changecam();
  const ::rtech::liveapi::ChangeCamera& changecam() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::ChangeCamera* release_changecam();
  ::rtech::liveapi::ChangeCamera* mutable_changecam();
  void set_allocated_changecam(::rtech::liveapi::ChangeCamera* changecam);
  private:
  const ::rtech::liveapi::ChangeCamera& _internal_changecam() const;
  ::rtech::liveapi::ChangeCamera* _internal_mutable_changecam();
  public:
  void unsafe_arena_set_allocated_changecam(
      ::rtech::liveapi::ChangeCamera* changecam);
  ::rtech::liveapi::ChangeCamera* unsafe_arena_release_changecam();

  // .rtech.liveapi.PauseToggle pauseToggle = 5;
  bool has_pausetoggle() const;
  private:
  bool _internal_has_pausetoggle() const;
  public:
  void clear_pausetoggle();
  const ::rtech::liveapi::PauseToggle& pausetoggle() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::PauseToggle* release_pausetoggle();
  ::rtech::liveapi::PauseToggle* mutable_pausetoggle();
  void set_allocated_pausetoggle(::rtech::liveapi::PauseToggle* pausetoggle);
  private:
  const ::rtech::liveapi::PauseToggle& _internal_pausetoggle() const;
  ::rtech::liveapi::PauseToggle* _internal_mutable_pausetoggle();
  public:
  void unsafe_arena_set_allocated_pausetoggle(
      ::rtech::liveapi::PauseToggle* pausetoggle);
  ::rtech::liveapi::PauseToggle* unsafe_arena_release_pausetoggle();

  // .rtech.liveapi.CustomMatch_CreateLobby customMatch_CreateLobby = 10;
  bool has_custommatch_createlobby() const;
  private:
  bool _internal_has_custommatch_createlobby() const;
  public:
  void clear_custommatch_createlobby();
  const ::rtech::liveapi::CustomMatch_CreateLobby& custommatch_createlobby() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_CreateLobby* release_custommatch_createlobby();
  ::rtech::liveapi::CustomMatch_CreateLobby* mutable_custommatch_createlobby();
  void set_allocated_custommatch_createlobby(::rtech::liveapi::CustomMatch_CreateLobby* custommatch_createlobby);
  private:
  const ::rtech::liveapi::CustomMatch_CreateLobby& _internal_custommatch_createlobby() const;
  ::rtech::liveapi::CustomMatch_CreateLobby* _internal_mutable_custommatch_createlobby();
  public:
  void unsafe_arena_set_allocated_custommatch_createlobby(
      ::rtech::liveapi::CustomMatch_CreateLobby* custommatch_createlobby);
  ::rtech::liveapi::CustomMatch_CreateLobby* unsafe_arena_release_custommatch_createlobby();

  // .rtech.liveapi.CustomMatch_JoinLobby customMatch_JoinLobby = 11;
  bool has_custommatch_joinlobby() const;
  private:
  bool _internal_has_custommatch_joinlobby() const;
  public:
  void clear_custommatch_joinlobby();
  const ::rtech::liveapi::CustomMatch_JoinLobby& custommatch_joinlobby() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_JoinLobby* release_custommatch_joinlobby();
  ::rtech::liveapi::CustomMatch_JoinLobby* mutable_custommatch_joinlobby();
  void set_allocated_custommatch_joinlobby(::rtech::liveapi::CustomMatch_JoinLobby* custommatch_joinlobby);
  private:
  const ::rtech::liveapi::CustomMatch_JoinLobby& _internal_custommatch_joinlobby() const;
  ::rtech::liveapi::CustomMatch_JoinLobby* _internal_mutable_custommatch_joinlobby();
  public:
  void unsafe_arena_set_allocated_custommatch_joinlobby(
      ::rtech::liveapi::CustomMatch_JoinLobby* custommatch_joinlobby);
  ::rtech::liveapi::CustomMatch_JoinLobby* unsafe_arena_release_custommatch_joinlobby();

  // .rtech.liveapi.CustomMatch_LeaveLobby customMatch_LeaveLobby = 12;
  bool has_custommatch_leavelobby() const;
  private:
  bool _internal_has_custommatch_leavelobby() const;
  public:
  void clear_custommatch_leavelobby();
  const ::rtech::liveapi::CustomMatch_LeaveLobby& custommatch_leavelobby() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_LeaveLobby* release_custommatch_leavelobby();
  ::rtech::liveapi::CustomMatch_LeaveLobby* mutable_custommatch_leavelobby();
  void set_allocated_custommatch_leavelobby(::rtech::liveapi::CustomMatch_LeaveLobby* custommatch_leavelobby);
  private:
  const ::rtech::liveapi::CustomMatch_LeaveLobby& _internal_custommatch_leavelobby() const;
  ::rtech::liveapi::CustomMatch_LeaveLobby* _internal_mutable_custommatch_leavelobby();
  public:
  void unsafe_arena_set_allocated_custommatch_leavelobby(
      ::rtech::liveapi::CustomMatch_LeaveLobby* custommatch_leavelobby);
  ::rtech::liveapi::CustomMatch_LeaveLobby* unsafe_arena_release_custommatch_leavelobby();

  // .rtech.liveapi.CustomMatch_SetReady customMatch_SetReady = 13;
  bool has_custommatch_setready() const;
  private:
  bool _internal_has_custommatch_setready() const;
  public:
  void clear_custommatch_setready();
  const ::rtech::liveapi::CustomMatch_SetReady& custommatch_setready() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetReady* release_custommatch_setready();
  ::rtech::liveapi::CustomMatch_SetReady* mutable_custommatch_setready();
  void set_allocated_custommatch_setready(::rtech::liveapi::CustomMatch_SetReady* custommatch_setready);
  private:
  const ::rtech::liveapi::CustomMatch_SetReady& _internal_custommatch_setready() const;
  ::rtech::liveapi::CustomMatch_SetReady* _internal_mutable_custommatch_setready();
  public:
  void unsafe_arena_set_allocated_custommatch_setready(
      ::rtech::liveapi::CustomMatch_SetReady* custommatch_setready);
  ::rtech::liveapi::CustomMatch_SetReady* unsafe_arena_release_custommatch_setready();

  // .rtech.liveapi.CustomMatch_SetMatchmaking customMatch_SetMatchmaking = 14;
  bool has_custommatch_setmatchmaking() const;
  private:
  bool _internal_has_custommatch_setmatchmaking() const;
  public:
  void clear_custommatch_setmatchmaking();
  const ::rtech::liveapi::CustomMatch_SetMatchmaking& custommatch_setmatchmaking() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetMatchmaking* release_custommatch_setmatchmaking();
  ::rtech::liveapi::CustomMatch_SetMatchmaking* mutable_custommatch_setmatchmaking();
  void set_allocated_custommatch_setmatchmaking(::rtech::liveapi::CustomMatch_SetMatchmaking* custommatch_setmatchmaking);
  private:
  const ::rtech::liveapi::CustomMatch_SetMatchmaking& _internal_custommatch_setmatchmaking() const;
  ::rtech::liveapi::CustomMatch_SetMatchmaking* _internal_mutable_custommatch_setmatchmaking();
  public:
  void unsafe_arena_set_allocated_custommatch_setmatchmaking(
      ::rtech::liveapi::CustomMatch_SetMatchmaking* custommatch_setmatchmaking);
  ::rtech::liveapi::CustomMatch_SetMatchmaking* unsafe_arena_release_custommatch_setmatchmaking();

  // .rtech.liveapi.CustomMatch_SetTeam customMatch_SetTeam = 15;
  bool has_custommatch_setteam() const;
  private:
  bool _internal_has_custommatch_setteam() const;
  public:
  void clear_custommatch_setteam();
  const ::rtech::liveapi::CustomMatch_SetTeam& custommatch_setteam() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetTeam* release_custommatch_setteam();
  ::rtech::liveapi::CustomMatch_SetTeam* mutable_custommatch_setteam();
  void set_allocated_custommatch_setteam(::rtech::liveapi::CustomMatch_SetTeam* custommatch_setteam);
  private:
  const ::rtech::liveapi::CustomMatch_SetTeam& _internal_custommatch_setteam() const;
  ::rtech::liveapi::CustomMatch_SetTeam* _internal_mutable_custommatch_setteam();
  public:
  void unsafe_arena_set_allocated_custommatch_setteam(
      ::rtech::liveapi::CustomMatch_SetTeam* custommatch_setteam);
  ::rtech::liveapi::CustomMatch_SetTeam* unsafe_arena_release_custommatch_setteam();

  // .rtech.liveapi.CustomMatch_KickPlayer customMatch_KickPlayer = 16;
  bool has_custommatch_kickplayer() const;
  private:
  bool _internal_has_custommatch_kickplayer() const;
  public:
  void clear_custommatch_kickplayer();
  const ::rtech::liveapi::CustomMatch_KickPlayer& custommatch_kickplayer() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_KickPlayer* release_custommatch_kickplayer();
  ::rtech::liveapi::CustomMatch_KickPlayer* mutable_custommatch_kickplayer();
  void set_allocated_custommatch_kickplayer(::rtech::liveapi::CustomMatch_KickPlayer* custommatch_kickplayer);
  private:
  const ::rtech::liveapi::CustomMatch_KickPlayer& _internal_custommatch_kickplayer() const;
  ::rtech::liveapi::CustomMatch_KickPlayer* _internal_mutable_custommatch_kickplayer();
  public:
  void unsafe_arena_set_allocated_custommatch_kickplayer(
      ::rtech::liveapi::CustomMatch_KickPlayer* custommatch_kickplayer);
  ::rtech::liveapi::CustomMatch_KickPlayer* unsafe_arena_release_custommatch_kickplayer();

  // .rtech.liveapi.CustomMatch_SetSettings customMatch_SetSettings = 17;
  bool has_custommatch_setsettings() const;
  private:
  bool _internal_has_custommatch_setsettings() const;
  public:
  void clear_custommatch_setsettings();
  const ::rtech::liveapi::CustomMatch_SetSettings& custommatch_setsettings() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetSettings* release_custommatch_setsettings();
  ::rtech::liveapi::CustomMatch_SetSettings* mutable_custommatch_setsettings();
  void set_allocated_custommatch_setsettings(::rtech::liveapi::CustomMatch_SetSettings* custommatch_setsettings);
  private:
  const ::rtech::liveapi::CustomMatch_SetSettings& _internal_custommatch_setsettings() const;
  ::rtech::liveapi::CustomMatch_SetSettings* _internal_mutable_custommatch_setsettings();
  public:
  void unsafe_arena_set_allocated_custommatch_setsettings(
      ::rtech::liveapi::CustomMatch_SetSettings* custommatch_setsettings);
  ::rtech::liveapi::CustomMatch_SetSettings* unsafe_arena_release_custommatch_setsettings();

  // .rtech.liveapi.CustomMatch_SendChat customMatch_SendChat = 18;
  bool has_custommatch_sendchat() const;
  private:
  bool _internal_has_custommatch_sendchat() const;
  public:
  void clear_custommatch_sendchat();
  const ::rtech::liveapi::CustomMatch_SendChat& custommatch_sendchat() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SendChat* release_custommatch_sendchat();
  ::rtech::liveapi::CustomMatch_SendChat* mutable_custommatch_sendchat();
  void set_allocated_custommatch_sendchat(::rtech::liveapi::CustomMatch_SendChat* custommatch_sendchat);
  private:
  const ::rtech::liveapi::CustomMatch_SendChat& _internal_custommatch_sendchat() const;
  ::rtech::liveapi::CustomMatch_SendChat* _internal_mutable_custommatch_sendchat();
  public:
  void unsafe_arena_set_allocated_custommatch_sendchat(
      ::rtech::liveapi::CustomMatch_SendChat* custommatch_sendchat);
  ::rtech::liveapi::CustomMatch_SendChat* unsafe_arena_release_custommatch_sendchat();

  // .rtech.liveapi.CustomMatch_GetLobbyPlayers customMatch_GetLobbyPlayers = 19;
  bool has_custommatch_getlobbyplayers() const;
  private:
  bool _internal_has_custommatch_getlobbyplayers() const;
  public:
  void clear_custommatch_getlobbyplayers();
  const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& custommatch_getlobbyplayers() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_GetLobbyPlayers* release_custommatch_getlobbyplayers();
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* mutable_custommatch_getlobbyplayers();
  void set_allocated_custommatch_getlobbyplayers(::rtech::liveapi::CustomMatch_GetLobbyPlayers* custommatch_getlobbyplayers);
  private:
  const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& _internal_custommatch_getlobbyplayers() const;
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* _internal_mutable_custommatch_getlobbyplayers();
  public:
  void unsafe_arena_set_allocated_custommatch_getlobbyplayers(
      ::rtech::liveapi::CustomMatch_GetLobbyPlayers* custommatch_getlobbyplayers);
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* unsafe_arena_release_custommatch_getlobbyplayers();

  // .rtech.liveapi.CustomMatch_SetTeamName customMatch_SetTeamName = 20;
  bool has_custommatch_setteamname() const;
  private:
  bool _internal_has_custommatch_setteamname() const;
  public:
  void clear_custommatch_setteamname();
  const ::rtech::liveapi::CustomMatch_SetTeamName& custommatch_setteamname() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_SetTeamName* release_custommatch_setteamname();
  ::rtech::liveapi::CustomMatch_SetTeamName* mutable_custommatch_setteamname();
  void set_allocated_custommatch_setteamname(::rtech::liveapi::CustomMatch_SetTeamName* custommatch_setteamname);
  private:
  const ::rtech::liveapi::CustomMatch_SetTeamName& _internal_custommatch_setteamname() const;
  ::rtech::liveapi::CustomMatch_SetTeamName* _internal_mutable_custommatch_setteamname();
  public:
  void unsafe_arena_set_allocated_custommatch_setteamname(
      ::rtech::liveapi::CustomMatch_SetTeamName* custommatch_setteamname);
  ::rtech::liveapi::CustomMatch_SetTeamName* unsafe_arena_release_custommatch_setteamname();

  // .rtech.liveapi.CustomMatch_GetSettings customMatch_GetSettings = 21;
  bool has_custommatch_getsettings() const;
  private:
  bool _internal_has_custommatch_getsettings() const;
  public:
  void clear_custommatch_getsettings();
  const ::rtech::liveapi::CustomMatch_GetSettings& custommatch_getsettings() const;
  PROTOBUF_NODISCARD ::rtech::liveapi::CustomMatch_GetSettings* release_custommatch_getsettings();
  ::rtech::liveapi::CustomMatch_GetSettings* mutable_custommatch_getsettings();
  void set_allocated_custommatch_getsettings(::rtech::liveapi::CustomMatch_GetSettings* custommatch_getsettings);
  private:
  const ::rtech::liveapi::CustomMatch_GetSettings& _internal_custommatch_getsettings() const;
  ::rtech::liveapi::CustomMatch_GetSettings* _internal_mutable_custommatch_getsettings();
  public:
  void unsafe_arena_set_allocated_custommatch_getsettings(
      ::rtech::liveapi::CustomMatch_GetSettings* custommatch_getsettings);
  ::rtech::liveapi::CustomMatch_GetSettings* unsafe_arena_release_custommatch_getsettings();

  void clear_actions();
  ActionsCase actions_case() const;
  // @@protoc_insertion_point(class_scope:rtech.liveapi.Request)
 private:
  class _Internal;
  void set_has_changecam();
  void set_has_pausetoggle();
  void set_has_custommatch_createlobby();
  void set_has_custommatch_joinlobby();
  void set_has_custommatch_leavelobby();
  void set_has_custommatch_setready();
  void set_has_custommatch_setmatchmaking();
  void set_has_custommatch_setteam();
  void set_has_custommatch_kickplayer();
  void set_has_custommatch_setsettings();
  void set_has_custommatch_sendchat();
  void set_has_custommatch_getlobbyplayers();
  void set_has_custommatch_setteamname();
  void set_has_custommatch_getsettings();

  inline bool has_actions() const;
  inline void clear_has_actions();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr presharedkey_;
    bool withack_;
    union ActionsUnion {
      constexpr ActionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::rtech::liveapi::ChangeCamera* changecam_;
      ::rtech::liveapi::PauseToggle* pausetoggle_;
      ::rtech::liveapi::CustomMatch_CreateLobby* custommatch_createlobby_;
      ::rtech::liveapi::CustomMatch_JoinLobby* custommatch_joinlobby_;
      ::rtech::liveapi::CustomMatch_LeaveLobby* custommatch_leavelobby_;
      ::rtech::liveapi::CustomMatch_SetReady* custommatch_setready_;
      ::rtech::liveapi::CustomMatch_SetMatchmaking* custommatch_setmatchmaking_;
      ::rtech::liveapi::CustomMatch_SetTeam* custommatch_setteam_;
      ::rtech::liveapi::CustomMatch_KickPlayer* custommatch_kickplayer_;
      ::rtech::liveapi::CustomMatch_SetSettings* custommatch_setsettings_;
      ::rtech::liveapi::CustomMatch_SendChat* custommatch_sendchat_;
      ::rtech::liveapi::CustomMatch_GetLobbyPlayers* custommatch_getlobbyplayers_;
      ::rtech::liveapi::CustomMatch_SetTeamName* custommatch_setteamname_;
      ::rtech::liveapi::CustomMatch_GetSettings* custommatch_getsettings_;
    } actions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class RequestStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.RequestStatus) */ {
 public:
  inline RequestStatus() : RequestStatus(nullptr) {}
  ~RequestStatus() override;
  explicit PROTOBUF_CONSTEXPR RequestStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestStatus(const RequestStatus& from);
  RequestStatus(RequestStatus&& from) noexcept
    : RequestStatus() {
    *this = ::std::move(from);
  }

  inline RequestStatus& operator=(const RequestStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestStatus& operator=(RequestStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestStatus* internal_default_instance() {
    return reinterpret_cast<const RequestStatus*>(
               &_RequestStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(RequestStatus& a, RequestStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestStatus& from) {
    RequestStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.RequestStatus";
  }
  protected:
  explicit RequestStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.RequestStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .google.protobuf.Any result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::PROTOBUF_NAMESPACE_ID::Any& result() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_result();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_result();
  void set_allocated_result(::PROTOBUF_NAMESPACE_ID::Any* result);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::PROTOBUF_NAMESPACE_ID::Any* result);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_result();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Any* result_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// -------------------------------------------------------------------

class LiveAPIEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rtech.liveapi.LiveAPIEvent) */ {
 public:
  inline LiveAPIEvent() : LiveAPIEvent(nullptr) {}
  ~LiveAPIEvent() override;
  explicit PROTOBUF_CONSTEXPR LiveAPIEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveAPIEvent(const LiveAPIEvent& from);
  LiveAPIEvent(LiveAPIEvent&& from) noexcept
    : LiveAPIEvent() {
    *this = ::std::move(from);
  }

  inline LiveAPIEvent& operator=(const LiveAPIEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveAPIEvent& operator=(LiveAPIEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveAPIEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveAPIEvent* internal_default_instance() {
    return reinterpret_cast<const LiveAPIEvent*>(
               &_LiveAPIEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(LiveAPIEvent& a, LiveAPIEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveAPIEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveAPIEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveAPIEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveAPIEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveAPIEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LiveAPIEvent& from) {
    LiveAPIEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveAPIEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rtech.liveapi.LiveAPIEvent";
  }
  protected:
  explicit LiveAPIEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameMessageFieldNumber = 3,
    kEventSizeFieldNumber = 1,
  };
  // .google.protobuf.Any gameMessage = 3;
  bool has_gamemessage() const;
  private:
  bool _internal_has_gamemessage() const;
  public:
  void clear_gamemessage();
  const ::PROTOBUF_NAMESPACE_ID::Any& gamemessage() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_gamemessage();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_gamemessage();
  void set_allocated_gamemessage(::PROTOBUF_NAMESPACE_ID::Any* gamemessage);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_gamemessage() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_gamemessage();
  public:
  void unsafe_arena_set_allocated_gamemessage(
      ::PROTOBUF_NAMESPACE_ID::Any* gamemessage);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_gamemessage();

  // fixed32 event_size = 1;
  void clear_event_size();
  uint32_t event_size() const;
  void set_event_size(uint32_t value);
  private:
  uint32_t _internal_event_size() const;
  void _internal_set_event_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rtech.liveapi.LiveAPIEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Any* gamemessage_;
    uint32_t event_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Vector3.z)
}

// -------------------------------------------------------------------

// Player

// string name = 1;
inline void Player::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.name)
  return _impl_.name_.Release();
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.name)
}

// uint32 teamId = 2;
inline void Player::clear_teamid() {
  _impl_.teamid_ = 0u;
}
inline uint32_t Player::_internal_teamid() const {
  return _impl_.teamid_;
}
inline uint32_t Player::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.teamId)
  return _internal_teamid();
}
inline void Player::_internal_set_teamid(uint32_t value) {
  
  _impl_.teamid_ = value;
}
inline void Player::set_teamid(uint32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.teamId)
}

// .rtech.liveapi.Vector3 pos = 3;
inline bool Player::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool Player::has_pos() const {
  return _internal_has_pos();
}
inline void Player::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::rtech::liveapi::Vector3& Player::_internal_pos() const {
  const ::rtech::liveapi::Vector3* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(
      ::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& Player::pos() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.pos)
  return _internal_pos();
}
inline void Player::unsafe_arena_set_allocated_pos(
    ::rtech::liveapi::Vector3* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Player.pos)
}
inline ::rtech::liveapi::Vector3* Player::release_pos() {
  
  ::rtech::liveapi::Vector3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Vector3* Player::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.pos)
  
  ::rtech::liveapi::Vector3* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* Player::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::rtech::liveapi::Vector3* Player::mutable_pos() {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.pos)
  return _msg;
}
inline void Player::set_allocated_pos(::rtech::liveapi::Vector3* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.pos)
}

// .rtech.liveapi.Vector3 angles = 4;
inline bool Player::_internal_has_angles() const {
  return this != internal_default_instance() && _impl_.angles_ != nullptr;
}
inline bool Player::has_angles() const {
  return _internal_has_angles();
}
inline void Player::clear_angles() {
  if (GetArenaForAllocation() == nullptr && _impl_.angles_ != nullptr) {
    delete _impl_.angles_;
  }
  _impl_.angles_ = nullptr;
}
inline const ::rtech::liveapi::Vector3& Player::_internal_angles() const {
  const ::rtech::liveapi::Vector3* p = _impl_.angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(
      ::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& Player::angles() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.angles)
  return _internal_angles();
}
inline void Player::unsafe_arena_set_allocated_angles(
    ::rtech::liveapi::Vector3* angles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angles_);
  }
  _impl_.angles_ = angles;
  if (angles) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Player.angles)
}
inline ::rtech::liveapi::Vector3* Player::release_angles() {
  
  ::rtech::liveapi::Vector3* temp = _impl_.angles_;
  _impl_.angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Vector3* Player::unsafe_arena_release_angles() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.angles)
  
  ::rtech::liveapi::Vector3* temp = _impl_.angles_;
  _impl_.angles_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* Player::_internal_mutable_angles() {
  
  if (_impl_.angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArenaForAllocation());
    _impl_.angles_ = p;
  }
  return _impl_.angles_;
}
inline ::rtech::liveapi::Vector3* Player::mutable_angles() {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_angles();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.angles)
  return _msg;
}
inline void Player::set_allocated_angles(::rtech::liveapi::Vector3* angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.angles_;
  }
  if (angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angles);
    if (message_arena != submessage_arena) {
      angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angles, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.angles_ = angles;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.angles)
}

// uint32 currentHealth = 5;
inline void Player::clear_currenthealth() {
  _impl_.currenthealth_ = 0u;
}
inline uint32_t Player::_internal_currenthealth() const {
  return _impl_.currenthealth_;
}
inline uint32_t Player::currenthealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.currentHealth)
  return _internal_currenthealth();
}
inline void Player::_internal_set_currenthealth(uint32_t value) {
  
  _impl_.currenthealth_ = value;
}
inline void Player::set_currenthealth(uint32_t value) {
  _internal_set_currenthealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.currentHealth)
}

// uint32 maxHealth = 6;
inline void Player::clear_maxhealth() {
  _impl_.maxhealth_ = 0u;
}
inline uint32_t Player::_internal_maxhealth() const {
  return _impl_.maxhealth_;
}
inline uint32_t Player::maxhealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.maxHealth)
  return _internal_maxhealth();
}
inline void Player::_internal_set_maxhealth(uint32_t value) {
  
  _impl_.maxhealth_ = value;
}
inline void Player::set_maxhealth(uint32_t value) {
  _internal_set_maxhealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.maxHealth)
}

// uint32 shieldHealth = 7;
inline void Player::clear_shieldhealth() {
  _impl_.shieldhealth_ = 0u;
}
inline uint32_t Player::_internal_shieldhealth() const {
  return _impl_.shieldhealth_;
}
inline uint32_t Player::shieldhealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.shieldHealth)
  return _internal_shieldhealth();
}
inline void Player::_internal_set_shieldhealth(uint32_t value) {
  
  _impl_.shieldhealth_ = value;
}
inline void Player::set_shieldhealth(uint32_t value) {
  _internal_set_shieldhealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.shieldHealth)
}

// uint32 shieldMaxHealth = 8;
inline void Player::clear_shieldmaxhealth() {
  _impl_.shieldmaxhealth_ = 0u;
}
inline uint32_t Player::_internal_shieldmaxhealth() const {
  return _impl_.shieldmaxhealth_;
}
inline uint32_t Player::shieldmaxhealth() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.shieldMaxHealth)
  return _internal_shieldmaxhealth();
}
inline void Player::_internal_set_shieldmaxhealth(uint32_t value) {
  
  _impl_.shieldmaxhealth_ = value;
}
inline void Player::set_shieldmaxhealth(uint32_t value) {
  _internal_set_shieldmaxhealth(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.shieldMaxHealth)
}

// string nucleusHash = 9;
inline void Player::clear_nucleushash() {
  _impl_.nucleushash_.ClearToEmpty();
}
inline const std::string& Player::nucleushash() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.nucleusHash)
  return _internal_nucleushash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_nucleushash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nucleushash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.nucleusHash)
}
inline std::string* Player::mutable_nucleushash() {
  std::string* _s = _internal_mutable_nucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.nucleusHash)
  return _s;
}
inline const std::string& Player::_internal_nucleushash() const {
  return _impl_.nucleushash_.Get();
}
inline void Player::_internal_set_nucleushash(const std::string& value) {
  
  _impl_.nucleushash_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_nucleushash() {
  
  return _impl_.nucleushash_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_nucleushash() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.nucleusHash)
  return _impl_.nucleushash_.Release();
}
inline void Player::set_allocated_nucleushash(std::string* nucleushash) {
  if (nucleushash != nullptr) {
    
  } else {
    
  }
  _impl_.nucleushash_.SetAllocated(nucleushash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nucleushash_.IsDefault()) {
    _impl_.nucleushash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.nucleusHash)
}

// string hardwareName = 10;
inline void Player::clear_hardwarename() {
  _impl_.hardwarename_.ClearToEmpty();
}
inline const std::string& Player::hardwarename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.hardwareName)
  return _internal_hardwarename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_hardwarename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hardwarename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.hardwareName)
}
inline std::string* Player::mutable_hardwarename() {
  std::string* _s = _internal_mutable_hardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.hardwareName)
  return _s;
}
inline const std::string& Player::_internal_hardwarename() const {
  return _impl_.hardwarename_.Get();
}
inline void Player::_internal_set_hardwarename(const std::string& value) {
  
  _impl_.hardwarename_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_hardwarename() {
  
  return _impl_.hardwarename_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_hardwarename() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.hardwareName)
  return _impl_.hardwarename_.Release();
}
inline void Player::set_allocated_hardwarename(std::string* hardwarename) {
  if (hardwarename != nullptr) {
    
  } else {
    
  }
  _impl_.hardwarename_.SetAllocated(hardwarename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hardwarename_.IsDefault()) {
    _impl_.hardwarename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.hardwareName)
}

// string teamName = 11;
inline void Player::clear_teamname() {
  _impl_.teamname_.ClearToEmpty();
}
inline const std::string& Player::teamname() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.teamName)
  return _internal_teamname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_teamname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.teamname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.teamName)
}
inline std::string* Player::mutable_teamname() {
  std::string* _s = _internal_mutable_teamname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.teamName)
  return _s;
}
inline const std::string& Player::_internal_teamname() const {
  return _impl_.teamname_.Get();
}
inline void Player::_internal_set_teamname(const std::string& value) {
  
  _impl_.teamname_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_teamname() {
  
  return _impl_.teamname_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_teamname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.teamName)
  return _impl_.teamname_.Release();
}
inline void Player::set_allocated_teamname(std::string* teamname) {
  if (teamname != nullptr) {
    
  } else {
    
  }
  _impl_.teamname_.SetAllocated(teamname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.teamname_.IsDefault()) {
    _impl_.teamname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.teamName)
}

// uint32 squadIndex = 12;
inline void Player::clear_squadindex() {
  _impl_.squadindex_ = 0u;
}
inline uint32_t Player::_internal_squadindex() const {
  return _impl_.squadindex_;
}
inline uint32_t Player::squadindex() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.squadIndex)
  return _internal_squadindex();
}
inline void Player::_internal_set_squadindex(uint32_t value) {
  
  _impl_.squadindex_ = value;
}
inline void Player::set_squadindex(uint32_t value) {
  _internal_set_squadindex(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.squadIndex)
}

// string character = 13;
inline void Player::clear_character() {
  _impl_.character_.ClearToEmpty();
}
inline const std::string& Player::character() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.character)
  return _internal_character();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_character(ArgT0&& arg0, ArgT... args) {
 
 _impl_.character_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.character)
}
inline std::string* Player::mutable_character() {
  std::string* _s = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.character)
  return _s;
}
inline const std::string& Player::_internal_character() const {
  return _impl_.character_.Get();
}
inline void Player::_internal_set_character(const std::string& value) {
  
  _impl_.character_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_character() {
  
  return _impl_.character_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_character() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.character)
  return _impl_.character_.Release();
}
inline void Player::set_allocated_character(std::string* character) {
  if (character != nullptr) {
    
  } else {
    
  }
  _impl_.character_.SetAllocated(character, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.character_.IsDefault()) {
    _impl_.character_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.character)
}

// string skin = 14;
inline void Player::clear_skin() {
  _impl_.skin_.ClearToEmpty();
}
inline const std::string& Player::skin() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Player.skin)
  return _internal_skin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_skin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.skin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Player.skin)
}
inline std::string* Player::mutable_skin() {
  std::string* _s = _internal_mutable_skin();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Player.skin)
  return _s;
}
inline const std::string& Player::_internal_skin() const {
  return _impl_.skin_.Get();
}
inline void Player::_internal_set_skin(const std::string& value) {
  
  _impl_.skin_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_skin() {
  
  return _impl_.skin_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_skin() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Player.skin)
  return _impl_.skin_.Release();
}
inline void Player::set_allocated_skin(std::string* skin) {
  if (skin != nullptr) {
    
  } else {
    
  }
  _impl_.skin_.SetAllocated(skin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.skin_.IsDefault()) {
    _impl_.skin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Player.skin)
}

// -------------------------------------------------------------------

// CustomMatch_LobbyPlayer

// string name = 1;
inline void CustomMatch_LobbyPlayer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayer::name() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_LobbyPlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.name)
}
inline std::string* CustomMatch_LobbyPlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayer.name)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CustomMatch_LobbyPlayer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayer::release_name() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayer.name)
  return _impl_.name_.Release();
}
inline void CustomMatch_LobbyPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayer.name)
}

// uint32 teamId = 2;
inline void CustomMatch_LobbyPlayer::clear_teamid() {
  _impl_.teamid_ = 0u;
}
inline uint32_t CustomMatch_LobbyPlayer::_internal_teamid() const {
  return _impl_.teamid_;
}
inline uint32_t CustomMatch_LobbyPlayer::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.teamId)
  return _internal_teamid();
}
inline void CustomMatch_LobbyPlayer::_internal_set_teamid(uint32_t value) {
  
  _impl_.teamid_ = value;
}
inline void CustomMatch_LobbyPlayer::set_teamid(uint32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.teamId)
}

// string nucleusHash = 3;
inline void CustomMatch_LobbyPlayer::clear_nucleushash() {
  _impl_.nucleushash_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayer::nucleushash() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
  return _internal_nucleushash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_LobbyPlayer::set_nucleushash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nucleushash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
}
inline std::string* CustomMatch_LobbyPlayer::mutable_nucleushash() {
  std::string* _s = _internal_mutable_nucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayer::_internal_nucleushash() const {
  return _impl_.nucleushash_.Get();
}
inline void CustomMatch_LobbyPlayer::_internal_set_nucleushash(const std::string& value) {
  
  _impl_.nucleushash_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayer::_internal_mutable_nucleushash() {
  
  return _impl_.nucleushash_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayer::release_nucleushash() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
  return _impl_.nucleushash_.Release();
}
inline void CustomMatch_LobbyPlayer::set_allocated_nucleushash(std::string* nucleushash) {
  if (nucleushash != nullptr) {
    
  } else {
    
  }
  _impl_.nucleushash_.SetAllocated(nucleushash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nucleushash_.IsDefault()) {
    _impl_.nucleushash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayer.nucleusHash)
}

// string hardwareName = 4;
inline void CustomMatch_LobbyPlayer::clear_hardwarename() {
  _impl_.hardwarename_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayer::hardwarename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
  return _internal_hardwarename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_LobbyPlayer::set_hardwarename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hardwarename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
}
inline std::string* CustomMatch_LobbyPlayer::mutable_hardwarename() {
  std::string* _s = _internal_mutable_hardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayer::_internal_hardwarename() const {
  return _impl_.hardwarename_.Get();
}
inline void CustomMatch_LobbyPlayer::_internal_set_hardwarename(const std::string& value) {
  
  _impl_.hardwarename_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayer::_internal_mutable_hardwarename() {
  
  return _impl_.hardwarename_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayer::release_hardwarename() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
  return _impl_.hardwarename_.Release();
}
inline void CustomMatch_LobbyPlayer::set_allocated_hardwarename(std::string* hardwarename) {
  if (hardwarename != nullptr) {
    
  } else {
    
  }
  _impl_.hardwarename_.SetAllocated(hardwarename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hardwarename_.IsDefault()) {
    _impl_.hardwarename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayer.hardwareName)
}

// -------------------------------------------------------------------

// Datacenter

// uint64 timestamp = 1;
inline void Datacenter::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t Datacenter::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t Datacenter::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Datacenter.timestamp)
  return _internal_timestamp();
}
inline void Datacenter::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Datacenter::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Datacenter.timestamp)
}

// string category = 2;
inline void Datacenter::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& Datacenter::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Datacenter.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datacenter::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Datacenter.category)
}
inline std::string* Datacenter::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Datacenter.category)
  return _s;
}
inline const std::string& Datacenter::_internal_category() const {
  return _impl_.category_.Get();
}
inline void Datacenter::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* Datacenter::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* Datacenter::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Datacenter.category)
  return _impl_.category_.Release();
}
inline void Datacenter::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Datacenter.category)
}

// string name = 3;
inline void Datacenter::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Datacenter::name() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Datacenter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datacenter::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Datacenter.name)
}
inline std::string* Datacenter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Datacenter.name)
  return _s;
}
inline const std::string& Datacenter::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Datacenter::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Datacenter::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Datacenter::release_name() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Datacenter.name)
  return _impl_.name_.Release();
}
inline void Datacenter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Datacenter.name)
}

// -------------------------------------------------------------------

// Version

// uint32 major_num = 1;
inline void Version::clear_major_num() {
  _impl_.major_num_ = 0u;
}
inline uint32_t Version::_internal_major_num() const {
  return _impl_.major_num_;
}
inline uint32_t Version::major_num() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.major_num)
  return _internal_major_num();
}
inline void Version::_internal_set_major_num(uint32_t value) {
  
  _impl_.major_num_ = value;
}
inline void Version::set_major_num(uint32_t value) {
  _internal_set_major_num(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.major_num)
}

// uint32 minor_num = 2;
inline void Version::clear_minor_num() {
  _impl_.minor_num_ = 0u;
}
inline uint32_t Version::_internal_minor_num() const {
  return _impl_.minor_num_;
}
inline uint32_t Version::minor_num() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.minor_num)
  return _internal_minor_num();
}
inline void Version::_internal_set_minor_num(uint32_t value) {
  
  _impl_.minor_num_ = value;
}
inline void Version::set_minor_num(uint32_t value) {
  _internal_set_minor_num(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.minor_num)
}

// uint32 build_stamp = 3;
inline void Version::clear_build_stamp() {
  _impl_.build_stamp_ = 0u;
}
inline uint32_t Version::_internal_build_stamp() const {
  return _impl_.build_stamp_;
}
inline uint32_t Version::build_stamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.build_stamp)
  return _internal_build_stamp();
}
inline void Version::_internal_set_build_stamp(uint32_t value) {
  
  _impl_.build_stamp_ = value;
}
inline void Version::set_build_stamp(uint32_t value) {
  _internal_set_build_stamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.build_stamp)
}

// string revision = 4;
inline void Version::clear_revision() {
  _impl_.revision_.ClearToEmpty();
}
inline const std::string& Version::revision() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Version.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_revision(ArgT0&& arg0, ArgT... args) {
 
 _impl_.revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Version.revision)
}
inline std::string* Version::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Version.revision)
  return _s;
}
inline const std::string& Version::_internal_revision() const {
  return _impl_.revision_.Get();
}
inline void Version::_internal_set_revision(const std::string& value) {
  
  _impl_.revision_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_revision() {
  
  return _impl_.revision_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_revision() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Version.revision)
  return _impl_.revision_.Release();
}
inline void Version::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  _impl_.revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.revision_.IsDefault()) {
    _impl_.revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Version.revision)
}

// -------------------------------------------------------------------

// InventoryItem

// int32 quantity = 1;
inline void InventoryItem::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t InventoryItem::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t InventoryItem::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryItem.quantity)
  return _internal_quantity();
}
inline void InventoryItem::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void InventoryItem::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryItem.quantity)
}

// string item = 2;
inline void InventoryItem::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryItem::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryItem.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryItem::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryItem.item)
}
inline std::string* InventoryItem::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryItem.item)
  return _s;
}
inline const std::string& InventoryItem::_internal_item() const {
  return _impl_.item_.Get();
}
inline void InventoryItem::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryItem::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryItem::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryItem.item)
  return _impl_.item_.Release();
}
inline void InventoryItem::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryItem.item)
}

// string extraData = 3;
inline void InventoryItem::clear_extradata() {
  _impl_.extradata_.ClearToEmpty();
}
inline const std::string& InventoryItem::extradata() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryItem.extraData)
  return _internal_extradata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryItem::set_extradata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extradata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryItem.extraData)
}
inline std::string* InventoryItem::mutable_extradata() {
  std::string* _s = _internal_mutable_extradata();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryItem.extraData)
  return _s;
}
inline const std::string& InventoryItem::_internal_extradata() const {
  return _impl_.extradata_.Get();
}
inline void InventoryItem::_internal_set_extradata(const std::string& value) {
  
  _impl_.extradata_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryItem::_internal_mutable_extradata() {
  
  return _impl_.extradata_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryItem::release_extradata() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryItem.extraData)
  return _impl_.extradata_.Release();
}
inline void InventoryItem::set_allocated_extradata(std::string* extradata) {
  if (extradata != nullptr) {
    
  } else {
    
  }
  _impl_.extradata_.SetAllocated(extradata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extradata_.IsDefault()) {
    _impl_.extradata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryItem.extraData)
}

// -------------------------------------------------------------------

// LoadoutConfiguration

// repeated .rtech.liveapi.InventoryItem weapons = 1;
inline int LoadoutConfiguration::_internal_weapons_size() const {
  return _impl_.weapons_.size();
}
inline int LoadoutConfiguration::weapons_size() const {
  return _internal_weapons_size();
}
inline void LoadoutConfiguration::clear_weapons() {
  _impl_.weapons_.Clear();
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LoadoutConfiguration.weapons)
  return _impl_.weapons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >*
LoadoutConfiguration::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.LoadoutConfiguration.weapons)
  return &_impl_.weapons_;
}
inline const ::rtech::liveapi::InventoryItem& LoadoutConfiguration::_internal_weapons(int index) const {
  return _impl_.weapons_.Get(index);
}
inline const ::rtech::liveapi::InventoryItem& LoadoutConfiguration::weapons(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LoadoutConfiguration.weapons)
  return _internal_weapons(index);
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::_internal_add_weapons() {
  return _impl_.weapons_.Add();
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::add_weapons() {
  ::rtech::liveapi::InventoryItem* _add = _internal_add_weapons();
  // @@protoc_insertion_point(field_add:rtech.liveapi.LoadoutConfiguration.weapons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >&
LoadoutConfiguration::weapons() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.LoadoutConfiguration.weapons)
  return _impl_.weapons_;
}

// repeated .rtech.liveapi.InventoryItem equipment = 2;
inline int LoadoutConfiguration::_internal_equipment_size() const {
  return _impl_.equipment_.size();
}
inline int LoadoutConfiguration::equipment_size() const {
  return _internal_equipment_size();
}
inline void LoadoutConfiguration::clear_equipment() {
  _impl_.equipment_.Clear();
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::mutable_equipment(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LoadoutConfiguration.equipment)
  return _impl_.equipment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >*
LoadoutConfiguration::mutable_equipment() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.LoadoutConfiguration.equipment)
  return &_impl_.equipment_;
}
inline const ::rtech::liveapi::InventoryItem& LoadoutConfiguration::_internal_equipment(int index) const {
  return _impl_.equipment_.Get(index);
}
inline const ::rtech::liveapi::InventoryItem& LoadoutConfiguration::equipment(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LoadoutConfiguration.equipment)
  return _internal_equipment(index);
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::_internal_add_equipment() {
  return _impl_.equipment_.Add();
}
inline ::rtech::liveapi::InventoryItem* LoadoutConfiguration::add_equipment() {
  ::rtech::liveapi::InventoryItem* _add = _internal_add_equipment();
  // @@protoc_insertion_point(field_add:rtech.liveapi.LoadoutConfiguration.equipment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::InventoryItem >&
LoadoutConfiguration::equipment() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.LoadoutConfiguration.equipment)
  return _impl_.equipment_;
}

// -------------------------------------------------------------------

// Init

// uint64 timestamp = 1;
inline void Init::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t Init::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t Init::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.timestamp)
  return _internal_timestamp();
}
inline void Init::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Init::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.timestamp)
}

// string category = 2;
inline void Init::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& Init::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.category)
}
inline std::string* Init::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.category)
  return _s;
}
inline const std::string& Init::_internal_category() const {
  return _impl_.category_.Get();
}
inline void Init::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.category)
  return _impl_.category_.Release();
}
inline void Init::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.category)
}

// string gameVersion = 3;
inline void Init::clear_gameversion() {
  _impl_.gameversion_.ClearToEmpty();
}
inline const std::string& Init::gameversion() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.gameVersion)
  return _internal_gameversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_gameversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gameversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.gameVersion)
}
inline std::string* Init::mutable_gameversion() {
  std::string* _s = _internal_mutable_gameversion();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.gameVersion)
  return _s;
}
inline const std::string& Init::_internal_gameversion() const {
  return _impl_.gameversion_.Get();
}
inline void Init::_internal_set_gameversion(const std::string& value) {
  
  _impl_.gameversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_gameversion() {
  
  return _impl_.gameversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_gameversion() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.gameVersion)
  return _impl_.gameversion_.Release();
}
inline void Init::set_allocated_gameversion(std::string* gameversion) {
  if (gameversion != nullptr) {
    
  } else {
    
  }
  _impl_.gameversion_.SetAllocated(gameversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gameversion_.IsDefault()) {
    _impl_.gameversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.gameVersion)
}

// .rtech.liveapi.Version apiVersion = 4;
inline bool Init::_internal_has_apiversion() const {
  return this != internal_default_instance() && _impl_.apiversion_ != nullptr;
}
inline bool Init::has_apiversion() const {
  return _internal_has_apiversion();
}
inline void Init::clear_apiversion() {
  if (GetArenaForAllocation() == nullptr && _impl_.apiversion_ != nullptr) {
    delete _impl_.apiversion_;
  }
  _impl_.apiversion_ = nullptr;
}
inline const ::rtech::liveapi::Version& Init::_internal_apiversion() const {
  const ::rtech::liveapi::Version* p = _impl_.apiversion_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Version&>(
      ::rtech::liveapi::_Version_default_instance_);
}
inline const ::rtech::liveapi::Version& Init::apiversion() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.apiVersion)
  return _internal_apiversion();
}
inline void Init::unsafe_arena_set_allocated_apiversion(
    ::rtech::liveapi::Version* apiversion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.apiversion_);
  }
  _impl_.apiversion_ = apiversion;
  if (apiversion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Init.apiVersion)
}
inline ::rtech::liveapi::Version* Init::release_apiversion() {
  
  ::rtech::liveapi::Version* temp = _impl_.apiversion_;
  _impl_.apiversion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Version* Init::unsafe_arena_release_apiversion() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.apiVersion)
  
  ::rtech::liveapi::Version* temp = _impl_.apiversion_;
  _impl_.apiversion_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Version* Init::_internal_mutable_apiversion() {
  
  if (_impl_.apiversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Version>(GetArenaForAllocation());
    _impl_.apiversion_ = p;
  }
  return _impl_.apiversion_;
}
inline ::rtech::liveapi::Version* Init::mutable_apiversion() {
  ::rtech::liveapi::Version* _msg = _internal_mutable_apiversion();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.apiVersion)
  return _msg;
}
inline void Init::set_allocated_apiversion(::rtech::liveapi::Version* apiversion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.apiversion_;
  }
  if (apiversion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(apiversion);
    if (message_arena != submessage_arena) {
      apiversion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apiversion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.apiversion_ = apiversion;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.apiVersion)
}

// string platform = 5;
inline void Init::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& Init::platform() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_platform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.platform)
}
inline std::string* Init::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.platform)
  return _s;
}
inline const std::string& Init::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void Init::_internal_set_platform(const std::string& value) {
  
  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_platform() {
  
  return _impl_.platform_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_platform() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.platform)
  return _impl_.platform_.Release();
}
inline void Init::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  _impl_.platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.platform)
}

// string name = 6;
inline void Init::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Init::name() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Init.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Init.name)
}
inline std::string* Init::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Init.name)
  return _s;
}
inline const std::string& Init::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Init::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_name() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Init.name)
  return _impl_.name_.Release();
}
inline void Init::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Init.name)
}

// -------------------------------------------------------------------

// CustomMatch_LobbyPlayers

// string playerToken = 1;
inline void CustomMatch_LobbyPlayers::clear_playertoken() {
  _impl_.playertoken_.ClearToEmpty();
}
inline const std::string& CustomMatch_LobbyPlayers::playertoken() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
  return _internal_playertoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_LobbyPlayers::set_playertoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playertoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
}
inline std::string* CustomMatch_LobbyPlayers::mutable_playertoken() {
  std::string* _s = _internal_mutable_playertoken();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
  return _s;
}
inline const std::string& CustomMatch_LobbyPlayers::_internal_playertoken() const {
  return _impl_.playertoken_.Get();
}
inline void CustomMatch_LobbyPlayers::_internal_set_playertoken(const std::string& value) {
  
  _impl_.playertoken_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayers::_internal_mutable_playertoken() {
  
  return _impl_.playertoken_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_LobbyPlayers::release_playertoken() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
  return _impl_.playertoken_.Release();
}
inline void CustomMatch_LobbyPlayers::set_allocated_playertoken(std::string* playertoken) {
  if (playertoken != nullptr) {
    
  } else {
    
  }
  _impl_.playertoken_.SetAllocated(playertoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playertoken_.IsDefault()) {
    _impl_.playertoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_LobbyPlayers.playerToken)
}

// repeated .rtech.liveapi.CustomMatch_LobbyPlayer players = 2;
inline int CustomMatch_LobbyPlayers::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int CustomMatch_LobbyPlayers::players_size() const {
  return _internal_players_size();
}
inline void CustomMatch_LobbyPlayers::clear_players() {
  _impl_.players_.Clear();
}
inline ::rtech::liveapi::CustomMatch_LobbyPlayer* CustomMatch_LobbyPlayers::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer >*
CustomMatch_LobbyPlayers::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return &_impl_.players_;
}
inline const ::rtech::liveapi::CustomMatch_LobbyPlayer& CustomMatch_LobbyPlayers::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::rtech::liveapi::CustomMatch_LobbyPlayer& CustomMatch_LobbyPlayers::players(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _internal_players(index);
}
inline ::rtech::liveapi::CustomMatch_LobbyPlayer* CustomMatch_LobbyPlayers::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::rtech::liveapi::CustomMatch_LobbyPlayer* CustomMatch_LobbyPlayers::add_players() {
  ::rtech::liveapi::CustomMatch_LobbyPlayer* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::CustomMatch_LobbyPlayer >&
CustomMatch_LobbyPlayers::players() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.CustomMatch_LobbyPlayers.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// ObserverSwitched

// uint64 timestamp = 1;
inline void ObserverSwitched::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ObserverSwitched::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ObserverSwitched::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.timestamp)
  return _internal_timestamp();
}
inline void ObserverSwitched::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ObserverSwitched::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverSwitched.timestamp)
}

// string category = 2;
inline void ObserverSwitched::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ObserverSwitched::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObserverSwitched::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverSwitched.category)
}
inline std::string* ObserverSwitched::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.category)
  return _s;
}
inline const std::string& ObserverSwitched::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ObserverSwitched::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ObserverSwitched::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ObserverSwitched::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverSwitched.category)
  return _impl_.category_.Release();
}
inline void ObserverSwitched::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverSwitched.category)
}

// .rtech.liveapi.Player observer = 3;
inline bool ObserverSwitched::_internal_has_observer() const {
  return this != internal_default_instance() && _impl_.observer_ != nullptr;
}
inline bool ObserverSwitched::has_observer() const {
  return _internal_has_observer();
}
inline void ObserverSwitched::clear_observer() {
  if (GetArenaForAllocation() == nullptr && _impl_.observer_ != nullptr) {
    delete _impl_.observer_;
  }
  _impl_.observer_ = nullptr;
}
inline const ::rtech::liveapi::Player& ObserverSwitched::_internal_observer() const {
  const ::rtech::liveapi::Player* p = _impl_.observer_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ObserverSwitched::observer() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.observer)
  return _internal_observer();
}
inline void ObserverSwitched::unsafe_arena_set_allocated_observer(
    ::rtech::liveapi::Player* observer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.observer_);
  }
  _impl_.observer_ = observer;
  if (observer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ObserverSwitched.observer)
}
inline ::rtech::liveapi::Player* ObserverSwitched::release_observer() {
  
  ::rtech::liveapi::Player* temp = _impl_.observer_;
  _impl_.observer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* ObserverSwitched::unsafe_arena_release_observer() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverSwitched.observer)
  
  ::rtech::liveapi::Player* temp = _impl_.observer_;
  _impl_.observer_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ObserverSwitched::_internal_mutable_observer() {
  
  if (_impl_.observer_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.observer_ = p;
  }
  return _impl_.observer_;
}
inline ::rtech::liveapi::Player* ObserverSwitched::mutable_observer() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_observer();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.observer)
  return _msg;
}
inline void ObserverSwitched::set_allocated_observer(::rtech::liveapi::Player* observer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.observer_;
  }
  if (observer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(observer);
    if (message_arena != submessage_arena) {
      observer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, observer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.observer_ = observer;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverSwitched.observer)
}

// .rtech.liveapi.Player target = 4;
inline bool ObserverSwitched::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool ObserverSwitched::has_target() const {
  return _internal_has_target();
}
inline void ObserverSwitched::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::rtech::liveapi::Player& ObserverSwitched::_internal_target() const {
  const ::rtech::liveapi::Player* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ObserverSwitched::target() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.target)
  return _internal_target();
}
inline void ObserverSwitched::unsafe_arena_set_allocated_target(
    ::rtech::liveapi::Player* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ObserverSwitched.target)
}
inline ::rtech::liveapi::Player* ObserverSwitched::release_target() {
  
  ::rtech::liveapi::Player* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* ObserverSwitched::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverSwitched.target)
  
  ::rtech::liveapi::Player* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ObserverSwitched::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::rtech::liveapi::Player* ObserverSwitched::mutable_target() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.target)
  return _msg;
}
inline void ObserverSwitched::set_allocated_target(::rtech::liveapi::Player* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverSwitched.target)
}

// repeated .rtech.liveapi.Player targetTeam = 5;
inline int ObserverSwitched::_internal_targetteam_size() const {
  return _impl_.targetteam_.size();
}
inline int ObserverSwitched::targetteam_size() const {
  return _internal_targetteam_size();
}
inline void ObserverSwitched::clear_targetteam() {
  _impl_.targetteam_.Clear();
}
inline ::rtech::liveapi::Player* ObserverSwitched::mutable_targetteam(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverSwitched.targetTeam)
  return _impl_.targetteam_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
ObserverSwitched::mutable_targetteam() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.ObserverSwitched.targetTeam)
  return &_impl_.targetteam_;
}
inline const ::rtech::liveapi::Player& ObserverSwitched::_internal_targetteam(int index) const {
  return _impl_.targetteam_.Get(index);
}
inline const ::rtech::liveapi::Player& ObserverSwitched::targetteam(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverSwitched.targetTeam)
  return _internal_targetteam(index);
}
inline ::rtech::liveapi::Player* ObserverSwitched::_internal_add_targetteam() {
  return _impl_.targetteam_.Add();
}
inline ::rtech::liveapi::Player* ObserverSwitched::add_targetteam() {
  ::rtech::liveapi::Player* _add = _internal_add_targetteam();
  // @@protoc_insertion_point(field_add:rtech.liveapi.ObserverSwitched.targetTeam)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
ObserverSwitched::targetteam() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.ObserverSwitched.targetTeam)
  return _impl_.targetteam_;
}

// -------------------------------------------------------------------

// ObserverAnnotation

// uint64 timestamp = 1;
inline void ObserverAnnotation::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ObserverAnnotation::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ObserverAnnotation::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverAnnotation.timestamp)
  return _internal_timestamp();
}
inline void ObserverAnnotation::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ObserverAnnotation::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverAnnotation.timestamp)
}

// string category = 2;
inline void ObserverAnnotation::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ObserverAnnotation::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverAnnotation.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObserverAnnotation::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverAnnotation.category)
}
inline std::string* ObserverAnnotation::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ObserverAnnotation.category)
  return _s;
}
inline const std::string& ObserverAnnotation::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ObserverAnnotation::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ObserverAnnotation::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ObserverAnnotation::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ObserverAnnotation.category)
  return _impl_.category_.Release();
}
inline void ObserverAnnotation::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ObserverAnnotation.category)
}

// int32 annotationSerial = 3;
inline void ObserverAnnotation::clear_annotationserial() {
  _impl_.annotationserial_ = 0;
}
inline int32_t ObserverAnnotation::_internal_annotationserial() const {
  return _impl_.annotationserial_;
}
inline int32_t ObserverAnnotation::annotationserial() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ObserverAnnotation.annotationSerial)
  return _internal_annotationserial();
}
inline void ObserverAnnotation::_internal_set_annotationserial(int32_t value) {
  
  _impl_.annotationserial_ = value;
}
inline void ObserverAnnotation::set_annotationserial(int32_t value) {
  _internal_set_annotationserial(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ObserverAnnotation.annotationSerial)
}

// -------------------------------------------------------------------

// MatchSetup

// uint64 timestamp = 1;
inline void MatchSetup::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t MatchSetup::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t MatchSetup::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.timestamp)
  return _internal_timestamp();
}
inline void MatchSetup::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MatchSetup::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.timestamp)
}

// string category = 2;
inline void MatchSetup::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& MatchSetup::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchSetup::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.category)
}
inline std::string* MatchSetup::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.category)
  return _s;
}
inline const std::string& MatchSetup::_internal_category() const {
  return _impl_.category_.Get();
}
inline void MatchSetup::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchSetup::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchSetup::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.category)
  return _impl_.category_.Release();
}
inline void MatchSetup::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.category)
}

// string map = 3;
inline void MatchSetup::clear_map() {
  _impl_.map_.ClearToEmpty();
}
inline const std::string& MatchSetup::map() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.map)
  return _internal_map();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchSetup::set_map(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.map)
}
inline std::string* MatchSetup::mutable_map() {
  std::string* _s = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.map)
  return _s;
}
inline const std::string& MatchSetup::_internal_map() const {
  return _impl_.map_.Get();
}
inline void MatchSetup::_internal_set_map(const std::string& value) {
  
  _impl_.map_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchSetup::_internal_mutable_map() {
  
  return _impl_.map_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchSetup::release_map() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.map)
  return _impl_.map_.Release();
}
inline void MatchSetup::set_allocated_map(std::string* map) {
  if (map != nullptr) {
    
  } else {
    
  }
  _impl_.map_.SetAllocated(map, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_.IsDefault()) {
    _impl_.map_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.map)
}

// string playlistName = 4;
inline void MatchSetup::clear_playlistname() {
  _impl_.playlistname_.ClearToEmpty();
}
inline const std::string& MatchSetup::playlistname() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.playlistName)
  return _internal_playlistname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchSetup::set_playlistname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playlistname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.playlistName)
}
inline std::string* MatchSetup::mutable_playlistname() {
  std::string* _s = _internal_mutable_playlistname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.playlistName)
  return _s;
}
inline const std::string& MatchSetup::_internal_playlistname() const {
  return _impl_.playlistname_.Get();
}
inline void MatchSetup::_internal_set_playlistname(const std::string& value) {
  
  _impl_.playlistname_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchSetup::_internal_mutable_playlistname() {
  
  return _impl_.playlistname_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchSetup::release_playlistname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.playlistName)
  return _impl_.playlistname_.Release();
}
inline void MatchSetup::set_allocated_playlistname(std::string* playlistname) {
  if (playlistname != nullptr) {
    
  } else {
    
  }
  _impl_.playlistname_.SetAllocated(playlistname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playlistname_.IsDefault()) {
    _impl_.playlistname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.playlistName)
}

// string playlistDesc = 5;
inline void MatchSetup::clear_playlistdesc() {
  _impl_.playlistdesc_.ClearToEmpty();
}
inline const std::string& MatchSetup::playlistdesc() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.playlistDesc)
  return _internal_playlistdesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchSetup::set_playlistdesc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playlistdesc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.playlistDesc)
}
inline std::string* MatchSetup::mutable_playlistdesc() {
  std::string* _s = _internal_mutable_playlistdesc();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.playlistDesc)
  return _s;
}
inline const std::string& MatchSetup::_internal_playlistdesc() const {
  return _impl_.playlistdesc_.Get();
}
inline void MatchSetup::_internal_set_playlistdesc(const std::string& value) {
  
  _impl_.playlistdesc_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchSetup::_internal_mutable_playlistdesc() {
  
  return _impl_.playlistdesc_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchSetup::release_playlistdesc() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.playlistDesc)
  return _impl_.playlistdesc_.Release();
}
inline void MatchSetup::set_allocated_playlistdesc(std::string* playlistdesc) {
  if (playlistdesc != nullptr) {
    
  } else {
    
  }
  _impl_.playlistdesc_.SetAllocated(playlistdesc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playlistdesc_.IsDefault()) {
    _impl_.playlistdesc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.playlistDesc)
}

// .rtech.liveapi.Datacenter datacenter = 6;
inline bool MatchSetup::_internal_has_datacenter() const {
  return this != internal_default_instance() && _impl_.datacenter_ != nullptr;
}
inline bool MatchSetup::has_datacenter() const {
  return _internal_has_datacenter();
}
inline void MatchSetup::clear_datacenter() {
  if (GetArenaForAllocation() == nullptr && _impl_.datacenter_ != nullptr) {
    delete _impl_.datacenter_;
  }
  _impl_.datacenter_ = nullptr;
}
inline const ::rtech::liveapi::Datacenter& MatchSetup::_internal_datacenter() const {
  const ::rtech::liveapi::Datacenter* p = _impl_.datacenter_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Datacenter&>(
      ::rtech::liveapi::_Datacenter_default_instance_);
}
inline const ::rtech::liveapi::Datacenter& MatchSetup::datacenter() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.datacenter)
  return _internal_datacenter();
}
inline void MatchSetup::unsafe_arena_set_allocated_datacenter(
    ::rtech::liveapi::Datacenter* datacenter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datacenter_);
  }
  _impl_.datacenter_ = datacenter;
  if (datacenter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.MatchSetup.datacenter)
}
inline ::rtech::liveapi::Datacenter* MatchSetup::release_datacenter() {
  
  ::rtech::liveapi::Datacenter* temp = _impl_.datacenter_;
  _impl_.datacenter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Datacenter* MatchSetup::unsafe_arena_release_datacenter() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.datacenter)
  
  ::rtech::liveapi::Datacenter* temp = _impl_.datacenter_;
  _impl_.datacenter_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Datacenter* MatchSetup::_internal_mutable_datacenter() {
  
  if (_impl_.datacenter_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Datacenter>(GetArenaForAllocation());
    _impl_.datacenter_ = p;
  }
  return _impl_.datacenter_;
}
inline ::rtech::liveapi::Datacenter* MatchSetup::mutable_datacenter() {
  ::rtech::liveapi::Datacenter* _msg = _internal_mutable_datacenter();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.datacenter)
  return _msg;
}
inline void MatchSetup::set_allocated_datacenter(::rtech::liveapi::Datacenter* datacenter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.datacenter_;
  }
  if (datacenter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datacenter);
    if (message_arena != submessage_arena) {
      datacenter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datacenter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datacenter_ = datacenter;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.datacenter)
}

// bool aimAssistOn = 7;
inline void MatchSetup::clear_aimassiston() {
  _impl_.aimassiston_ = false;
}
inline bool MatchSetup::_internal_aimassiston() const {
  return _impl_.aimassiston_;
}
inline bool MatchSetup::aimassiston() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.aimAssistOn)
  return _internal_aimassiston();
}
inline void MatchSetup::_internal_set_aimassiston(bool value) {
  
  _impl_.aimassiston_ = value;
}
inline void MatchSetup::set_aimassiston(bool value) {
  _internal_set_aimassiston(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.aimAssistOn)
}

// bool anonymousMode = 8;
inline void MatchSetup::clear_anonymousmode() {
  _impl_.anonymousmode_ = false;
}
inline bool MatchSetup::_internal_anonymousmode() const {
  return _impl_.anonymousmode_;
}
inline bool MatchSetup::anonymousmode() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.anonymousMode)
  return _internal_anonymousmode();
}
inline void MatchSetup::_internal_set_anonymousmode(bool value) {
  
  _impl_.anonymousmode_ = value;
}
inline void MatchSetup::set_anonymousmode(bool value) {
  _internal_set_anonymousmode(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.anonymousMode)
}

// string serverId = 9;
inline void MatchSetup::clear_serverid() {
  _impl_.serverid_.ClearToEmpty();
}
inline const std::string& MatchSetup::serverid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.serverId)
  return _internal_serverid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchSetup::set_serverid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serverid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchSetup.serverId)
}
inline std::string* MatchSetup::mutable_serverid() {
  std::string* _s = _internal_mutable_serverid();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.serverId)
  return _s;
}
inline const std::string& MatchSetup::_internal_serverid() const {
  return _impl_.serverid_.Get();
}
inline void MatchSetup::_internal_set_serverid(const std::string& value) {
  
  _impl_.serverid_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchSetup::_internal_mutable_serverid() {
  
  return _impl_.serverid_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchSetup::release_serverid() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.serverId)
  return _impl_.serverid_.Release();
}
inline void MatchSetup::set_allocated_serverid(std::string* serverid) {
  if (serverid != nullptr) {
    
  } else {
    
  }
  _impl_.serverid_.SetAllocated(serverid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverid_.IsDefault()) {
    _impl_.serverid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.serverId)
}

// .rtech.liveapi.LoadoutConfiguration startingLoadout = 10;
inline bool MatchSetup::_internal_has_startingloadout() const {
  return this != internal_default_instance() && _impl_.startingloadout_ != nullptr;
}
inline bool MatchSetup::has_startingloadout() const {
  return _internal_has_startingloadout();
}
inline void MatchSetup::clear_startingloadout() {
  if (GetArenaForAllocation() == nullptr && _impl_.startingloadout_ != nullptr) {
    delete _impl_.startingloadout_;
  }
  _impl_.startingloadout_ = nullptr;
}
inline const ::rtech::liveapi::LoadoutConfiguration& MatchSetup::_internal_startingloadout() const {
  const ::rtech::liveapi::LoadoutConfiguration* p = _impl_.startingloadout_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::LoadoutConfiguration&>(
      ::rtech::liveapi::_LoadoutConfiguration_default_instance_);
}
inline const ::rtech::liveapi::LoadoutConfiguration& MatchSetup::startingloadout() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchSetup.startingLoadout)
  return _internal_startingloadout();
}
inline void MatchSetup::unsafe_arena_set_allocated_startingloadout(
    ::rtech::liveapi::LoadoutConfiguration* startingloadout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.startingloadout_);
  }
  _impl_.startingloadout_ = startingloadout;
  if (startingloadout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.MatchSetup.startingLoadout)
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::release_startingloadout() {
  
  ::rtech::liveapi::LoadoutConfiguration* temp = _impl_.startingloadout_;
  _impl_.startingloadout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::unsafe_arena_release_startingloadout() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchSetup.startingLoadout)
  
  ::rtech::liveapi::LoadoutConfiguration* temp = _impl_.startingloadout_;
  _impl_.startingloadout_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::_internal_mutable_startingloadout() {
  
  if (_impl_.startingloadout_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::LoadoutConfiguration>(GetArenaForAllocation());
    _impl_.startingloadout_ = p;
  }
  return _impl_.startingloadout_;
}
inline ::rtech::liveapi::LoadoutConfiguration* MatchSetup::mutable_startingloadout() {
  ::rtech::liveapi::LoadoutConfiguration* _msg = _internal_mutable_startingloadout();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchSetup.startingLoadout)
  return _msg;
}
inline void MatchSetup::set_allocated_startingloadout(::rtech::liveapi::LoadoutConfiguration* startingloadout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.startingloadout_;
  }
  if (startingloadout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(startingloadout);
    if (message_arena != submessage_arena) {
      startingloadout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startingloadout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.startingloadout_ = startingloadout;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchSetup.startingLoadout)
}

// -------------------------------------------------------------------

// GameStateChanged

// uint64 timestamp = 1;
inline void GameStateChanged::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t GameStateChanged::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t GameStateChanged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GameStateChanged.timestamp)
  return _internal_timestamp();
}
inline void GameStateChanged::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void GameStateChanged::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GameStateChanged.timestamp)
}

// string category = 2;
inline void GameStateChanged::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& GameStateChanged::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GameStateChanged.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStateChanged::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GameStateChanged.category)
}
inline std::string* GameStateChanged::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GameStateChanged.category)
  return _s;
}
inline const std::string& GameStateChanged::_internal_category() const {
  return _impl_.category_.Get();
}
inline void GameStateChanged::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStateChanged::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStateChanged::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GameStateChanged.category)
  return _impl_.category_.Release();
}
inline void GameStateChanged::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GameStateChanged.category)
}

// string state = 3;
inline void GameStateChanged::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& GameStateChanged::state() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GameStateChanged.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStateChanged::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GameStateChanged.state)
}
inline std::string* GameStateChanged::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GameStateChanged.state)
  return _s;
}
inline const std::string& GameStateChanged::_internal_state() const {
  return _impl_.state_.Get();
}
inline void GameStateChanged::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStateChanged::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStateChanged::release_state() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GameStateChanged.state)
  return _impl_.state_.Release();
}
inline void GameStateChanged::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GameStateChanged.state)
}

// -------------------------------------------------------------------

// CharacterSelected

// uint64 timestamp = 1;
inline void CharacterSelected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t CharacterSelected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t CharacterSelected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CharacterSelected.timestamp)
  return _internal_timestamp();
}
inline void CharacterSelected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void CharacterSelected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CharacterSelected.timestamp)
}

// string category = 2;
inline void CharacterSelected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& CharacterSelected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CharacterSelected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterSelected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CharacterSelected.category)
}
inline std::string* CharacterSelected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CharacterSelected.category)
  return _s;
}
inline const std::string& CharacterSelected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void CharacterSelected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterSelected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* CharacterSelected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CharacterSelected.category)
  return _impl_.category_.Release();
}
inline void CharacterSelected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CharacterSelected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool CharacterSelected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool CharacterSelected::has_player() const {
  return _internal_has_player();
}
inline void CharacterSelected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& CharacterSelected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& CharacterSelected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CharacterSelected.player)
  return _internal_player();
}
inline void CharacterSelected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.CharacterSelected.player)
}
inline ::rtech::liveapi::Player* CharacterSelected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* CharacterSelected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CharacterSelected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* CharacterSelected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* CharacterSelected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CharacterSelected.player)
  return _msg;
}
inline void CharacterSelected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CharacterSelected.player)
}

// -------------------------------------------------------------------

// MatchStateEnd

// uint64 timestamp = 1;
inline void MatchStateEnd::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t MatchStateEnd::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t MatchStateEnd::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.timestamp)
  return _internal_timestamp();
}
inline void MatchStateEnd::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MatchStateEnd::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchStateEnd.timestamp)
}

// string category = 2;
inline void MatchStateEnd::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& MatchStateEnd::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchStateEnd::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchStateEnd.category)
}
inline std::string* MatchStateEnd::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchStateEnd.category)
  return _s;
}
inline const std::string& MatchStateEnd::_internal_category() const {
  return _impl_.category_.Get();
}
inline void MatchStateEnd::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchStateEnd::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchStateEnd::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchStateEnd.category)
  return _impl_.category_.Release();
}
inline void MatchStateEnd::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchStateEnd.category)
}

// string state = 3;
inline void MatchStateEnd::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& MatchStateEnd::state() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchStateEnd::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.MatchStateEnd.state)
}
inline std::string* MatchStateEnd::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchStateEnd.state)
  return _s;
}
inline const std::string& MatchStateEnd::_internal_state() const {
  return _impl_.state_.Get();
}
inline void MatchStateEnd::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchStateEnd::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchStateEnd::release_state() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.MatchStateEnd.state)
  return _impl_.state_.Release();
}
inline void MatchStateEnd::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.MatchStateEnd.state)
}

// repeated .rtech.liveapi.Player winners = 4;
inline int MatchStateEnd::_internal_winners_size() const {
  return _impl_.winners_.size();
}
inline int MatchStateEnd::winners_size() const {
  return _internal_winners_size();
}
inline void MatchStateEnd::clear_winners() {
  _impl_.winners_.Clear();
}
inline ::rtech::liveapi::Player* MatchStateEnd::mutable_winners(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.MatchStateEnd.winners)
  return _impl_.winners_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
MatchStateEnd::mutable_winners() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.MatchStateEnd.winners)
  return &_impl_.winners_;
}
inline const ::rtech::liveapi::Player& MatchStateEnd::_internal_winners(int index) const {
  return _impl_.winners_.Get(index);
}
inline const ::rtech::liveapi::Player& MatchStateEnd::winners(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.MatchStateEnd.winners)
  return _internal_winners(index);
}
inline ::rtech::liveapi::Player* MatchStateEnd::_internal_add_winners() {
  return _impl_.winners_.Add();
}
inline ::rtech::liveapi::Player* MatchStateEnd::add_winners() {
  ::rtech::liveapi::Player* _add = _internal_add_winners();
  // @@protoc_insertion_point(field_add:rtech.liveapi.MatchStateEnd.winners)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
MatchStateEnd::winners() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.MatchStateEnd.winners)
  return _impl_.winners_;
}

// -------------------------------------------------------------------

// RingStartClosing

// uint64 timestamp = 1;
inline void RingStartClosing::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t RingStartClosing::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t RingStartClosing::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.timestamp)
  return _internal_timestamp();
}
inline void RingStartClosing::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RingStartClosing::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.timestamp)
}

// string category = 2;
inline void RingStartClosing::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& RingStartClosing::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingStartClosing::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.category)
}
inline std::string* RingStartClosing::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingStartClosing.category)
  return _s;
}
inline const std::string& RingStartClosing::_internal_category() const {
  return _impl_.category_.Get();
}
inline void RingStartClosing::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* RingStartClosing::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* RingStartClosing::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingStartClosing.category)
  return _impl_.category_.Release();
}
inline void RingStartClosing::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingStartClosing.category)
}

// uint32 stage = 3;
inline void RingStartClosing::clear_stage() {
  _impl_.stage_ = 0u;
}
inline uint32_t RingStartClosing::_internal_stage() const {
  return _impl_.stage_;
}
inline uint32_t RingStartClosing::stage() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.stage)
  return _internal_stage();
}
inline void RingStartClosing::_internal_set_stage(uint32_t value) {
  
  _impl_.stage_ = value;
}
inline void RingStartClosing::set_stage(uint32_t value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.stage)
}

// .rtech.liveapi.Vector3 center = 4;
inline bool RingStartClosing::_internal_has_center() const {
  return this != internal_default_instance() && _impl_.center_ != nullptr;
}
inline bool RingStartClosing::has_center() const {
  return _internal_has_center();
}
inline void RingStartClosing::clear_center() {
  if (GetArenaForAllocation() == nullptr && _impl_.center_ != nullptr) {
    delete _impl_.center_;
  }
  _impl_.center_ = nullptr;
}
inline const ::rtech::liveapi::Vector3& RingStartClosing::_internal_center() const {
  const ::rtech::liveapi::Vector3* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(
      ::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& RingStartClosing::center() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.center)
  return _internal_center();
}
inline void RingStartClosing::unsafe_arena_set_allocated_center(
    ::rtech::liveapi::Vector3* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = center;
  if (center) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RingStartClosing.center)
}
inline ::rtech::liveapi::Vector3* RingStartClosing::release_center() {
  
  ::rtech::liveapi::Vector3* temp = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Vector3* RingStartClosing::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingStartClosing.center)
  
  ::rtech::liveapi::Vector3* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* RingStartClosing::_internal_mutable_center() {
  
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArenaForAllocation());
    _impl_.center_ = p;
  }
  return _impl_.center_;
}
inline ::rtech::liveapi::Vector3* RingStartClosing::mutable_center() {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingStartClosing.center)
  return _msg;
}
inline void RingStartClosing::set_allocated_center(::rtech::liveapi::Vector3* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.center_ = center;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingStartClosing.center)
}

// float currentRadius = 5;
inline void RingStartClosing::clear_currentradius() {
  _impl_.currentradius_ = 0;
}
inline float RingStartClosing::_internal_currentradius() const {
  return _impl_.currentradius_;
}
inline float RingStartClosing::currentradius() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.currentRadius)
  return _internal_currentradius();
}
inline void RingStartClosing::_internal_set_currentradius(float value) {
  
  _impl_.currentradius_ = value;
}
inline void RingStartClosing::set_currentradius(float value) {
  _internal_set_currentradius(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.currentRadius)
}

// float endRadius = 6;
inline void RingStartClosing::clear_endradius() {
  _impl_.endradius_ = 0;
}
inline float RingStartClosing::_internal_endradius() const {
  return _impl_.endradius_;
}
inline float RingStartClosing::endradius() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.endRadius)
  return _internal_endradius();
}
inline void RingStartClosing::_internal_set_endradius(float value) {
  
  _impl_.endradius_ = value;
}
inline void RingStartClosing::set_endradius(float value) {
  _internal_set_endradius(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.endRadius)
}

// float shrinkDuration = 7;
inline void RingStartClosing::clear_shrinkduration() {
  _impl_.shrinkduration_ = 0;
}
inline float RingStartClosing::_internal_shrinkduration() const {
  return _impl_.shrinkduration_;
}
inline float RingStartClosing::shrinkduration() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingStartClosing.shrinkDuration)
  return _internal_shrinkduration();
}
inline void RingStartClosing::_internal_set_shrinkduration(float value) {
  
  _impl_.shrinkduration_ = value;
}
inline void RingStartClosing::set_shrinkduration(float value) {
  _internal_set_shrinkduration(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingStartClosing.shrinkDuration)
}

// -------------------------------------------------------------------

// RingFinishedClosing

// uint64 timestamp = 1;
inline void RingFinishedClosing::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t RingFinishedClosing::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t RingFinishedClosing::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.timestamp)
  return _internal_timestamp();
}
inline void RingFinishedClosing::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RingFinishedClosing::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.timestamp)
}

// string category = 2;
inline void RingFinishedClosing::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& RingFinishedClosing::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingFinishedClosing::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.category)
}
inline std::string* RingFinishedClosing::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingFinishedClosing.category)
  return _s;
}
inline const std::string& RingFinishedClosing::_internal_category() const {
  return _impl_.category_.Get();
}
inline void RingFinishedClosing::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* RingFinishedClosing::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* RingFinishedClosing::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingFinishedClosing.category)
  return _impl_.category_.Release();
}
inline void RingFinishedClosing::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingFinishedClosing.category)
}

// uint32 stage = 3;
inline void RingFinishedClosing::clear_stage() {
  _impl_.stage_ = 0u;
}
inline uint32_t RingFinishedClosing::_internal_stage() const {
  return _impl_.stage_;
}
inline uint32_t RingFinishedClosing::stage() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.stage)
  return _internal_stage();
}
inline void RingFinishedClosing::_internal_set_stage(uint32_t value) {
  
  _impl_.stage_ = value;
}
inline void RingFinishedClosing::set_stage(uint32_t value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.stage)
}

// .rtech.liveapi.Vector3 center = 4;
inline bool RingFinishedClosing::_internal_has_center() const {
  return this != internal_default_instance() && _impl_.center_ != nullptr;
}
inline bool RingFinishedClosing::has_center() const {
  return _internal_has_center();
}
inline void RingFinishedClosing::clear_center() {
  if (GetArenaForAllocation() == nullptr && _impl_.center_ != nullptr) {
    delete _impl_.center_;
  }
  _impl_.center_ = nullptr;
}
inline const ::rtech::liveapi::Vector3& RingFinishedClosing::_internal_center() const {
  const ::rtech::liveapi::Vector3* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Vector3&>(
      ::rtech::liveapi::_Vector3_default_instance_);
}
inline const ::rtech::liveapi::Vector3& RingFinishedClosing::center() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.center)
  return _internal_center();
}
inline void RingFinishedClosing::unsafe_arena_set_allocated_center(
    ::rtech::liveapi::Vector3* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = center;
  if (center) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RingFinishedClosing.center)
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::release_center() {
  
  ::rtech::liveapi::Vector3* temp = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RingFinishedClosing.center)
  
  ::rtech::liveapi::Vector3* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::_internal_mutable_center() {
  
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Vector3>(GetArenaForAllocation());
    _impl_.center_ = p;
  }
  return _impl_.center_;
}
inline ::rtech::liveapi::Vector3* RingFinishedClosing::mutable_center() {
  ::rtech::liveapi::Vector3* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RingFinishedClosing.center)
  return _msg;
}
inline void RingFinishedClosing::set_allocated_center(::rtech::liveapi::Vector3* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.center_ = center;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RingFinishedClosing.center)
}

// float currentRadius = 5;
inline void RingFinishedClosing::clear_currentradius() {
  _impl_.currentradius_ = 0;
}
inline float RingFinishedClosing::_internal_currentradius() const {
  return _impl_.currentradius_;
}
inline float RingFinishedClosing::currentradius() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.currentRadius)
  return _internal_currentradius();
}
inline void RingFinishedClosing::_internal_set_currentradius(float value) {
  
  _impl_.currentradius_ = value;
}
inline void RingFinishedClosing::set_currentradius(float value) {
  _internal_set_currentradius(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.currentRadius)
}

// float shrinkDuration = 7;
inline void RingFinishedClosing::clear_shrinkduration() {
  _impl_.shrinkduration_ = 0;
}
inline float RingFinishedClosing::_internal_shrinkduration() const {
  return _impl_.shrinkduration_;
}
inline float RingFinishedClosing::shrinkduration() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RingFinishedClosing.shrinkDuration)
  return _internal_shrinkduration();
}
inline void RingFinishedClosing::_internal_set_shrinkduration(float value) {
  
  _impl_.shrinkduration_ = value;
}
inline void RingFinishedClosing::set_shrinkduration(float value) {
  _internal_set_shrinkduration(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RingFinishedClosing.shrinkDuration)
}

// -------------------------------------------------------------------

// PlayerConnected

// uint64 timestamp = 1;
inline void PlayerConnected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerConnected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerConnected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerConnected.timestamp)
  return _internal_timestamp();
}
inline void PlayerConnected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerConnected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerConnected.timestamp)
}

// string category = 2;
inline void PlayerConnected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerConnected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerConnected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerConnected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerConnected.category)
}
inline std::string* PlayerConnected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerConnected.category)
  return _s;
}
inline const std::string& PlayerConnected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerConnected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerConnected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerConnected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerConnected.category)
  return _impl_.category_.Release();
}
inline void PlayerConnected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerConnected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerConnected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerConnected::has_player() const {
  return _internal_has_player();
}
inline void PlayerConnected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerConnected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerConnected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerConnected.player)
  return _internal_player();
}
inline void PlayerConnected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerConnected.player)
}
inline ::rtech::liveapi::Player* PlayerConnected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerConnected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerConnected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerConnected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerConnected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerConnected.player)
  return _msg;
}
inline void PlayerConnected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerConnected.player)
}

// -------------------------------------------------------------------

// PlayerDisconnected

// uint64 timestamp = 1;
inline void PlayerDisconnected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerDisconnected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerDisconnected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.timestamp)
  return _internal_timestamp();
}
inline void PlayerDisconnected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerDisconnected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.timestamp)
}

// string category = 2;
inline void PlayerDisconnected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerDisconnected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDisconnected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.category)
}
inline std::string* PlayerDisconnected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDisconnected.category)
  return _s;
}
inline const std::string& PlayerDisconnected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerDisconnected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDisconnected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDisconnected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDisconnected.category)
  return _impl_.category_.Release();
}
inline void PlayerDisconnected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDisconnected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerDisconnected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerDisconnected::has_player() const {
  return _internal_has_player();
}
inline void PlayerDisconnected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerDisconnected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDisconnected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.player)
  return _internal_player();
}
inline void PlayerDisconnected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDisconnected.player)
}
inline ::rtech::liveapi::Player* PlayerDisconnected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDisconnected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDisconnected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDisconnected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerDisconnected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDisconnected.player)
  return _msg;
}
inline void PlayerDisconnected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDisconnected.player)
}

// bool canReconnect = 4;
inline void PlayerDisconnected::clear_canreconnect() {
  _impl_.canreconnect_ = false;
}
inline bool PlayerDisconnected::_internal_canreconnect() const {
  return _impl_.canreconnect_;
}
inline bool PlayerDisconnected::canreconnect() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.canReconnect)
  return _internal_canreconnect();
}
inline void PlayerDisconnected::_internal_set_canreconnect(bool value) {
  
  _impl_.canreconnect_ = value;
}
inline void PlayerDisconnected::set_canreconnect(bool value) {
  _internal_set_canreconnect(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.canReconnect)
}

// bool isAlive = 5;
inline void PlayerDisconnected::clear_isalive() {
  _impl_.isalive_ = false;
}
inline bool PlayerDisconnected::_internal_isalive() const {
  return _impl_.isalive_;
}
inline bool PlayerDisconnected::isalive() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDisconnected.isAlive)
  return _internal_isalive();
}
inline void PlayerDisconnected::_internal_set_isalive(bool value) {
  
  _impl_.isalive_ = value;
}
inline void PlayerDisconnected::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDisconnected.isAlive)
}

// -------------------------------------------------------------------

// PlayerStatChanged

// uint64 timestamp = 1;
inline void PlayerStatChanged::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerStatChanged::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerStatChanged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.timestamp)
  return _internal_timestamp();
}
inline void PlayerStatChanged::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerStatChanged::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.timestamp)
}

// string category = 2;
inline void PlayerStatChanged::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerStatChanged::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerStatChanged::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.category)
}
inline std::string* PlayerStatChanged::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerStatChanged.category)
  return _s;
}
inline const std::string& PlayerStatChanged::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerStatChanged::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerStatChanged::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerStatChanged::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerStatChanged.category)
  return _impl_.category_.Release();
}
inline void PlayerStatChanged::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerStatChanged.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerStatChanged::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerStatChanged::has_player() const {
  return _internal_has_player();
}
inline void PlayerStatChanged::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerStatChanged::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerStatChanged::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.player)
  return _internal_player();
}
inline void PlayerStatChanged::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerStatChanged.player)
}
inline ::rtech::liveapi::Player* PlayerStatChanged::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerStatChanged::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerStatChanged.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerStatChanged::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerStatChanged::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerStatChanged.player)
  return _msg;
}
inline void PlayerStatChanged::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerStatChanged.player)
}

// string statName = 4;
inline void PlayerStatChanged::clear_statname() {
  _impl_.statname_.ClearToEmpty();
}
inline const std::string& PlayerStatChanged::statname() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.statName)
  return _internal_statname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerStatChanged::set_statname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.statname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.statName)
}
inline std::string* PlayerStatChanged::mutable_statname() {
  std::string* _s = _internal_mutable_statname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerStatChanged.statName)
  return _s;
}
inline const std::string& PlayerStatChanged::_internal_statname() const {
  return _impl_.statname_.Get();
}
inline void PlayerStatChanged::_internal_set_statname(const std::string& value) {
  
  _impl_.statname_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerStatChanged::_internal_mutable_statname() {
  
  return _impl_.statname_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerStatChanged::release_statname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerStatChanged.statName)
  return _impl_.statname_.Release();
}
inline void PlayerStatChanged::set_allocated_statname(std::string* statname) {
  if (statname != nullptr) {
    
  } else {
    
  }
  _impl_.statname_.SetAllocated(statname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.statname_.IsDefault()) {
    _impl_.statname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerStatChanged.statName)
}

// uint32 intValue = 5;
inline bool PlayerStatChanged::_internal_has_intvalue() const {
  return newValue_case() == kIntValue;
}
inline bool PlayerStatChanged::has_intvalue() const {
  return _internal_has_intvalue();
}
inline void PlayerStatChanged::set_has_intvalue() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void PlayerStatChanged::clear_intvalue() {
  if (_internal_has_intvalue()) {
    _impl_.newValue_.intvalue_ = 0u;
    clear_has_newValue();
  }
}
inline uint32_t PlayerStatChanged::_internal_intvalue() const {
  if (_internal_has_intvalue()) {
    return _impl_.newValue_.intvalue_;
  }
  return 0u;
}
inline void PlayerStatChanged::_internal_set_intvalue(uint32_t value) {
  if (!_internal_has_intvalue()) {
    clear_newValue();
    set_has_intvalue();
  }
  _impl_.newValue_.intvalue_ = value;
}
inline uint32_t PlayerStatChanged::intvalue() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.intValue)
  return _internal_intvalue();
}
inline void PlayerStatChanged::set_intvalue(uint32_t value) {
  _internal_set_intvalue(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.intValue)
}

// float floatValue = 6;
inline bool PlayerStatChanged::_internal_has_floatvalue() const {
  return newValue_case() == kFloatValue;
}
inline bool PlayerStatChanged::has_floatvalue() const {
  return _internal_has_floatvalue();
}
inline void PlayerStatChanged::set_has_floatvalue() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void PlayerStatChanged::clear_floatvalue() {
  if (_internal_has_floatvalue()) {
    _impl_.newValue_.floatvalue_ = 0;
    clear_has_newValue();
  }
}
inline float PlayerStatChanged::_internal_floatvalue() const {
  if (_internal_has_floatvalue()) {
    return _impl_.newValue_.floatvalue_;
  }
  return 0;
}
inline void PlayerStatChanged::_internal_set_floatvalue(float value) {
  if (!_internal_has_floatvalue()) {
    clear_newValue();
    set_has_floatvalue();
  }
  _impl_.newValue_.floatvalue_ = value;
}
inline float PlayerStatChanged::floatvalue() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.floatValue)
  return _internal_floatvalue();
}
inline void PlayerStatChanged::set_floatvalue(float value) {
  _internal_set_floatvalue(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.floatValue)
}

// bool boolValue = 7;
inline bool PlayerStatChanged::_internal_has_boolvalue() const {
  return newValue_case() == kBoolValue;
}
inline bool PlayerStatChanged::has_boolvalue() const {
  return _internal_has_boolvalue();
}
inline void PlayerStatChanged::set_has_boolvalue() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void PlayerStatChanged::clear_boolvalue() {
  if (_internal_has_boolvalue()) {
    _impl_.newValue_.boolvalue_ = false;
    clear_has_newValue();
  }
}
inline bool PlayerStatChanged::_internal_boolvalue() const {
  if (_internal_has_boolvalue()) {
    return _impl_.newValue_.boolvalue_;
  }
  return false;
}
inline void PlayerStatChanged::_internal_set_boolvalue(bool value) {
  if (!_internal_has_boolvalue()) {
    clear_newValue();
    set_has_boolvalue();
  }
  _impl_.newValue_.boolvalue_ = value;
}
inline bool PlayerStatChanged::boolvalue() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerStatChanged.boolValue)
  return _internal_boolvalue();
}
inline void PlayerStatChanged::set_boolvalue(bool value) {
  _internal_set_boolvalue(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerStatChanged.boolValue)
}

inline bool PlayerStatChanged::has_newValue() const {
  return newValue_case() != NEWVALUE_NOT_SET;
}
inline void PlayerStatChanged::clear_has_newValue() {
  _impl_._oneof_case_[0] = NEWVALUE_NOT_SET;
}
inline PlayerStatChanged::NewValueCase PlayerStatChanged::newValue_case() const {
  return PlayerStatChanged::NewValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerUpgradeTierChanged

// uint64 timestamp = 1;
inline void PlayerUpgradeTierChanged::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerUpgradeTierChanged::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerUpgradeTierChanged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.timestamp)
  return _internal_timestamp();
}
inline void PlayerUpgradeTierChanged::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerUpgradeTierChanged::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerUpgradeTierChanged.timestamp)
}

// string category = 2;
inline void PlayerUpgradeTierChanged::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerUpgradeTierChanged::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerUpgradeTierChanged::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerUpgradeTierChanged.category)
}
inline std::string* PlayerUpgradeTierChanged::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerUpgradeTierChanged.category)
  return _s;
}
inline const std::string& PlayerUpgradeTierChanged::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerUpgradeTierChanged::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerUpgradeTierChanged::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerUpgradeTierChanged::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerUpgradeTierChanged.category)
  return _impl_.category_.Release();
}
inline void PlayerUpgradeTierChanged::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerUpgradeTierChanged.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerUpgradeTierChanged::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerUpgradeTierChanged::has_player() const {
  return _internal_has_player();
}
inline void PlayerUpgradeTierChanged::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerUpgradeTierChanged::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerUpgradeTierChanged::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.player)
  return _internal_player();
}
inline void PlayerUpgradeTierChanged::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerUpgradeTierChanged.player)
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerUpgradeTierChanged.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerUpgradeTierChanged::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerUpgradeTierChanged.player)
  return _msg;
}
inline void PlayerUpgradeTierChanged::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerUpgradeTierChanged.player)
}

// int32 level = 4;
inline void PlayerUpgradeTierChanged::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t PlayerUpgradeTierChanged::_internal_level() const {
  return _impl_.level_;
}
inline int32_t PlayerUpgradeTierChanged::level() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerUpgradeTierChanged.level)
  return _internal_level();
}
inline void PlayerUpgradeTierChanged::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void PlayerUpgradeTierChanged::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerUpgradeTierChanged.level)
}

// -------------------------------------------------------------------

// PlayerDamaged

// uint64 timestamp = 1;
inline void PlayerDamaged::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerDamaged::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerDamaged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.timestamp)
  return _internal_timestamp();
}
inline void PlayerDamaged::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerDamaged::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.timestamp)
}

// string category = 2;
inline void PlayerDamaged::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerDamaged::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDamaged::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.category)
}
inline std::string* PlayerDamaged::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.category)
  return _s;
}
inline const std::string& PlayerDamaged::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerDamaged::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDamaged::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDamaged::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.category)
  return _impl_.category_.Release();
}
inline void PlayerDamaged::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool PlayerDamaged::_internal_has_attacker() const {
  return this != internal_default_instance() && _impl_.attacker_ != nullptr;
}
inline bool PlayerDamaged::has_attacker() const {
  return _internal_has_attacker();
}
inline void PlayerDamaged::clear_attacker() {
  if (GetArenaForAllocation() == nullptr && _impl_.attacker_ != nullptr) {
    delete _impl_.attacker_;
  }
  _impl_.attacker_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerDamaged::_internal_attacker() const {
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDamaged::attacker() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.attacker)
  return _internal_attacker();
}
inline void PlayerDamaged::unsafe_arena_set_allocated_attacker(
    ::rtech::liveapi::Player* attacker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = attacker;
  if (attacker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDamaged.attacker)
}
inline ::rtech::liveapi::Player* PlayerDamaged::release_attacker() {
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDamaged::unsafe_arena_release_attacker() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.attacker)
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDamaged::_internal_mutable_attacker() {
  
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.attacker_ = p;
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* PlayerDamaged::mutable_attacker() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.attacker)
  return _msg;
}
inline void PlayerDamaged::set_allocated_attacker(::rtech::liveapi::Player* attacker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attacker_;
  }
  if (attacker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attacker);
    if (message_arena != submessage_arena) {
      attacker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attacker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attacker_ = attacker;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerDamaged::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool PlayerDamaged::has_victim() const {
  return _internal_has_victim();
}
inline void PlayerDamaged::clear_victim() {
  if (GetArenaForAllocation() == nullptr && _impl_.victim_ != nullptr) {
    delete _impl_.victim_;
  }
  _impl_.victim_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerDamaged::_internal_victim() const {
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDamaged::victim() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.victim)
  return _internal_victim();
}
inline void PlayerDamaged::unsafe_arena_set_allocated_victim(
    ::rtech::liveapi::Player* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDamaged.victim)
}
inline ::rtech::liveapi::Player* PlayerDamaged::release_victim() {
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDamaged::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.victim)
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDamaged::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerDamaged::mutable_victim() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.victim)
  return _msg;
}
inline void PlayerDamaged::set_allocated_victim(::rtech::liveapi::Player* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.victim_;
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(victim);
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.victim)
}

// string weapon = 5;
inline void PlayerDamaged::clear_weapon() {
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerDamaged::weapon() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.weapon)
  return _internal_weapon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDamaged::set_weapon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.weapon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.weapon)
}
inline std::string* PlayerDamaged::mutable_weapon() {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDamaged.weapon)
  return _s;
}
inline const std::string& PlayerDamaged::_internal_weapon() const {
  return _impl_.weapon_.Get();
}
inline void PlayerDamaged::_internal_set_weapon(const std::string& value) {
  
  _impl_.weapon_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDamaged::_internal_mutable_weapon() {
  
  return _impl_.weapon_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDamaged::release_weapon() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDamaged.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerDamaged::set_allocated_weapon(std::string* weapon) {
  if (weapon != nullptr) {
    
  } else {
    
  }
  _impl_.weapon_.SetAllocated(weapon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weapon_.IsDefault()) {
    _impl_.weapon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDamaged.weapon)
}

// uint32 damageInflicted = 6;
inline void PlayerDamaged::clear_damageinflicted() {
  _impl_.damageinflicted_ = 0u;
}
inline uint32_t PlayerDamaged::_internal_damageinflicted() const {
  return _impl_.damageinflicted_;
}
inline uint32_t PlayerDamaged::damageinflicted() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDamaged.damageInflicted)
  return _internal_damageinflicted();
}
inline void PlayerDamaged::_internal_set_damageinflicted(uint32_t value) {
  
  _impl_.damageinflicted_ = value;
}
inline void PlayerDamaged::set_damageinflicted(uint32_t value) {
  _internal_set_damageinflicted(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDamaged.damageInflicted)
}

// -------------------------------------------------------------------

// PlayerKilled

// uint64 timestamp = 1;
inline void PlayerKilled::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerKilled::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerKilled::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.timestamp)
  return _internal_timestamp();
}
inline void PlayerKilled::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerKilled::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerKilled.timestamp)
}

// string category = 2;
inline void PlayerKilled::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerKilled::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerKilled::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerKilled.category)
}
inline std::string* PlayerKilled::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.category)
  return _s;
}
inline const std::string& PlayerKilled::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerKilled::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerKilled::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerKilled::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.category)
  return _impl_.category_.Release();
}
inline void PlayerKilled::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool PlayerKilled::_internal_has_attacker() const {
  return this != internal_default_instance() && _impl_.attacker_ != nullptr;
}
inline bool PlayerKilled::has_attacker() const {
  return _internal_has_attacker();
}
inline void PlayerKilled::clear_attacker() {
  if (GetArenaForAllocation() == nullptr && _impl_.attacker_ != nullptr) {
    delete _impl_.attacker_;
  }
  _impl_.attacker_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerKilled::_internal_attacker() const {
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerKilled::attacker() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.attacker)
  return _internal_attacker();
}
inline void PlayerKilled::unsafe_arena_set_allocated_attacker(
    ::rtech::liveapi::Player* attacker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = attacker;
  if (attacker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerKilled.attacker)
}
inline ::rtech::liveapi::Player* PlayerKilled::release_attacker() {
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::unsafe_arena_release_attacker() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.attacker)
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::_internal_mutable_attacker() {
  
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.attacker_ = p;
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* PlayerKilled::mutable_attacker() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.attacker)
  return _msg;
}
inline void PlayerKilled::set_allocated_attacker(::rtech::liveapi::Player* attacker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attacker_;
  }
  if (attacker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attacker);
    if (message_arena != submessage_arena) {
      attacker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attacker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attacker_ = attacker;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerKilled::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool PlayerKilled::has_victim() const {
  return _internal_has_victim();
}
inline void PlayerKilled::clear_victim() {
  if (GetArenaForAllocation() == nullptr && _impl_.victim_ != nullptr) {
    delete _impl_.victim_;
  }
  _impl_.victim_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerKilled::_internal_victim() const {
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerKilled::victim() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.victim)
  return _internal_victim();
}
inline void PlayerKilled::unsafe_arena_set_allocated_victim(
    ::rtech::liveapi::Player* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerKilled.victim)
}
inline ::rtech::liveapi::Player* PlayerKilled::release_victim() {
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.victim)
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerKilled::mutable_victim() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.victim)
  return _msg;
}
inline void PlayerKilled::set_allocated_victim(::rtech::liveapi::Player* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.victim_;
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(victim);
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.victim)
}

// .rtech.liveapi.Player awardedTo = 5;
inline bool PlayerKilled::_internal_has_awardedto() const {
  return this != internal_default_instance() && _impl_.awardedto_ != nullptr;
}
inline bool PlayerKilled::has_awardedto() const {
  return _internal_has_awardedto();
}
inline void PlayerKilled::clear_awardedto() {
  if (GetArenaForAllocation() == nullptr && _impl_.awardedto_ != nullptr) {
    delete _impl_.awardedto_;
  }
  _impl_.awardedto_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerKilled::_internal_awardedto() const {
  const ::rtech::liveapi::Player* p = _impl_.awardedto_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerKilled::awardedto() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.awardedTo)
  return _internal_awardedto();
}
inline void PlayerKilled::unsafe_arena_set_allocated_awardedto(
    ::rtech::liveapi::Player* awardedto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.awardedto_);
  }
  _impl_.awardedto_ = awardedto;
  if (awardedto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerKilled.awardedTo)
}
inline ::rtech::liveapi::Player* PlayerKilled::release_awardedto() {
  
  ::rtech::liveapi::Player* temp = _impl_.awardedto_;
  _impl_.awardedto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::unsafe_arena_release_awardedto() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.awardedTo)
  
  ::rtech::liveapi::Player* temp = _impl_.awardedto_;
  _impl_.awardedto_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerKilled::_internal_mutable_awardedto() {
  
  if (_impl_.awardedto_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.awardedto_ = p;
  }
  return _impl_.awardedto_;
}
inline ::rtech::liveapi::Player* PlayerKilled::mutable_awardedto() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_awardedto();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.awardedTo)
  return _msg;
}
inline void PlayerKilled::set_allocated_awardedto(::rtech::liveapi::Player* awardedto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.awardedto_;
  }
  if (awardedto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(awardedto);
    if (message_arena != submessage_arena) {
      awardedto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, awardedto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.awardedto_ = awardedto;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.awardedTo)
}

// string weapon = 6;
inline void PlayerKilled::clear_weapon() {
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerKilled::weapon() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerKilled.weapon)
  return _internal_weapon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerKilled::set_weapon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.weapon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerKilled.weapon)
}
inline std::string* PlayerKilled::mutable_weapon() {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerKilled.weapon)
  return _s;
}
inline const std::string& PlayerKilled::_internal_weapon() const {
  return _impl_.weapon_.Get();
}
inline void PlayerKilled::_internal_set_weapon(const std::string& value) {
  
  _impl_.weapon_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerKilled::_internal_mutable_weapon() {
  
  return _impl_.weapon_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerKilled::release_weapon() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerKilled.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerKilled::set_allocated_weapon(std::string* weapon) {
  if (weapon != nullptr) {
    
  } else {
    
  }
  _impl_.weapon_.SetAllocated(weapon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weapon_.IsDefault()) {
    _impl_.weapon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerKilled.weapon)
}

// -------------------------------------------------------------------

// PlayerDowned

// uint64 timestamp = 1;
inline void PlayerDowned::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerDowned::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerDowned::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.timestamp)
  return _internal_timestamp();
}
inline void PlayerDowned::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerDowned::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDowned.timestamp)
}

// string category = 2;
inline void PlayerDowned::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerDowned::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDowned::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDowned.category)
}
inline std::string* PlayerDowned::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.category)
  return _s;
}
inline const std::string& PlayerDowned::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerDowned::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDowned::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDowned::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.category)
  return _impl_.category_.Release();
}
inline void PlayerDowned::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool PlayerDowned::_internal_has_attacker() const {
  return this != internal_default_instance() && _impl_.attacker_ != nullptr;
}
inline bool PlayerDowned::has_attacker() const {
  return _internal_has_attacker();
}
inline void PlayerDowned::clear_attacker() {
  if (GetArenaForAllocation() == nullptr && _impl_.attacker_ != nullptr) {
    delete _impl_.attacker_;
  }
  _impl_.attacker_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerDowned::_internal_attacker() const {
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDowned::attacker() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.attacker)
  return _internal_attacker();
}
inline void PlayerDowned::unsafe_arena_set_allocated_attacker(
    ::rtech::liveapi::Player* attacker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = attacker;
  if (attacker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDowned.attacker)
}
inline ::rtech::liveapi::Player* PlayerDowned::release_attacker() {
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDowned::unsafe_arena_release_attacker() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.attacker)
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDowned::_internal_mutable_attacker() {
  
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.attacker_ = p;
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* PlayerDowned::mutable_attacker() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.attacker)
  return _msg;
}
inline void PlayerDowned::set_allocated_attacker(::rtech::liveapi::Player* attacker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attacker_;
  }
  if (attacker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attacker);
    if (message_arena != submessage_arena) {
      attacker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attacker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attacker_ = attacker;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerDowned::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool PlayerDowned::has_victim() const {
  return _internal_has_victim();
}
inline void PlayerDowned::clear_victim() {
  if (GetArenaForAllocation() == nullptr && _impl_.victim_ != nullptr) {
    delete _impl_.victim_;
  }
  _impl_.victim_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerDowned::_internal_victim() const {
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerDowned::victim() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.victim)
  return _internal_victim();
}
inline void PlayerDowned::unsafe_arena_set_allocated_victim(
    ::rtech::liveapi::Player* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerDowned.victim)
}
inline ::rtech::liveapi::Player* PlayerDowned::release_victim() {
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDowned::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.victim)
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerDowned::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerDowned::mutable_victim() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.victim)
  return _msg;
}
inline void PlayerDowned::set_allocated_victim(::rtech::liveapi::Player* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.victim_;
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(victim);
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.victim)
}

// string weapon = 5;
inline void PlayerDowned::clear_weapon() {
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerDowned::weapon() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerDowned.weapon)
  return _internal_weapon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerDowned::set_weapon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.weapon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerDowned.weapon)
}
inline std::string* PlayerDowned::mutable_weapon() {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerDowned.weapon)
  return _s;
}
inline const std::string& PlayerDowned::_internal_weapon() const {
  return _impl_.weapon_.Get();
}
inline void PlayerDowned::_internal_set_weapon(const std::string& value) {
  
  _impl_.weapon_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerDowned::_internal_mutable_weapon() {
  
  return _impl_.weapon_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerDowned::release_weapon() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerDowned.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerDowned::set_allocated_weapon(std::string* weapon) {
  if (weapon != nullptr) {
    
  } else {
    
  }
  _impl_.weapon_.SetAllocated(weapon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weapon_.IsDefault()) {
    _impl_.weapon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerDowned.weapon)
}

// -------------------------------------------------------------------

// PlayerAssist

// uint64 timestamp = 1;
inline void PlayerAssist::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerAssist::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerAssist::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.timestamp)
  return _internal_timestamp();
}
inline void PlayerAssist::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerAssist::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAssist.timestamp)
}

// string category = 2;
inline void PlayerAssist::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerAssist::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerAssist::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAssist.category)
}
inline std::string* PlayerAssist::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.category)
  return _s;
}
inline const std::string& PlayerAssist::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerAssist::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerAssist::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerAssist::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.category)
  return _impl_.category_.Release();
}
inline void PlayerAssist::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.category)
}

// .rtech.liveapi.Player assistant = 3;
inline bool PlayerAssist::_internal_has_assistant() const {
  return this != internal_default_instance() && _impl_.assistant_ != nullptr;
}
inline bool PlayerAssist::has_assistant() const {
  return _internal_has_assistant();
}
inline void PlayerAssist::clear_assistant() {
  if (GetArenaForAllocation() == nullptr && _impl_.assistant_ != nullptr) {
    delete _impl_.assistant_;
  }
  _impl_.assistant_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerAssist::_internal_assistant() const {
  const ::rtech::liveapi::Player* p = _impl_.assistant_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerAssist::assistant() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.assistant)
  return _internal_assistant();
}
inline void PlayerAssist::unsafe_arena_set_allocated_assistant(
    ::rtech::liveapi::Player* assistant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assistant_);
  }
  _impl_.assistant_ = assistant;
  if (assistant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerAssist.assistant)
}
inline ::rtech::liveapi::Player* PlayerAssist::release_assistant() {
  
  ::rtech::liveapi::Player* temp = _impl_.assistant_;
  _impl_.assistant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAssist::unsafe_arena_release_assistant() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.assistant)
  
  ::rtech::liveapi::Player* temp = _impl_.assistant_;
  _impl_.assistant_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAssist::_internal_mutable_assistant() {
  
  if (_impl_.assistant_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.assistant_ = p;
  }
  return _impl_.assistant_;
}
inline ::rtech::liveapi::Player* PlayerAssist::mutable_assistant() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_assistant();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.assistant)
  return _msg;
}
inline void PlayerAssist::set_allocated_assistant(::rtech::liveapi::Player* assistant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.assistant_;
  }
  if (assistant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(assistant);
    if (message_arena != submessage_arena) {
      assistant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assistant, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.assistant_ = assistant;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.assistant)
}

// .rtech.liveapi.Player victim = 4;
inline bool PlayerAssist::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool PlayerAssist::has_victim() const {
  return _internal_has_victim();
}
inline void PlayerAssist::clear_victim() {
  if (GetArenaForAllocation() == nullptr && _impl_.victim_ != nullptr) {
    delete _impl_.victim_;
  }
  _impl_.victim_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerAssist::_internal_victim() const {
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerAssist::victim() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.victim)
  return _internal_victim();
}
inline void PlayerAssist::unsafe_arena_set_allocated_victim(
    ::rtech::liveapi::Player* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerAssist.victim)
}
inline ::rtech::liveapi::Player* PlayerAssist::release_victim() {
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAssist::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.victim)
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAssist::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* PlayerAssist::mutable_victim() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.victim)
  return _msg;
}
inline void PlayerAssist::set_allocated_victim(::rtech::liveapi::Player* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.victim_;
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(victim);
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.victim)
}

// string weapon = 5;
inline void PlayerAssist::clear_weapon() {
  _impl_.weapon_.ClearToEmpty();
}
inline const std::string& PlayerAssist::weapon() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAssist.weapon)
  return _internal_weapon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerAssist::set_weapon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.weapon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAssist.weapon)
}
inline std::string* PlayerAssist::mutable_weapon() {
  std::string* _s = _internal_mutable_weapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAssist.weapon)
  return _s;
}
inline const std::string& PlayerAssist::_internal_weapon() const {
  return _impl_.weapon_.Get();
}
inline void PlayerAssist::_internal_set_weapon(const std::string& value) {
  
  _impl_.weapon_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerAssist::_internal_mutable_weapon() {
  
  return _impl_.weapon_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerAssist::release_weapon() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAssist.weapon)
  return _impl_.weapon_.Release();
}
inline void PlayerAssist::set_allocated_weapon(std::string* weapon) {
  if (weapon != nullptr) {
    
  } else {
    
  }
  _impl_.weapon_.SetAllocated(weapon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.weapon_.IsDefault()) {
    _impl_.weapon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAssist.weapon)
}

// -------------------------------------------------------------------

// SquadEliminated

// uint64 timestamp = 1;
inline void SquadEliminated::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t SquadEliminated::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t SquadEliminated::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.SquadEliminated.timestamp)
  return _internal_timestamp();
}
inline void SquadEliminated::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void SquadEliminated::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.SquadEliminated.timestamp)
}

// string category = 2;
inline void SquadEliminated::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& SquadEliminated::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.SquadEliminated.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SquadEliminated::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.SquadEliminated.category)
}
inline std::string* SquadEliminated::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.SquadEliminated.category)
  return _s;
}
inline const std::string& SquadEliminated::_internal_category() const {
  return _impl_.category_.Get();
}
inline void SquadEliminated::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* SquadEliminated::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* SquadEliminated::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.SquadEliminated.category)
  return _impl_.category_.Release();
}
inline void SquadEliminated::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.SquadEliminated.category)
}

// repeated .rtech.liveapi.Player players = 3;
inline int SquadEliminated::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int SquadEliminated::players_size() const {
  return _internal_players_size();
}
inline void SquadEliminated::clear_players() {
  _impl_.players_.Clear();
}
inline ::rtech::liveapi::Player* SquadEliminated::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.SquadEliminated.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
SquadEliminated::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.SquadEliminated.players)
  return &_impl_.players_;
}
inline const ::rtech::liveapi::Player& SquadEliminated::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::rtech::liveapi::Player& SquadEliminated::players(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.SquadEliminated.players)
  return _internal_players(index);
}
inline ::rtech::liveapi::Player* SquadEliminated::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::rtech::liveapi::Player* SquadEliminated::add_players() {
  ::rtech::liveapi::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:rtech.liveapi.SquadEliminated.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
SquadEliminated::players() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.SquadEliminated.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// GibraltarShieldAbsorbed

// uint64 timestamp = 1;
inline void GibraltarShieldAbsorbed::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t GibraltarShieldAbsorbed::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t GibraltarShieldAbsorbed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.timestamp)
  return _internal_timestamp();
}
inline void GibraltarShieldAbsorbed::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void GibraltarShieldAbsorbed::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GibraltarShieldAbsorbed.timestamp)
}

// string category = 2;
inline void GibraltarShieldAbsorbed::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& GibraltarShieldAbsorbed::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GibraltarShieldAbsorbed::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GibraltarShieldAbsorbed.category)
}
inline std::string* GibraltarShieldAbsorbed::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GibraltarShieldAbsorbed.category)
  return _s;
}
inline const std::string& GibraltarShieldAbsorbed::_internal_category() const {
  return _impl_.category_.Get();
}
inline void GibraltarShieldAbsorbed::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* GibraltarShieldAbsorbed::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* GibraltarShieldAbsorbed::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GibraltarShieldAbsorbed.category)
  return _impl_.category_.Release();
}
inline void GibraltarShieldAbsorbed::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool GibraltarShieldAbsorbed::_internal_has_attacker() const {
  return this != internal_default_instance() && _impl_.attacker_ != nullptr;
}
inline bool GibraltarShieldAbsorbed::has_attacker() const {
  return _internal_has_attacker();
}
inline void GibraltarShieldAbsorbed::clear_attacker() {
  if (GetArenaForAllocation() == nullptr && _impl_.attacker_ != nullptr) {
    delete _impl_.attacker_;
  }
  _impl_.attacker_ = nullptr;
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::_internal_attacker() const {
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::attacker() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
  return _internal_attacker();
}
inline void GibraltarShieldAbsorbed::unsafe_arena_set_allocated_attacker(
    ::rtech::liveapi::Player* attacker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = attacker;
  if (attacker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::release_attacker() {
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::unsafe_arena_release_attacker() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::_internal_mutable_attacker() {
  
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.attacker_ = p;
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::mutable_attacker() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
  return _msg;
}
inline void GibraltarShieldAbsorbed::set_allocated_attacker(::rtech::liveapi::Player* attacker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attacker_;
  }
  if (attacker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attacker);
    if (message_arena != submessage_arena) {
      attacker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attacker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attacker_ = attacker;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool GibraltarShieldAbsorbed::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool GibraltarShieldAbsorbed::has_victim() const {
  return _internal_has_victim();
}
inline void GibraltarShieldAbsorbed::clear_victim() {
  if (GetArenaForAllocation() == nullptr && _impl_.victim_ != nullptr) {
    delete _impl_.victim_;
  }
  _impl_.victim_ = nullptr;
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::_internal_victim() const {
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& GibraltarShieldAbsorbed::victim() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.victim)
  return _internal_victim();
}
inline void GibraltarShieldAbsorbed::unsafe_arena_set_allocated_victim(
    ::rtech::liveapi::Player* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.victim)
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::release_victim() {
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GibraltarShieldAbsorbed.victim)
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* GibraltarShieldAbsorbed::mutable_victim() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GibraltarShieldAbsorbed.victim)
  return _msg;
}
inline void GibraltarShieldAbsorbed::set_allocated_victim(::rtech::liveapi::Player* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.victim_;
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(victim);
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GibraltarShieldAbsorbed.victim)
}

// uint32 damageInflicted = 6;
inline void GibraltarShieldAbsorbed::clear_damageinflicted() {
  _impl_.damageinflicted_ = 0u;
}
inline uint32_t GibraltarShieldAbsorbed::_internal_damageinflicted() const {
  return _impl_.damageinflicted_;
}
inline uint32_t GibraltarShieldAbsorbed::damageinflicted() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GibraltarShieldAbsorbed.damageInflicted)
  return _internal_damageinflicted();
}
inline void GibraltarShieldAbsorbed::_internal_set_damageinflicted(uint32_t value) {
  
  _impl_.damageinflicted_ = value;
}
inline void GibraltarShieldAbsorbed::set_damageinflicted(uint32_t value) {
  _internal_set_damageinflicted(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GibraltarShieldAbsorbed.damageInflicted)
}

// -------------------------------------------------------------------

// RevenantForgedShadowDamaged

// uint64 timestamp = 1;
inline void RevenantForgedShadowDamaged::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t RevenantForgedShadowDamaged::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t RevenantForgedShadowDamaged::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.timestamp)
  return _internal_timestamp();
}
inline void RevenantForgedShadowDamaged::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RevenantForgedShadowDamaged::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RevenantForgedShadowDamaged.timestamp)
}

// string category = 2;
inline void RevenantForgedShadowDamaged::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& RevenantForgedShadowDamaged::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RevenantForgedShadowDamaged::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RevenantForgedShadowDamaged.category)
}
inline std::string* RevenantForgedShadowDamaged::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RevenantForgedShadowDamaged.category)
  return _s;
}
inline const std::string& RevenantForgedShadowDamaged::_internal_category() const {
  return _impl_.category_.Get();
}
inline void RevenantForgedShadowDamaged::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* RevenantForgedShadowDamaged::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* RevenantForgedShadowDamaged::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RevenantForgedShadowDamaged.category)
  return _impl_.category_.Release();
}
inline void RevenantForgedShadowDamaged::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.category)
}

// .rtech.liveapi.Player attacker = 3;
inline bool RevenantForgedShadowDamaged::_internal_has_attacker() const {
  return this != internal_default_instance() && _impl_.attacker_ != nullptr;
}
inline bool RevenantForgedShadowDamaged::has_attacker() const {
  return _internal_has_attacker();
}
inline void RevenantForgedShadowDamaged::clear_attacker() {
  if (GetArenaForAllocation() == nullptr && _impl_.attacker_ != nullptr) {
    delete _impl_.attacker_;
  }
  _impl_.attacker_ = nullptr;
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::_internal_attacker() const {
  const ::rtech::liveapi::Player* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::attacker() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
  return _internal_attacker();
}
inline void RevenantForgedShadowDamaged::unsafe_arena_set_allocated_attacker(
    ::rtech::liveapi::Player* attacker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = attacker;
  if (attacker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::release_attacker() {
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::unsafe_arena_release_attacker() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
  
  ::rtech::liveapi::Player* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::_internal_mutable_attacker() {
  
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.attacker_ = p;
  }
  return _impl_.attacker_;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::mutable_attacker() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
  return _msg;
}
inline void RevenantForgedShadowDamaged::set_allocated_attacker(::rtech::liveapi::Player* attacker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attacker_;
  }
  if (attacker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attacker);
    if (message_arena != submessage_arena) {
      attacker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attacker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attacker_ = attacker;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.attacker)
}

// .rtech.liveapi.Player victim = 4;
inline bool RevenantForgedShadowDamaged::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool RevenantForgedShadowDamaged::has_victim() const {
  return _internal_has_victim();
}
inline void RevenantForgedShadowDamaged::clear_victim() {
  if (GetArenaForAllocation() == nullptr && _impl_.victim_ != nullptr) {
    delete _impl_.victim_;
  }
  _impl_.victim_ = nullptr;
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::_internal_victim() const {
  const ::rtech::liveapi::Player* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& RevenantForgedShadowDamaged::victim() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.victim)
  return _internal_victim();
}
inline void RevenantForgedShadowDamaged::unsafe_arena_set_allocated_victim(
    ::rtech::liveapi::Player* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.victim)
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::release_victim() {
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RevenantForgedShadowDamaged.victim)
  
  ::rtech::liveapi::Player* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::rtech::liveapi::Player* RevenantForgedShadowDamaged::mutable_victim() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RevenantForgedShadowDamaged.victim)
  return _msg;
}
inline void RevenantForgedShadowDamaged::set_allocated_victim(::rtech::liveapi::Player* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.victim_;
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(victim);
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RevenantForgedShadowDamaged.victim)
}

// uint32 damageInflicted = 6;
inline void RevenantForgedShadowDamaged::clear_damageinflicted() {
  _impl_.damageinflicted_ = 0u;
}
inline uint32_t RevenantForgedShadowDamaged::_internal_damageinflicted() const {
  return _impl_.damageinflicted_;
}
inline uint32_t RevenantForgedShadowDamaged::damageinflicted() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RevenantForgedShadowDamaged.damageInflicted)
  return _internal_damageinflicted();
}
inline void RevenantForgedShadowDamaged::_internal_set_damageinflicted(uint32_t value) {
  
  _impl_.damageinflicted_ = value;
}
inline void RevenantForgedShadowDamaged::set_damageinflicted(uint32_t value) {
  _internal_set_damageinflicted(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.RevenantForgedShadowDamaged.damageInflicted)
}

// -------------------------------------------------------------------

// PlayerRespawnTeam

// uint64 timestamp = 1;
inline void PlayerRespawnTeam::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerRespawnTeam::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerRespawnTeam::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.timestamp)
  return _internal_timestamp();
}
inline void PlayerRespawnTeam::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerRespawnTeam::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRespawnTeam.timestamp)
}

// string category = 2;
inline void PlayerRespawnTeam::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerRespawnTeam::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerRespawnTeam::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRespawnTeam.category)
}
inline std::string* PlayerRespawnTeam::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRespawnTeam.category)
  return _s;
}
inline const std::string& PlayerRespawnTeam::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerRespawnTeam::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerRespawnTeam::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerRespawnTeam::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRespawnTeam.category)
  return _impl_.category_.Release();
}
inline void PlayerRespawnTeam::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRespawnTeam.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerRespawnTeam::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerRespawnTeam::has_player() const {
  return _internal_has_player();
}
inline void PlayerRespawnTeam::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerRespawnTeam::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerRespawnTeam::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.player)
  return _internal_player();
}
inline void PlayerRespawnTeam::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerRespawnTeam.player)
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRespawnTeam.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRespawnTeam.player)
  return _msg;
}
inline void PlayerRespawnTeam::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRespawnTeam.player)
}

// repeated .rtech.liveapi.Player respawned = 4;
inline int PlayerRespawnTeam::_internal_respawned_size() const {
  return _impl_.respawned_.size();
}
inline int PlayerRespawnTeam::respawned_size() const {
  return _internal_respawned_size();
}
inline void PlayerRespawnTeam::clear_respawned() {
  _impl_.respawned_.Clear();
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::mutable_respawned(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _impl_.respawned_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >*
PlayerRespawnTeam::mutable_respawned() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.PlayerRespawnTeam.respawned)
  return &_impl_.respawned_;
}
inline const ::rtech::liveapi::Player& PlayerRespawnTeam::_internal_respawned(int index) const {
  return _impl_.respawned_.Get(index);
}
inline const ::rtech::liveapi::Player& PlayerRespawnTeam::respawned(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _internal_respawned(index);
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::_internal_add_respawned() {
  return _impl_.respawned_.Add();
}
inline ::rtech::liveapi::Player* PlayerRespawnTeam::add_respawned() {
  ::rtech::liveapi::Player* _add = _internal_add_respawned();
  // @@protoc_insertion_point(field_add:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rtech::liveapi::Player >&
PlayerRespawnTeam::respawned() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.PlayerRespawnTeam.respawned)
  return _impl_.respawned_;
}

// -------------------------------------------------------------------

// PlayerRevive

// uint64 timestamp = 1;
inline void PlayerRevive::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerRevive::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerRevive::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.timestamp)
  return _internal_timestamp();
}
inline void PlayerRevive::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerRevive::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRevive.timestamp)
}

// string category = 2;
inline void PlayerRevive::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerRevive::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerRevive::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerRevive.category)
}
inline std::string* PlayerRevive::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRevive.category)
  return _s;
}
inline const std::string& PlayerRevive::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerRevive::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerRevive::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerRevive::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRevive.category)
  return _impl_.category_.Release();
}
inline void PlayerRevive::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRevive.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerRevive::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerRevive::has_player() const {
  return _internal_has_player();
}
inline void PlayerRevive::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerRevive::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerRevive::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.player)
  return _internal_player();
}
inline void PlayerRevive::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerRevive.player)
}
inline ::rtech::liveapi::Player* PlayerRevive::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRevive::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRevive.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRevive::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerRevive::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRevive.player)
  return _msg;
}
inline void PlayerRevive::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRevive.player)
}

// .rtech.liveapi.Player revived = 4;
inline bool PlayerRevive::_internal_has_revived() const {
  return this != internal_default_instance() && _impl_.revived_ != nullptr;
}
inline bool PlayerRevive::has_revived() const {
  return _internal_has_revived();
}
inline void PlayerRevive::clear_revived() {
  if (GetArenaForAllocation() == nullptr && _impl_.revived_ != nullptr) {
    delete _impl_.revived_;
  }
  _impl_.revived_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerRevive::_internal_revived() const {
  const ::rtech::liveapi::Player* p = _impl_.revived_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerRevive::revived() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerRevive.revived)
  return _internal_revived();
}
inline void PlayerRevive::unsafe_arena_set_allocated_revived(
    ::rtech::liveapi::Player* revived) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.revived_);
  }
  _impl_.revived_ = revived;
  if (revived) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerRevive.revived)
}
inline ::rtech::liveapi::Player* PlayerRevive::release_revived() {
  
  ::rtech::liveapi::Player* temp = _impl_.revived_;
  _impl_.revived_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRevive::unsafe_arena_release_revived() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerRevive.revived)
  
  ::rtech::liveapi::Player* temp = _impl_.revived_;
  _impl_.revived_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerRevive::_internal_mutable_revived() {
  
  if (_impl_.revived_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.revived_ = p;
  }
  return _impl_.revived_;
}
inline ::rtech::liveapi::Player* PlayerRevive::mutable_revived() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_revived();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerRevive.revived)
  return _msg;
}
inline void PlayerRevive::set_allocated_revived(::rtech::liveapi::Player* revived) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.revived_;
  }
  if (revived) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(revived);
    if (message_arena != submessage_arena) {
      revived = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, revived, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.revived_ = revived;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerRevive.revived)
}

// -------------------------------------------------------------------

// ArenasItemSelected

// uint64 timestamp = 1;
inline void ArenasItemSelected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ArenasItemSelected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ArenasItemSelected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.timestamp)
  return _internal_timestamp();
}
inline void ArenasItemSelected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ArenasItemSelected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.timestamp)
}

// string category = 2;
inline void ArenasItemSelected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ArenasItemSelected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArenasItemSelected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.category)
}
inline std::string* ArenasItemSelected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemSelected.category)
  return _s;
}
inline const std::string& ArenasItemSelected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ArenasItemSelected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ArenasItemSelected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ArenasItemSelected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemSelected.category)
  return _impl_.category_.Release();
}
inline void ArenasItemSelected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemSelected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool ArenasItemSelected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool ArenasItemSelected::has_player() const {
  return _internal_has_player();
}
inline void ArenasItemSelected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& ArenasItemSelected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ArenasItemSelected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.player)
  return _internal_player();
}
inline void ArenasItemSelected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ArenasItemSelected.player)
}
inline ::rtech::liveapi::Player* ArenasItemSelected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* ArenasItemSelected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemSelected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ArenasItemSelected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* ArenasItemSelected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemSelected.player)
  return _msg;
}
inline void ArenasItemSelected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemSelected.player)
}

// string item = 4;
inline void ArenasItemSelected::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& ArenasItemSelected::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArenasItemSelected::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.item)
}
inline std::string* ArenasItemSelected::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemSelected.item)
  return _s;
}
inline const std::string& ArenasItemSelected::_internal_item() const {
  return _impl_.item_.Get();
}
inline void ArenasItemSelected::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* ArenasItemSelected::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* ArenasItemSelected::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemSelected.item)
  return _impl_.item_.Release();
}
inline void ArenasItemSelected::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemSelected.item)
}

// int32 quantity = 5;
inline void ArenasItemSelected::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t ArenasItemSelected::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t ArenasItemSelected::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemSelected.quantity)
  return _internal_quantity();
}
inline void ArenasItemSelected::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void ArenasItemSelected::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemSelected.quantity)
}

// -------------------------------------------------------------------

// ArenasItemDeselected

// uint64 timestamp = 1;
inline void ArenasItemDeselected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ArenasItemDeselected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ArenasItemDeselected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.timestamp)
  return _internal_timestamp();
}
inline void ArenasItemDeselected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ArenasItemDeselected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.timestamp)
}

// string category = 2;
inline void ArenasItemDeselected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ArenasItemDeselected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArenasItemDeselected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.category)
}
inline std::string* ArenasItemDeselected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemDeselected.category)
  return _s;
}
inline const std::string& ArenasItemDeselected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ArenasItemDeselected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ArenasItemDeselected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ArenasItemDeselected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemDeselected.category)
  return _impl_.category_.Release();
}
inline void ArenasItemDeselected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemDeselected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool ArenasItemDeselected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool ArenasItemDeselected::has_player() const {
  return _internal_has_player();
}
inline void ArenasItemDeselected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& ArenasItemDeselected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ArenasItemDeselected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.player)
  return _internal_player();
}
inline void ArenasItemDeselected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ArenasItemDeselected.player)
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemDeselected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* ArenasItemDeselected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemDeselected.player)
  return _msg;
}
inline void ArenasItemDeselected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemDeselected.player)
}

// string item = 4;
inline void ArenasItemDeselected::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& ArenasItemDeselected::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArenasItemDeselected::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.item)
}
inline std::string* ArenasItemDeselected::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ArenasItemDeselected.item)
  return _s;
}
inline const std::string& ArenasItemDeselected::_internal_item() const {
  return _impl_.item_.Get();
}
inline void ArenasItemDeselected::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* ArenasItemDeselected::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* ArenasItemDeselected::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ArenasItemDeselected.item)
  return _impl_.item_.Release();
}
inline void ArenasItemDeselected::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ArenasItemDeselected.item)
}

// int32 quantity = 5;
inline void ArenasItemDeselected::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t ArenasItemDeselected::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t ArenasItemDeselected::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ArenasItemDeselected.quantity)
  return _internal_quantity();
}
inline void ArenasItemDeselected::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void ArenasItemDeselected::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ArenasItemDeselected.quantity)
}

// -------------------------------------------------------------------

// InventoryPickUp

// uint64 timestamp = 1;
inline void InventoryPickUp::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t InventoryPickUp::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t InventoryPickUp::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.timestamp)
  return _internal_timestamp();
}
inline void InventoryPickUp::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void InventoryPickUp::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.timestamp)
}

// string category = 2;
inline void InventoryPickUp::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& InventoryPickUp::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryPickUp::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.category)
}
inline std::string* InventoryPickUp::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryPickUp.category)
  return _s;
}
inline const std::string& InventoryPickUp::_internal_category() const {
  return _impl_.category_.Get();
}
inline void InventoryPickUp::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryPickUp::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryPickUp::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryPickUp.category)
  return _impl_.category_.Release();
}
inline void InventoryPickUp::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryPickUp.category)
}

// .rtech.liveapi.Player player = 3;
inline bool InventoryPickUp::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool InventoryPickUp::has_player() const {
  return _internal_has_player();
}
inline void InventoryPickUp::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& InventoryPickUp::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& InventoryPickUp::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.player)
  return _internal_player();
}
inline void InventoryPickUp::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.InventoryPickUp.player)
}
inline ::rtech::liveapi::Player* InventoryPickUp::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* InventoryPickUp::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryPickUp.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* InventoryPickUp::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* InventoryPickUp::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryPickUp.player)
  return _msg;
}
inline void InventoryPickUp::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryPickUp.player)
}

// string item = 4;
inline void InventoryPickUp::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryPickUp::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryPickUp::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.item)
}
inline std::string* InventoryPickUp::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryPickUp.item)
  return _s;
}
inline const std::string& InventoryPickUp::_internal_item() const {
  return _impl_.item_.Get();
}
inline void InventoryPickUp::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryPickUp::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryPickUp::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryPickUp.item)
  return _impl_.item_.Release();
}
inline void InventoryPickUp::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryPickUp.item)
}

// int32 quantity = 5;
inline void InventoryPickUp::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t InventoryPickUp::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t InventoryPickUp::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryPickUp.quantity)
  return _internal_quantity();
}
inline void InventoryPickUp::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void InventoryPickUp::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryPickUp.quantity)
}

// -------------------------------------------------------------------

// InventoryDrop

// uint64 timestamp = 1;
inline void InventoryDrop::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t InventoryDrop::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t InventoryDrop::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.timestamp)
  return _internal_timestamp();
}
inline void InventoryDrop::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void InventoryDrop::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.timestamp)
}

// string category = 2;
inline void InventoryDrop::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& InventoryDrop::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryDrop::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.category)
}
inline std::string* InventoryDrop::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.category)
  return _s;
}
inline const std::string& InventoryDrop::_internal_category() const {
  return _impl_.category_.Get();
}
inline void InventoryDrop::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryDrop::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryDrop::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryDrop.category)
  return _impl_.category_.Release();
}
inline void InventoryDrop::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryDrop.category)
}

// .rtech.liveapi.Player player = 3;
inline bool InventoryDrop::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool InventoryDrop::has_player() const {
  return _internal_has_player();
}
inline void InventoryDrop::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& InventoryDrop::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& InventoryDrop::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.player)
  return _internal_player();
}
inline void InventoryDrop::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.InventoryDrop.player)
}
inline ::rtech::liveapi::Player* InventoryDrop::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* InventoryDrop::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryDrop.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* InventoryDrop::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* InventoryDrop::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.player)
  return _msg;
}
inline void InventoryDrop::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryDrop.player)
}

// string item = 4;
inline void InventoryDrop::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryDrop::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryDrop::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.item)
}
inline std::string* InventoryDrop::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.item)
  return _s;
}
inline const std::string& InventoryDrop::_internal_item() const {
  return _impl_.item_.Get();
}
inline void InventoryDrop::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryDrop::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryDrop::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryDrop.item)
  return _impl_.item_.Release();
}
inline void InventoryDrop::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryDrop.item)
}

// int32 quantity = 5;
inline void InventoryDrop::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t InventoryDrop::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t InventoryDrop::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.quantity)
  return _internal_quantity();
}
inline void InventoryDrop::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void InventoryDrop::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.quantity)
}

// repeated string extraData = 6;
inline int InventoryDrop::_internal_extradata_size() const {
  return _impl_.extradata_.size();
}
inline int InventoryDrop::extradata_size() const {
  return _internal_extradata_size();
}
inline void InventoryDrop::clear_extradata() {
  _impl_.extradata_.Clear();
}
inline std::string* InventoryDrop::add_extradata() {
  std::string* _s = _internal_add_extradata();
  // @@protoc_insertion_point(field_add_mutable:rtech.liveapi.InventoryDrop.extraData)
  return _s;
}
inline const std::string& InventoryDrop::_internal_extradata(int index) const {
  return _impl_.extradata_.Get(index);
}
inline const std::string& InventoryDrop::extradata(int index) const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryDrop.extraData)
  return _internal_extradata(index);
}
inline std::string* InventoryDrop::mutable_extradata(int index) {
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryDrop.extraData)
  return _impl_.extradata_.Mutable(index);
}
inline void InventoryDrop::set_extradata(int index, const std::string& value) {
  _impl_.extradata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, std::string&& value) {
  _impl_.extradata_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extradata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::set_extradata(int index, const char* value, size_t size) {
  _impl_.extradata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rtech.liveapi.InventoryDrop.extraData)
}
inline std::string* InventoryDrop::_internal_add_extradata() {
  return _impl_.extradata_.Add();
}
inline void InventoryDrop::add_extradata(const std::string& value) {
  _impl_.extradata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(std::string&& value) {
  _impl_.extradata_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extradata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rtech.liveapi.InventoryDrop.extraData)
}
inline void InventoryDrop::add_extradata(const char* value, size_t size) {
  _impl_.extradata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rtech.liveapi.InventoryDrop.extraData)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InventoryDrop::extradata() const {
  // @@protoc_insertion_point(field_list:rtech.liveapi.InventoryDrop.extraData)
  return _impl_.extradata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InventoryDrop::mutable_extradata() {
  // @@protoc_insertion_point(field_mutable_list:rtech.liveapi.InventoryDrop.extraData)
  return &_impl_.extradata_;
}

// -------------------------------------------------------------------

// InventoryUse

// uint64 timestamp = 1;
inline void InventoryUse::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t InventoryUse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t InventoryUse::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.timestamp)
  return _internal_timestamp();
}
inline void InventoryUse::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void InventoryUse::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.timestamp)
}

// string category = 2;
inline void InventoryUse::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& InventoryUse::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryUse::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.category)
}
inline std::string* InventoryUse::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryUse.category)
  return _s;
}
inline const std::string& InventoryUse::_internal_category() const {
  return _impl_.category_.Get();
}
inline void InventoryUse::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryUse::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryUse::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryUse.category)
  return _impl_.category_.Release();
}
inline void InventoryUse::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryUse.category)
}

// .rtech.liveapi.Player player = 3;
inline bool InventoryUse::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool InventoryUse::has_player() const {
  return _internal_has_player();
}
inline void InventoryUse::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& InventoryUse::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& InventoryUse::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.player)
  return _internal_player();
}
inline void InventoryUse::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.InventoryUse.player)
}
inline ::rtech::liveapi::Player* InventoryUse::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* InventoryUse::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryUse.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* InventoryUse::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* InventoryUse::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryUse.player)
  return _msg;
}
inline void InventoryUse::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryUse.player)
}

// string item = 4;
inline void InventoryUse::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& InventoryUse::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InventoryUse::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.item)
}
inline std::string* InventoryUse::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.InventoryUse.item)
  return _s;
}
inline const std::string& InventoryUse::_internal_item() const {
  return _impl_.item_.Get();
}
inline void InventoryUse::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryUse::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* InventoryUse::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.InventoryUse.item)
  return _impl_.item_.Release();
}
inline void InventoryUse::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.InventoryUse.item)
}

// int32 quantity = 5;
inline void InventoryUse::clear_quantity() {
  _impl_.quantity_ = 0;
}
inline int32_t InventoryUse::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t InventoryUse::quantity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.InventoryUse.quantity)
  return _internal_quantity();
}
inline void InventoryUse::_internal_set_quantity(int32_t value) {
  
  _impl_.quantity_ = value;
}
inline void InventoryUse::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.InventoryUse.quantity)
}

// -------------------------------------------------------------------

// BannerCollected

// uint64 timestamp = 1;
inline void BannerCollected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t BannerCollected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t BannerCollected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.timestamp)
  return _internal_timestamp();
}
inline void BannerCollected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void BannerCollected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.BannerCollected.timestamp)
}

// string category = 2;
inline void BannerCollected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& BannerCollected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BannerCollected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.BannerCollected.category)
}
inline std::string* BannerCollected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BannerCollected.category)
  return _s;
}
inline const std::string& BannerCollected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void BannerCollected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* BannerCollected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* BannerCollected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.BannerCollected.category)
  return _impl_.category_.Release();
}
inline void BannerCollected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BannerCollected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool BannerCollected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool BannerCollected::has_player() const {
  return _internal_has_player();
}
inline void BannerCollected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& BannerCollected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& BannerCollected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.player)
  return _internal_player();
}
inline void BannerCollected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.BannerCollected.player)
}
inline ::rtech::liveapi::Player* BannerCollected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* BannerCollected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.BannerCollected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* BannerCollected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* BannerCollected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BannerCollected.player)
  return _msg;
}
inline void BannerCollected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BannerCollected.player)
}

// .rtech.liveapi.Player collected = 4;
inline bool BannerCollected::_internal_has_collected() const {
  return this != internal_default_instance() && _impl_.collected_ != nullptr;
}
inline bool BannerCollected::has_collected() const {
  return _internal_has_collected();
}
inline void BannerCollected::clear_collected() {
  if (GetArenaForAllocation() == nullptr && _impl_.collected_ != nullptr) {
    delete _impl_.collected_;
  }
  _impl_.collected_ = nullptr;
}
inline const ::rtech::liveapi::Player& BannerCollected::_internal_collected() const {
  const ::rtech::liveapi::Player* p = _impl_.collected_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& BannerCollected::collected() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BannerCollected.collected)
  return _internal_collected();
}
inline void BannerCollected::unsafe_arena_set_allocated_collected(
    ::rtech::liveapi::Player* collected) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collected_);
  }
  _impl_.collected_ = collected;
  if (collected) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.BannerCollected.collected)
}
inline ::rtech::liveapi::Player* BannerCollected::release_collected() {
  
  ::rtech::liveapi::Player* temp = _impl_.collected_;
  _impl_.collected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* BannerCollected::unsafe_arena_release_collected() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.BannerCollected.collected)
  
  ::rtech::liveapi::Player* temp = _impl_.collected_;
  _impl_.collected_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* BannerCollected::_internal_mutable_collected() {
  
  if (_impl_.collected_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.collected_ = p;
  }
  return _impl_.collected_;
}
inline ::rtech::liveapi::Player* BannerCollected::mutable_collected() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_collected();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BannerCollected.collected)
  return _msg;
}
inline void BannerCollected::set_allocated_collected(::rtech::liveapi::Player* collected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.collected_;
  }
  if (collected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collected);
    if (message_arena != submessage_arena) {
      collected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collected, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.collected_ = collected;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BannerCollected.collected)
}

// -------------------------------------------------------------------

// PlayerAbilityUsed

// uint64 timestamp = 1;
inline void PlayerAbilityUsed::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t PlayerAbilityUsed::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t PlayerAbilityUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.timestamp)
  return _internal_timestamp();
}
inline void PlayerAbilityUsed::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void PlayerAbilityUsed::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAbilityUsed.timestamp)
}

// string category = 2;
inline void PlayerAbilityUsed::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& PlayerAbilityUsed::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerAbilityUsed::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAbilityUsed.category)
}
inline std::string* PlayerAbilityUsed::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAbilityUsed.category)
  return _s;
}
inline const std::string& PlayerAbilityUsed::_internal_category() const {
  return _impl_.category_.Get();
}
inline void PlayerAbilityUsed::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerAbilityUsed::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerAbilityUsed::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAbilityUsed.category)
  return _impl_.category_.Release();
}
inline void PlayerAbilityUsed::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAbilityUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool PlayerAbilityUsed::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerAbilityUsed::has_player() const {
  return _internal_has_player();
}
inline void PlayerAbilityUsed::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& PlayerAbilityUsed::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& PlayerAbilityUsed::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.player)
  return _internal_player();
}
inline void PlayerAbilityUsed::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.PlayerAbilityUsed.player)
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAbilityUsed.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* PlayerAbilityUsed::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAbilityUsed.player)
  return _msg;
}
inline void PlayerAbilityUsed::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAbilityUsed.player)
}

// string linkedEntity = 4;
inline void PlayerAbilityUsed::clear_linkedentity() {
  _impl_.linkedentity_.ClearToEmpty();
}
inline const std::string& PlayerAbilityUsed::linkedentity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
  return _internal_linkedentity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerAbilityUsed::set_linkedentity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.linkedentity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
}
inline std::string* PlayerAbilityUsed::mutable_linkedentity() {
  std::string* _s = _internal_mutable_linkedentity();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
  return _s;
}
inline const std::string& PlayerAbilityUsed::_internal_linkedentity() const {
  return _impl_.linkedentity_.Get();
}
inline void PlayerAbilityUsed::_internal_set_linkedentity(const std::string& value) {
  
  _impl_.linkedentity_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerAbilityUsed::_internal_mutable_linkedentity() {
  
  return _impl_.linkedentity_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerAbilityUsed::release_linkedentity() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
  return _impl_.linkedentity_.Release();
}
inline void PlayerAbilityUsed::set_allocated_linkedentity(std::string* linkedentity) {
  if (linkedentity != nullptr) {
    
  } else {
    
  }
  _impl_.linkedentity_.SetAllocated(linkedentity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedentity_.IsDefault()) {
    _impl_.linkedentity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.PlayerAbilityUsed.linkedEntity)
}

// -------------------------------------------------------------------

// LegendUpgradeSelected

// uint64 timestamp = 1;
inline void LegendUpgradeSelected::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t LegendUpgradeSelected::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t LegendUpgradeSelected::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.timestamp)
  return _internal_timestamp();
}
inline void LegendUpgradeSelected::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void LegendUpgradeSelected::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.timestamp)
}

// string category = 2;
inline void LegendUpgradeSelected::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& LegendUpgradeSelected::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LegendUpgradeSelected::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.category)
}
inline std::string* LegendUpgradeSelected::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.category)
  return _s;
}
inline const std::string& LegendUpgradeSelected::_internal_category() const {
  return _impl_.category_.Get();
}
inline void LegendUpgradeSelected::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* LegendUpgradeSelected::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* LegendUpgradeSelected::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.category)
  return _impl_.category_.Release();
}
inline void LegendUpgradeSelected::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.category)
}

// .rtech.liveapi.Player player = 3;
inline bool LegendUpgradeSelected::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool LegendUpgradeSelected::has_player() const {
  return _internal_has_player();
}
inline void LegendUpgradeSelected::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& LegendUpgradeSelected::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& LegendUpgradeSelected::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.player)
  return _internal_player();
}
inline void LegendUpgradeSelected::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.LegendUpgradeSelected.player)
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* LegendUpgradeSelected::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.player)
  return _msg;
}
inline void LegendUpgradeSelected::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.player)
}

// string upgradeName = 4;
inline void LegendUpgradeSelected::clear_upgradename() {
  _impl_.upgradename_.ClearToEmpty();
}
inline const std::string& LegendUpgradeSelected::upgradename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.upgradeName)
  return _internal_upgradename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LegendUpgradeSelected::set_upgradename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.upgradename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.upgradeName)
}
inline std::string* LegendUpgradeSelected::mutable_upgradename() {
  std::string* _s = _internal_mutable_upgradename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.upgradeName)
  return _s;
}
inline const std::string& LegendUpgradeSelected::_internal_upgradename() const {
  return _impl_.upgradename_.Get();
}
inline void LegendUpgradeSelected::_internal_set_upgradename(const std::string& value) {
  
  _impl_.upgradename_.Set(value, GetArenaForAllocation());
}
inline std::string* LegendUpgradeSelected::_internal_mutable_upgradename() {
  
  return _impl_.upgradename_.Mutable(GetArenaForAllocation());
}
inline std::string* LegendUpgradeSelected::release_upgradename() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.upgradeName)
  return _impl_.upgradename_.Release();
}
inline void LegendUpgradeSelected::set_allocated_upgradename(std::string* upgradename) {
  if (upgradename != nullptr) {
    
  } else {
    
  }
  _impl_.upgradename_.SetAllocated(upgradename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.upgradename_.IsDefault()) {
    _impl_.upgradename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.upgradeName)
}

// string upgradeDesc = 5;
inline void LegendUpgradeSelected::clear_upgradedesc() {
  _impl_.upgradedesc_.ClearToEmpty();
}
inline const std::string& LegendUpgradeSelected::upgradedesc() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
  return _internal_upgradedesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LegendUpgradeSelected::set_upgradedesc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.upgradedesc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
}
inline std::string* LegendUpgradeSelected::mutable_upgradedesc() {
  std::string* _s = _internal_mutable_upgradedesc();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
  return _s;
}
inline const std::string& LegendUpgradeSelected::_internal_upgradedesc() const {
  return _impl_.upgradedesc_.Get();
}
inline void LegendUpgradeSelected::_internal_set_upgradedesc(const std::string& value) {
  
  _impl_.upgradedesc_.Set(value, GetArenaForAllocation());
}
inline std::string* LegendUpgradeSelected::_internal_mutable_upgradedesc() {
  
  return _impl_.upgradedesc_.Mutable(GetArenaForAllocation());
}
inline std::string* LegendUpgradeSelected::release_upgradedesc() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
  return _impl_.upgradedesc_.Release();
}
inline void LegendUpgradeSelected::set_allocated_upgradedesc(std::string* upgradedesc) {
  if (upgradedesc != nullptr) {
    
  } else {
    
  }
  _impl_.upgradedesc_.SetAllocated(upgradedesc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.upgradedesc_.IsDefault()) {
    _impl_.upgradedesc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LegendUpgradeSelected.upgradeDesc)
}

// int32 level = 6;
inline void LegendUpgradeSelected::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t LegendUpgradeSelected::_internal_level() const {
  return _impl_.level_;
}
inline int32_t LegendUpgradeSelected::level() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LegendUpgradeSelected.level)
  return _internal_level();
}
inline void LegendUpgradeSelected::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void LegendUpgradeSelected::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.LegendUpgradeSelected.level)
}

// -------------------------------------------------------------------

// ZiplineUsed

// uint64 timestamp = 1;
inline void ZiplineUsed::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ZiplineUsed::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ZiplineUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.timestamp)
  return _internal_timestamp();
}
inline void ZiplineUsed::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ZiplineUsed::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ZiplineUsed.timestamp)
}

// string category = 2;
inline void ZiplineUsed::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ZiplineUsed::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ZiplineUsed::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ZiplineUsed.category)
}
inline std::string* ZiplineUsed::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ZiplineUsed.category)
  return _s;
}
inline const std::string& ZiplineUsed::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ZiplineUsed::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ZiplineUsed::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ZiplineUsed::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ZiplineUsed.category)
  return _impl_.category_.Release();
}
inline void ZiplineUsed::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ZiplineUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool ZiplineUsed::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool ZiplineUsed::has_player() const {
  return _internal_has_player();
}
inline void ZiplineUsed::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& ZiplineUsed::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& ZiplineUsed::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.player)
  return _internal_player();
}
inline void ZiplineUsed::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.ZiplineUsed.player)
}
inline ::rtech::liveapi::Player* ZiplineUsed::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* ZiplineUsed::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ZiplineUsed.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* ZiplineUsed::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* ZiplineUsed::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ZiplineUsed.player)
  return _msg;
}
inline void ZiplineUsed::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ZiplineUsed.player)
}

// string linkedEntity = 4;
inline void ZiplineUsed::clear_linkedentity() {
  _impl_.linkedentity_.ClearToEmpty();
}
inline const std::string& ZiplineUsed::linkedentity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ZiplineUsed.linkedEntity)
  return _internal_linkedentity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ZiplineUsed::set_linkedentity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.linkedentity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ZiplineUsed.linkedEntity)
}
inline std::string* ZiplineUsed::mutable_linkedentity() {
  std::string* _s = _internal_mutable_linkedentity();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ZiplineUsed.linkedEntity)
  return _s;
}
inline const std::string& ZiplineUsed::_internal_linkedentity() const {
  return _impl_.linkedentity_.Get();
}
inline void ZiplineUsed::_internal_set_linkedentity(const std::string& value) {
  
  _impl_.linkedentity_.Set(value, GetArenaForAllocation());
}
inline std::string* ZiplineUsed::_internal_mutable_linkedentity() {
  
  return _impl_.linkedentity_.Mutable(GetArenaForAllocation());
}
inline std::string* ZiplineUsed::release_linkedentity() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ZiplineUsed.linkedEntity)
  return _impl_.linkedentity_.Release();
}
inline void ZiplineUsed::set_allocated_linkedentity(std::string* linkedentity) {
  if (linkedentity != nullptr) {
    
  } else {
    
  }
  _impl_.linkedentity_.SetAllocated(linkedentity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedentity_.IsDefault()) {
    _impl_.linkedentity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ZiplineUsed.linkedEntity)
}

// -------------------------------------------------------------------

// GrenadeThrown

// uint64 timestamp = 1;
inline void GrenadeThrown::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t GrenadeThrown::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t GrenadeThrown::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.timestamp)
  return _internal_timestamp();
}
inline void GrenadeThrown::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void GrenadeThrown::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.GrenadeThrown.timestamp)
}

// string category = 2;
inline void GrenadeThrown::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& GrenadeThrown::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrenadeThrown::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GrenadeThrown.category)
}
inline std::string* GrenadeThrown::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GrenadeThrown.category)
  return _s;
}
inline const std::string& GrenadeThrown::_internal_category() const {
  return _impl_.category_.Get();
}
inline void GrenadeThrown::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* GrenadeThrown::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* GrenadeThrown::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GrenadeThrown.category)
  return _impl_.category_.Release();
}
inline void GrenadeThrown::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GrenadeThrown.category)
}

// .rtech.liveapi.Player player = 3;
inline bool GrenadeThrown::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool GrenadeThrown::has_player() const {
  return _internal_has_player();
}
inline void GrenadeThrown::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& GrenadeThrown::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& GrenadeThrown::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.player)
  return _internal_player();
}
inline void GrenadeThrown::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.GrenadeThrown.player)
}
inline ::rtech::liveapi::Player* GrenadeThrown::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* GrenadeThrown::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GrenadeThrown.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* GrenadeThrown::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* GrenadeThrown::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GrenadeThrown.player)
  return _msg;
}
inline void GrenadeThrown::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GrenadeThrown.player)
}

// string linkedEntity = 4;
inline void GrenadeThrown::clear_linkedentity() {
  _impl_.linkedentity_.ClearToEmpty();
}
inline const std::string& GrenadeThrown::linkedentity() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.GrenadeThrown.linkedEntity)
  return _internal_linkedentity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrenadeThrown::set_linkedentity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.linkedentity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.GrenadeThrown.linkedEntity)
}
inline std::string* GrenadeThrown::mutable_linkedentity() {
  std::string* _s = _internal_mutable_linkedentity();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.GrenadeThrown.linkedEntity)
  return _s;
}
inline const std::string& GrenadeThrown::_internal_linkedentity() const {
  return _impl_.linkedentity_.Get();
}
inline void GrenadeThrown::_internal_set_linkedentity(const std::string& value) {
  
  _impl_.linkedentity_.Set(value, GetArenaForAllocation());
}
inline std::string* GrenadeThrown::_internal_mutable_linkedentity() {
  
  return _impl_.linkedentity_.Mutable(GetArenaForAllocation());
}
inline std::string* GrenadeThrown::release_linkedentity() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.GrenadeThrown.linkedEntity)
  return _impl_.linkedentity_.Release();
}
inline void GrenadeThrown::set_allocated_linkedentity(std::string* linkedentity) {
  if (linkedentity != nullptr) {
    
  } else {
    
  }
  _impl_.linkedentity_.SetAllocated(linkedentity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkedentity_.IsDefault()) {
    _impl_.linkedentity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.GrenadeThrown.linkedEntity)
}

// -------------------------------------------------------------------

// BlackMarketAction

// uint64 timestamp = 1;
inline void BlackMarketAction::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t BlackMarketAction::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t BlackMarketAction::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.timestamp)
  return _internal_timestamp();
}
inline void BlackMarketAction::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void BlackMarketAction::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.BlackMarketAction.timestamp)
}

// string category = 2;
inline void BlackMarketAction::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& BlackMarketAction::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlackMarketAction::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.BlackMarketAction.category)
}
inline std::string* BlackMarketAction::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BlackMarketAction.category)
  return _s;
}
inline const std::string& BlackMarketAction::_internal_category() const {
  return _impl_.category_.Get();
}
inline void BlackMarketAction::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* BlackMarketAction::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* BlackMarketAction::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.BlackMarketAction.category)
  return _impl_.category_.Release();
}
inline void BlackMarketAction::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BlackMarketAction.category)
}

// .rtech.liveapi.Player player = 3;
inline bool BlackMarketAction::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool BlackMarketAction::has_player() const {
  return _internal_has_player();
}
inline void BlackMarketAction::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& BlackMarketAction::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& BlackMarketAction::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.player)
  return _internal_player();
}
inline void BlackMarketAction::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.BlackMarketAction.player)
}
inline ::rtech::liveapi::Player* BlackMarketAction::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* BlackMarketAction::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.BlackMarketAction.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* BlackMarketAction::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* BlackMarketAction::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BlackMarketAction.player)
  return _msg;
}
inline void BlackMarketAction::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BlackMarketAction.player)
}

// string item = 4;
inline void BlackMarketAction::clear_item() {
  _impl_.item_.ClearToEmpty();
}
inline const std::string& BlackMarketAction::item() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.BlackMarketAction.item)
  return _internal_item();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlackMarketAction::set_item(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.BlackMarketAction.item)
}
inline std::string* BlackMarketAction::mutable_item() {
  std::string* _s = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.BlackMarketAction.item)
  return _s;
}
inline const std::string& BlackMarketAction::_internal_item() const {
  return _impl_.item_.Get();
}
inline void BlackMarketAction::_internal_set_item(const std::string& value) {
  
  _impl_.item_.Set(value, GetArenaForAllocation());
}
inline std::string* BlackMarketAction::_internal_mutable_item() {
  
  return _impl_.item_.Mutable(GetArenaForAllocation());
}
inline std::string* BlackMarketAction::release_item() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.BlackMarketAction.item)
  return _impl_.item_.Release();
}
inline void BlackMarketAction::set_allocated_item(std::string* item) {
  if (item != nullptr) {
    
  } else {
    
  }
  _impl_.item_.SetAllocated(item, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_.IsDefault()) {
    _impl_.item_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.BlackMarketAction.item)
}

// -------------------------------------------------------------------

// WraithPortal

// uint64 timestamp = 1;
inline void WraithPortal::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t WraithPortal::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t WraithPortal::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WraithPortal.timestamp)
  return _internal_timestamp();
}
inline void WraithPortal::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void WraithPortal::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.WraithPortal.timestamp)
}

// string category = 2;
inline void WraithPortal::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& WraithPortal::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WraithPortal.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WraithPortal::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WraithPortal.category)
}
inline std::string* WraithPortal::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WraithPortal.category)
  return _s;
}
inline const std::string& WraithPortal::_internal_category() const {
  return _impl_.category_.Get();
}
inline void WraithPortal::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* WraithPortal::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* WraithPortal::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WraithPortal.category)
  return _impl_.category_.Release();
}
inline void WraithPortal::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WraithPortal.category)
}

// .rtech.liveapi.Player player = 3;
inline bool WraithPortal::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool WraithPortal::has_player() const {
  return _internal_has_player();
}
inline void WraithPortal::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& WraithPortal::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& WraithPortal::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WraithPortal.player)
  return _internal_player();
}
inline void WraithPortal::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.WraithPortal.player)
}
inline ::rtech::liveapi::Player* WraithPortal::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* WraithPortal::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WraithPortal.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* WraithPortal::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* WraithPortal::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WraithPortal.player)
  return _msg;
}
inline void WraithPortal::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WraithPortal.player)
}

// -------------------------------------------------------------------

// WarpGateUsed

// uint64 timestamp = 1;
inline void WarpGateUsed::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t WarpGateUsed::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t WarpGateUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WarpGateUsed.timestamp)
  return _internal_timestamp();
}
inline void WarpGateUsed::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void WarpGateUsed::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.WarpGateUsed.timestamp)
}

// string category = 2;
inline void WarpGateUsed::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& WarpGateUsed::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WarpGateUsed.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WarpGateUsed::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WarpGateUsed.category)
}
inline std::string* WarpGateUsed::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WarpGateUsed.category)
  return _s;
}
inline const std::string& WarpGateUsed::_internal_category() const {
  return _impl_.category_.Get();
}
inline void WarpGateUsed::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* WarpGateUsed::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* WarpGateUsed::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WarpGateUsed.category)
  return _impl_.category_.Release();
}
inline void WarpGateUsed::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WarpGateUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool WarpGateUsed::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool WarpGateUsed::has_player() const {
  return _internal_has_player();
}
inline void WarpGateUsed::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& WarpGateUsed::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& WarpGateUsed::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WarpGateUsed.player)
  return _internal_player();
}
inline void WarpGateUsed::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.WarpGateUsed.player)
}
inline ::rtech::liveapi::Player* WarpGateUsed::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* WarpGateUsed::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WarpGateUsed.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* WarpGateUsed::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* WarpGateUsed::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WarpGateUsed.player)
  return _msg;
}
inline void WarpGateUsed::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WarpGateUsed.player)
}

// -------------------------------------------------------------------

// AmmoUsed

// uint64 timestamp = 1;
inline void AmmoUsed::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t AmmoUsed::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t AmmoUsed::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.timestamp)
  return _internal_timestamp();
}
inline void AmmoUsed::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void AmmoUsed::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.timestamp)
}

// string category = 2;
inline void AmmoUsed::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& AmmoUsed::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AmmoUsed::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.category)
}
inline std::string* AmmoUsed::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.AmmoUsed.category)
  return _s;
}
inline const std::string& AmmoUsed::_internal_category() const {
  return _impl_.category_.Get();
}
inline void AmmoUsed::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* AmmoUsed::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* AmmoUsed::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.AmmoUsed.category)
  return _impl_.category_.Release();
}
inline void AmmoUsed::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.AmmoUsed.category)
}

// .rtech.liveapi.Player player = 3;
inline bool AmmoUsed::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool AmmoUsed::has_player() const {
  return _internal_has_player();
}
inline void AmmoUsed::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& AmmoUsed::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& AmmoUsed::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.player)
  return _internal_player();
}
inline void AmmoUsed::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.AmmoUsed.player)
}
inline ::rtech::liveapi::Player* AmmoUsed::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* AmmoUsed::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.AmmoUsed.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* AmmoUsed::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* AmmoUsed::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.AmmoUsed.player)
  return _msg;
}
inline void AmmoUsed::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.AmmoUsed.player)
}

// string ammoType = 4;
inline void AmmoUsed::clear_ammotype() {
  _impl_.ammotype_.ClearToEmpty();
}
inline const std::string& AmmoUsed::ammotype() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.ammoType)
  return _internal_ammotype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AmmoUsed::set_ammotype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ammotype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.ammoType)
}
inline std::string* AmmoUsed::mutable_ammotype() {
  std::string* _s = _internal_mutable_ammotype();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.AmmoUsed.ammoType)
  return _s;
}
inline const std::string& AmmoUsed::_internal_ammotype() const {
  return _impl_.ammotype_.Get();
}
inline void AmmoUsed::_internal_set_ammotype(const std::string& value) {
  
  _impl_.ammotype_.Set(value, GetArenaForAllocation());
}
inline std::string* AmmoUsed::_internal_mutable_ammotype() {
  
  return _impl_.ammotype_.Mutable(GetArenaForAllocation());
}
inline std::string* AmmoUsed::release_ammotype() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.AmmoUsed.ammoType)
  return _impl_.ammotype_.Release();
}
inline void AmmoUsed::set_allocated_ammotype(std::string* ammotype) {
  if (ammotype != nullptr) {
    
  } else {
    
  }
  _impl_.ammotype_.SetAllocated(ammotype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ammotype_.IsDefault()) {
    _impl_.ammotype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.AmmoUsed.ammoType)
}

// uint32 amountUsed = 5;
inline void AmmoUsed::clear_amountused() {
  _impl_.amountused_ = 0u;
}
inline uint32_t AmmoUsed::_internal_amountused() const {
  return _impl_.amountused_;
}
inline uint32_t AmmoUsed::amountused() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.amountUsed)
  return _internal_amountused();
}
inline void AmmoUsed::_internal_set_amountused(uint32_t value) {
  
  _impl_.amountused_ = value;
}
inline void AmmoUsed::set_amountused(uint32_t value) {
  _internal_set_amountused(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.amountUsed)
}

// uint32 oldAmmoCount = 6;
inline void AmmoUsed::clear_oldammocount() {
  _impl_.oldammocount_ = 0u;
}
inline uint32_t AmmoUsed::_internal_oldammocount() const {
  return _impl_.oldammocount_;
}
inline uint32_t AmmoUsed::oldammocount() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.oldAmmoCount)
  return _internal_oldammocount();
}
inline void AmmoUsed::_internal_set_oldammocount(uint32_t value) {
  
  _impl_.oldammocount_ = value;
}
inline void AmmoUsed::set_oldammocount(uint32_t value) {
  _internal_set_oldammocount(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.oldAmmoCount)
}

// uint32 newAmmoCount = 7;
inline void AmmoUsed::clear_newammocount() {
  _impl_.newammocount_ = 0u;
}
inline uint32_t AmmoUsed::_internal_newammocount() const {
  return _impl_.newammocount_;
}
inline uint32_t AmmoUsed::newammocount() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.AmmoUsed.newAmmoCount)
  return _internal_newammocount();
}
inline void AmmoUsed::_internal_set_newammocount(uint32_t value) {
  
  _impl_.newammocount_ = value;
}
inline void AmmoUsed::set_newammocount(uint32_t value) {
  _internal_set_newammocount(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.AmmoUsed.newAmmoCount)
}

// -------------------------------------------------------------------

// WeaponSwitched

// uint64 timestamp = 1;
inline void WeaponSwitched::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t WeaponSwitched::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t WeaponSwitched::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.timestamp)
  return _internal_timestamp();
}
inline void WeaponSwitched::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void WeaponSwitched::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.timestamp)
}

// string category = 2;
inline void WeaponSwitched::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& WeaponSwitched::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponSwitched::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.category)
}
inline std::string* WeaponSwitched::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.category)
  return _s;
}
inline const std::string& WeaponSwitched::_internal_category() const {
  return _impl_.category_.Get();
}
inline void WeaponSwitched::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponSwitched::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponSwitched::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.category)
  return _impl_.category_.Release();
}
inline void WeaponSwitched::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.category)
}

// .rtech.liveapi.Player player = 3;
inline bool WeaponSwitched::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool WeaponSwitched::has_player() const {
  return _internal_has_player();
}
inline void WeaponSwitched::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::rtech::liveapi::Player& WeaponSwitched::_internal_player() const {
  const ::rtech::liveapi::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::rtech::liveapi::Player&>(
      ::rtech::liveapi::_Player_default_instance_);
}
inline const ::rtech::liveapi::Player& WeaponSwitched::player() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.player)
  return _internal_player();
}
inline void WeaponSwitched::unsafe_arena_set_allocated_player(
    ::rtech::liveapi::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.WeaponSwitched.player)
}
inline ::rtech::liveapi::Player* WeaponSwitched::release_player() {
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rtech::liveapi::Player* WeaponSwitched::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.player)
  
  ::rtech::liveapi::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::rtech::liveapi::Player* WeaponSwitched::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::rtech::liveapi::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::rtech::liveapi::Player* WeaponSwitched::mutable_player() {
  ::rtech::liveapi::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.player)
  return _msg;
}
inline void WeaponSwitched::set_allocated_player(::rtech::liveapi::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.player)
}

// string oldWeapon = 4;
inline void WeaponSwitched::clear_oldweapon() {
  _impl_.oldweapon_.ClearToEmpty();
}
inline const std::string& WeaponSwitched::oldweapon() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.oldWeapon)
  return _internal_oldweapon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponSwitched::set_oldweapon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.oldweapon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.oldWeapon)
}
inline std::string* WeaponSwitched::mutable_oldweapon() {
  std::string* _s = _internal_mutable_oldweapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.oldWeapon)
  return _s;
}
inline const std::string& WeaponSwitched::_internal_oldweapon() const {
  return _impl_.oldweapon_.Get();
}
inline void WeaponSwitched::_internal_set_oldweapon(const std::string& value) {
  
  _impl_.oldweapon_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponSwitched::_internal_mutable_oldweapon() {
  
  return _impl_.oldweapon_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponSwitched::release_oldweapon() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.oldWeapon)
  return _impl_.oldweapon_.Release();
}
inline void WeaponSwitched::set_allocated_oldweapon(std::string* oldweapon) {
  if (oldweapon != nullptr) {
    
  } else {
    
  }
  _impl_.oldweapon_.SetAllocated(oldweapon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oldweapon_.IsDefault()) {
    _impl_.oldweapon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.oldWeapon)
}

// string newWeapon = 5;
inline void WeaponSwitched::clear_newweapon() {
  _impl_.newweapon_.ClearToEmpty();
}
inline const std::string& WeaponSwitched::newweapon() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.WeaponSwitched.newWeapon)
  return _internal_newweapon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WeaponSwitched::set_newweapon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newweapon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.WeaponSwitched.newWeapon)
}
inline std::string* WeaponSwitched::mutable_newweapon() {
  std::string* _s = _internal_mutable_newweapon();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.WeaponSwitched.newWeapon)
  return _s;
}
inline const std::string& WeaponSwitched::_internal_newweapon() const {
  return _impl_.newweapon_.Get();
}
inline void WeaponSwitched::_internal_set_newweapon(const std::string& value) {
  
  _impl_.newweapon_.Set(value, GetArenaForAllocation());
}
inline std::string* WeaponSwitched::_internal_mutable_newweapon() {
  
  return _impl_.newweapon_.Mutable(GetArenaForAllocation());
}
inline std::string* WeaponSwitched::release_newweapon() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.WeaponSwitched.newWeapon)
  return _impl_.newweapon_.Release();
}
inline void WeaponSwitched::set_allocated_newweapon(std::string* newweapon) {
  if (newweapon != nullptr) {
    
  } else {
    
  }
  _impl_.newweapon_.SetAllocated(newweapon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newweapon_.IsDefault()) {
    _impl_.newweapon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.WeaponSwitched.newWeapon)
}

// -------------------------------------------------------------------

// CustomEvent

// uint64 timestamp = 1;
inline void CustomEvent::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t CustomEvent::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t CustomEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomEvent.timestamp)
  return _internal_timestamp();
}
inline void CustomEvent::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void CustomEvent::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomEvent.timestamp)
}

// string category = 2;
inline void CustomEvent::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& CustomEvent::category() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomEvent.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomEvent::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomEvent.category)
}
inline std::string* CustomEvent::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomEvent.category)
  return _s;
}
inline const std::string& CustomEvent::_internal_category() const {
  return _impl_.category_.Get();
}
inline void CustomEvent::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomEvent::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomEvent::release_category() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomEvent.category)
  return _impl_.category_.Release();
}
inline void CustomEvent::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomEvent.category)
}

// string name = 3;
inline void CustomEvent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CustomEvent::name() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomEvent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomEvent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomEvent.name)
}
inline std::string* CustomEvent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomEvent.name)
  return _s;
}
inline const std::string& CustomEvent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CustomEvent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomEvent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomEvent::release_name() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomEvent.name)
  return _impl_.name_.Release();
}
inline void CustomEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomEvent.name)
}

// .google.protobuf.Struct data = 4;
inline bool CustomEvent::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool CustomEvent::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CustomEvent::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CustomEvent::data() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomEvent.data)
  return _internal_data();
}
inline void CustomEvent::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.CustomEvent.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CustomEvent::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CustomEvent::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomEvent.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CustomEvent::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CustomEvent::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomEvent.data)
  return _msg;
}
inline void CustomEvent::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomEvent.data)
}

// -------------------------------------------------------------------

// ChangeCamera

// .rtech.liveapi.PlayerOfInterest poi = 1;
inline bool ChangeCamera::_internal_has_poi() const {
  return target_case() == kPoi;
}
inline bool ChangeCamera::has_poi() const {
  return _internal_has_poi();
}
inline void ChangeCamera::set_has_poi() {
  _impl_._oneof_case_[0] = kPoi;
}
inline void ChangeCamera::clear_poi() {
  if (_internal_has_poi()) {
    _impl_.target_.poi_ = 0;
    clear_has_target();
  }
}
inline ::rtech::liveapi::PlayerOfInterest ChangeCamera::_internal_poi() const {
  if (_internal_has_poi()) {
    return static_cast< ::rtech::liveapi::PlayerOfInterest >(_impl_.target_.poi_);
  }
  return static_cast< ::rtech::liveapi::PlayerOfInterest >(0);
}
inline ::rtech::liveapi::PlayerOfInterest ChangeCamera::poi() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ChangeCamera.poi)
  return _internal_poi();
}
inline void ChangeCamera::_internal_set_poi(::rtech::liveapi::PlayerOfInterest value) {
  if (!_internal_has_poi()) {
    clear_target();
    set_has_poi();
  }
  _impl_.target_.poi_ = value;
}
inline void ChangeCamera::set_poi(::rtech::liveapi::PlayerOfInterest value) {
  _internal_set_poi(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.ChangeCamera.poi)
}

// string name = 2;
inline bool ChangeCamera::_internal_has_name() const {
  return target_case() == kName;
}
inline bool ChangeCamera::has_name() const {
  return _internal_has_name();
}
inline void ChangeCamera::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void ChangeCamera::clear_name() {
  if (_internal_has_name()) {
    _impl_.target_.name_.Destroy();
    clear_has_target();
  }
}
inline const std::string& ChangeCamera::name() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.ChangeCamera.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void ChangeCamera::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_target();
    set_has_name();
    _impl_.target_.name_.InitDefault();
  }
  _impl_.target_.name_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.ChangeCamera.name)
}
inline std::string* ChangeCamera::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.ChangeCamera.name)
  return _s;
}
inline const std::string& ChangeCamera::_internal_name() const {
  if (_internal_has_name()) {
    return _impl_.target_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ChangeCamera::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_target();
    set_has_name();
    _impl_.target_.name_.InitDefault();
  }
  _impl_.target_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeCamera::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_target();
    set_has_name();
    _impl_.target_.name_.InitDefault();
  }
  return _impl_.target_.name_.Mutable(      GetArenaForAllocation());
}
inline std::string* ChangeCamera::release_name() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.ChangeCamera.name)
  if (_internal_has_name()) {
    clear_has_target();
    return _impl_.target_.name_.Release();
  } else {
    return nullptr;
  }
}
inline void ChangeCamera::set_allocated_name(std::string* name) {
  if (has_target()) {
    clear_target();
  }
  if (name != nullptr) {
    set_has_name();
    _impl_.target_.name_.InitAllocated(name, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.ChangeCamera.name)
}

inline bool ChangeCamera::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ChangeCamera::clear_has_target() {
  _impl_._oneof_case_[0] = TARGET_NOT_SET;
}
inline ChangeCamera::TargetCase ChangeCamera::target_case() const {
  return ChangeCamera::TargetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PauseToggle

// float preTimer = 1;
inline void PauseToggle::clear_pretimer() {
  _impl_.pretimer_ = 0;
}
inline float PauseToggle::_internal_pretimer() const {
  return _impl_.pretimer_;
}
inline float PauseToggle::pretimer() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.PauseToggle.preTimer)
  return _internal_pretimer();
}
inline void PauseToggle::_internal_set_pretimer(float value) {
  
  _impl_.pretimer_ = value;
}
inline void PauseToggle::set_pretimer(float value) {
  _internal_set_pretimer(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.PauseToggle.preTimer)
}

// -------------------------------------------------------------------

// CustomMatch_CreateLobby

// -------------------------------------------------------------------

// CustomMatch_JoinLobby

// string roleToken = 1;
inline void CustomMatch_JoinLobby::clear_roletoken() {
  _impl_.roletoken_.ClearToEmpty();
}
inline const std::string& CustomMatch_JoinLobby::roletoken() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
  return _internal_roletoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_JoinLobby::set_roletoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roletoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
}
inline std::string* CustomMatch_JoinLobby::mutable_roletoken() {
  std::string* _s = _internal_mutable_roletoken();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
  return _s;
}
inline const std::string& CustomMatch_JoinLobby::_internal_roletoken() const {
  return _impl_.roletoken_.Get();
}
inline void CustomMatch_JoinLobby::_internal_set_roletoken(const std::string& value) {
  
  _impl_.roletoken_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_JoinLobby::_internal_mutable_roletoken() {
  
  return _impl_.roletoken_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_JoinLobby::release_roletoken() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
  return _impl_.roletoken_.Release();
}
inline void CustomMatch_JoinLobby::set_allocated_roletoken(std::string* roletoken) {
  if (roletoken != nullptr) {
    
  } else {
    
  }
  _impl_.roletoken_.SetAllocated(roletoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roletoken_.IsDefault()) {
    _impl_.roletoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_JoinLobby.roleToken)
}

// -------------------------------------------------------------------

// CustomMatch_LeaveLobby

// -------------------------------------------------------------------

// CustomMatch_SetReady

// bool isReady = 1;
inline void CustomMatch_SetReady::clear_isready() {
  _impl_.isready_ = false;
}
inline bool CustomMatch_SetReady::_internal_isready() const {
  return _impl_.isready_;
}
inline bool CustomMatch_SetReady::isready() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetReady.isReady)
  return _internal_isready();
}
inline void CustomMatch_SetReady::_internal_set_isready(bool value) {
  
  _impl_.isready_ = value;
}
inline void CustomMatch_SetReady::set_isready(bool value) {
  _internal_set_isready(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetReady.isReady)
}

// -------------------------------------------------------------------

// CustomMatch_GetLobbyPlayers

// -------------------------------------------------------------------

// CustomMatch_SetMatchmaking

// bool enabled = 1;
inline void CustomMatch_SetMatchmaking::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool CustomMatch_SetMatchmaking::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool CustomMatch_SetMatchmaking::enabled() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetMatchmaking.enabled)
  return _internal_enabled();
}
inline void CustomMatch_SetMatchmaking::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void CustomMatch_SetMatchmaking::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetMatchmaking.enabled)
}

// -------------------------------------------------------------------

// CustomMatch_SetTeam

// int32 teamId = 1;
inline void CustomMatch_SetTeam::clear_teamid() {
  _impl_.teamid_ = 0;
}
inline int32_t CustomMatch_SetTeam::_internal_teamid() const {
  return _impl_.teamid_;
}
inline int32_t CustomMatch_SetTeam::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeam.teamId)
  return _internal_teamid();
}
inline void CustomMatch_SetTeam::_internal_set_teamid(int32_t value) {
  
  _impl_.teamid_ = value;
}
inline void CustomMatch_SetTeam::set_teamid(int32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeam.teamId)
}

// string targetHardwareName = 2;
inline void CustomMatch_SetTeam::clear_targethardwarename() {
  _impl_.targethardwarename_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetTeam::targethardwarename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
  return _internal_targethardwarename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_SetTeam::set_targethardwarename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targethardwarename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
}
inline std::string* CustomMatch_SetTeam::mutable_targethardwarename() {
  std::string* _s = _internal_mutable_targethardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
  return _s;
}
inline const std::string& CustomMatch_SetTeam::_internal_targethardwarename() const {
  return _impl_.targethardwarename_.Get();
}
inline void CustomMatch_SetTeam::_internal_set_targethardwarename(const std::string& value) {
  
  _impl_.targethardwarename_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_SetTeam::_internal_mutable_targethardwarename() {
  
  return _impl_.targethardwarename_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_SetTeam::release_targethardwarename() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
  return _impl_.targethardwarename_.Release();
}
inline void CustomMatch_SetTeam::set_allocated_targethardwarename(std::string* targethardwarename) {
  if (targethardwarename != nullptr) {
    
  } else {
    
  }
  _impl_.targethardwarename_.SetAllocated(targethardwarename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targethardwarename_.IsDefault()) {
    _impl_.targethardwarename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetTeam.targetHardwareName)
}

// string targetNucleusHash = 3;
inline void CustomMatch_SetTeam::clear_targetnucleushash() {
  _impl_.targetnucleushash_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetTeam::targetnucleushash() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
  return _internal_targetnucleushash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_SetTeam::set_targetnucleushash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetnucleushash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
}
inline std::string* CustomMatch_SetTeam::mutable_targetnucleushash() {
  std::string* _s = _internal_mutable_targetnucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
  return _s;
}
inline const std::string& CustomMatch_SetTeam::_internal_targetnucleushash() const {
  return _impl_.targetnucleushash_.Get();
}
inline void CustomMatch_SetTeam::_internal_set_targetnucleushash(const std::string& value) {
  
  _impl_.targetnucleushash_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_SetTeam::_internal_mutable_targetnucleushash() {
  
  return _impl_.targetnucleushash_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_SetTeam::release_targetnucleushash() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
  return _impl_.targetnucleushash_.Release();
}
inline void CustomMatch_SetTeam::set_allocated_targetnucleushash(std::string* targetnucleushash) {
  if (targetnucleushash != nullptr) {
    
  } else {
    
  }
  _impl_.targetnucleushash_.SetAllocated(targetnucleushash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetnucleushash_.IsDefault()) {
    _impl_.targetnucleushash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetTeam.targetNucleusHash)
}

// -------------------------------------------------------------------

// CustomMatch_KickPlayer

// string targetHardwareName = 1;
inline void CustomMatch_KickPlayer::clear_targethardwarename() {
  _impl_.targethardwarename_.ClearToEmpty();
}
inline const std::string& CustomMatch_KickPlayer::targethardwarename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
  return _internal_targethardwarename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_KickPlayer::set_targethardwarename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targethardwarename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
}
inline std::string* CustomMatch_KickPlayer::mutable_targethardwarename() {
  std::string* _s = _internal_mutable_targethardwarename();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
  return _s;
}
inline const std::string& CustomMatch_KickPlayer::_internal_targethardwarename() const {
  return _impl_.targethardwarename_.Get();
}
inline void CustomMatch_KickPlayer::_internal_set_targethardwarename(const std::string& value) {
  
  _impl_.targethardwarename_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_KickPlayer::_internal_mutable_targethardwarename() {
  
  return _impl_.targethardwarename_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_KickPlayer::release_targethardwarename() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
  return _impl_.targethardwarename_.Release();
}
inline void CustomMatch_KickPlayer::set_allocated_targethardwarename(std::string* targethardwarename) {
  if (targethardwarename != nullptr) {
    
  } else {
    
  }
  _impl_.targethardwarename_.SetAllocated(targethardwarename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targethardwarename_.IsDefault()) {
    _impl_.targethardwarename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_KickPlayer.targetHardwareName)
}

// string targetNucleusHash = 2;
inline void CustomMatch_KickPlayer::clear_targetnucleushash() {
  _impl_.targetnucleushash_.ClearToEmpty();
}
inline const std::string& CustomMatch_KickPlayer::targetnucleushash() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
  return _internal_targetnucleushash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_KickPlayer::set_targetnucleushash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetnucleushash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
}
inline std::string* CustomMatch_KickPlayer::mutable_targetnucleushash() {
  std::string* _s = _internal_mutable_targetnucleushash();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
  return _s;
}
inline const std::string& CustomMatch_KickPlayer::_internal_targetnucleushash() const {
  return _impl_.targetnucleushash_.Get();
}
inline void CustomMatch_KickPlayer::_internal_set_targetnucleushash(const std::string& value) {
  
  _impl_.targetnucleushash_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_KickPlayer::_internal_mutable_targetnucleushash() {
  
  return _impl_.targetnucleushash_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_KickPlayer::release_targetnucleushash() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
  return _impl_.targetnucleushash_.Release();
}
inline void CustomMatch_KickPlayer::set_allocated_targetnucleushash(std::string* targetnucleushash) {
  if (targetnucleushash != nullptr) {
    
  } else {
    
  }
  _impl_.targetnucleushash_.SetAllocated(targetnucleushash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetnucleushash_.IsDefault()) {
    _impl_.targetnucleushash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_KickPlayer.targetNucleusHash)
}

// -------------------------------------------------------------------

// CustomMatch_SetSettings

// string playlistName = 1;
inline void CustomMatch_SetSettings::clear_playlistname() {
  _impl_.playlistname_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetSettings::playlistname() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.playlistName)
  return _internal_playlistname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_SetSettings::set_playlistname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playlistname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.playlistName)
}
inline std::string* CustomMatch_SetSettings::mutable_playlistname() {
  std::string* _s = _internal_mutable_playlistname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetSettings.playlistName)
  return _s;
}
inline const std::string& CustomMatch_SetSettings::_internal_playlistname() const {
  return _impl_.playlistname_.Get();
}
inline void CustomMatch_SetSettings::_internal_set_playlistname(const std::string& value) {
  
  _impl_.playlistname_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_SetSettings::_internal_mutable_playlistname() {
  
  return _impl_.playlistname_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_SetSettings::release_playlistname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetSettings.playlistName)
  return _impl_.playlistname_.Release();
}
inline void CustomMatch_SetSettings::set_allocated_playlistname(std::string* playlistname) {
  if (playlistname != nullptr) {
    
  } else {
    
  }
  _impl_.playlistname_.SetAllocated(playlistname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playlistname_.IsDefault()) {
    _impl_.playlistname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetSettings.playlistName)
}

// bool adminChat = 2;
inline void CustomMatch_SetSettings::clear_adminchat() {
  _impl_.adminchat_ = false;
}
inline bool CustomMatch_SetSettings::_internal_adminchat() const {
  return _impl_.adminchat_;
}
inline bool CustomMatch_SetSettings::adminchat() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.adminChat)
  return _internal_adminchat();
}
inline void CustomMatch_SetSettings::_internal_set_adminchat(bool value) {
  
  _impl_.adminchat_ = value;
}
inline void CustomMatch_SetSettings::set_adminchat(bool value) {
  _internal_set_adminchat(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.adminChat)
}

// bool teamRename = 3;
inline void CustomMatch_SetSettings::clear_teamrename() {
  _impl_.teamrename_ = false;
}
inline bool CustomMatch_SetSettings::_internal_teamrename() const {
  return _impl_.teamrename_;
}
inline bool CustomMatch_SetSettings::teamrename() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.teamRename)
  return _internal_teamrename();
}
inline void CustomMatch_SetSettings::_internal_set_teamrename(bool value) {
  
  _impl_.teamrename_ = value;
}
inline void CustomMatch_SetSettings::set_teamrename(bool value) {
  _internal_set_teamrename(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.teamRename)
}

// bool selfAssign = 4;
inline void CustomMatch_SetSettings::clear_selfassign() {
  _impl_.selfassign_ = false;
}
inline bool CustomMatch_SetSettings::_internal_selfassign() const {
  return _impl_.selfassign_;
}
inline bool CustomMatch_SetSettings::selfassign() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.selfAssign)
  return _internal_selfassign();
}
inline void CustomMatch_SetSettings::_internal_set_selfassign(bool value) {
  
  _impl_.selfassign_ = value;
}
inline void CustomMatch_SetSettings::set_selfassign(bool value) {
  _internal_set_selfassign(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.selfAssign)
}

// bool aimAssist = 5;
inline void CustomMatch_SetSettings::clear_aimassist() {
  _impl_.aimassist_ = false;
}
inline bool CustomMatch_SetSettings::_internal_aimassist() const {
  return _impl_.aimassist_;
}
inline bool CustomMatch_SetSettings::aimassist() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.aimAssist)
  return _internal_aimassist();
}
inline void CustomMatch_SetSettings::_internal_set_aimassist(bool value) {
  
  _impl_.aimassist_ = value;
}
inline void CustomMatch_SetSettings::set_aimassist(bool value) {
  _internal_set_aimassist(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.aimAssist)
}

// bool anonMode = 6;
inline void CustomMatch_SetSettings::clear_anonmode() {
  _impl_.anonmode_ = false;
}
inline bool CustomMatch_SetSettings::_internal_anonmode() const {
  return _impl_.anonmode_;
}
inline bool CustomMatch_SetSettings::anonmode() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetSettings.anonMode)
  return _internal_anonmode();
}
inline void CustomMatch_SetSettings::_internal_set_anonmode(bool value) {
  
  _impl_.anonmode_ = value;
}
inline void CustomMatch_SetSettings::set_anonmode(bool value) {
  _internal_set_anonmode(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetSettings.anonMode)
}

// -------------------------------------------------------------------

// CustomMatch_GetSettings

// -------------------------------------------------------------------

// CustomMatch_SetTeamName

// int32 teamId = 1;
inline void CustomMatch_SetTeamName::clear_teamid() {
  _impl_.teamid_ = 0;
}
inline int32_t CustomMatch_SetTeamName::_internal_teamid() const {
  return _impl_.teamid_;
}
inline int32_t CustomMatch_SetTeamName::teamid() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeamName.teamId)
  return _internal_teamid();
}
inline void CustomMatch_SetTeamName::_internal_set_teamid(int32_t value) {
  
  _impl_.teamid_ = value;
}
inline void CustomMatch_SetTeamName::set_teamid(int32_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeamName.teamId)
}

// string teamName = 2;
inline void CustomMatch_SetTeamName::clear_teamname() {
  _impl_.teamname_.ClearToEmpty();
}
inline const std::string& CustomMatch_SetTeamName::teamname() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SetTeamName.teamName)
  return _internal_teamname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_SetTeamName::set_teamname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.teamname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SetTeamName.teamName)
}
inline std::string* CustomMatch_SetTeamName::mutable_teamname() {
  std::string* _s = _internal_mutable_teamname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SetTeamName.teamName)
  return _s;
}
inline const std::string& CustomMatch_SetTeamName::_internal_teamname() const {
  return _impl_.teamname_.Get();
}
inline void CustomMatch_SetTeamName::_internal_set_teamname(const std::string& value) {
  
  _impl_.teamname_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_SetTeamName::_internal_mutable_teamname() {
  
  return _impl_.teamname_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_SetTeamName::release_teamname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SetTeamName.teamName)
  return _impl_.teamname_.Release();
}
inline void CustomMatch_SetTeamName::set_allocated_teamname(std::string* teamname) {
  if (teamname != nullptr) {
    
  } else {
    
  }
  _impl_.teamname_.SetAllocated(teamname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.teamname_.IsDefault()) {
    _impl_.teamname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SetTeamName.teamName)
}

// -------------------------------------------------------------------

// CustomMatch_SendChat

// string text = 1;
inline void CustomMatch_SendChat::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& CustomMatch_SendChat::text() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.CustomMatch_SendChat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomMatch_SendChat::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.CustomMatch_SendChat.text)
}
inline std::string* CustomMatch_SendChat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.CustomMatch_SendChat.text)
  return _s;
}
inline const std::string& CustomMatch_SendChat::_internal_text() const {
  return _impl_.text_.Get();
}
inline void CustomMatch_SendChat::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMatch_SendChat::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomMatch_SendChat::release_text() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.CustomMatch_SendChat.text)
  return _impl_.text_.Release();
}
inline void CustomMatch_SendChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.CustomMatch_SendChat.text)
}

// -------------------------------------------------------------------

// Request

// bool withAck = 1;
inline void Request::clear_withack() {
  _impl_.withack_ = false;
}
inline bool Request::_internal_withack() const {
  return _impl_.withack_;
}
inline bool Request::withack() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.withAck)
  return _internal_withack();
}
inline void Request::_internal_set_withack(bool value) {
  
  _impl_.withack_ = value;
}
inline void Request::set_withack(bool value) {
  _internal_set_withack(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Request.withAck)
}

// string preSharedKey = 2;
inline void Request::clear_presharedkey() {
  _impl_.presharedkey_.ClearToEmpty();
}
inline const std::string& Request::presharedkey() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.preSharedKey)
  return _internal_presharedkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_presharedkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.presharedkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.Request.preSharedKey)
}
inline std::string* Request::mutable_presharedkey() {
  std::string* _s = _internal_mutable_presharedkey();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.preSharedKey)
  return _s;
}
inline const std::string& Request::_internal_presharedkey() const {
  return _impl_.presharedkey_.Get();
}
inline void Request::_internal_set_presharedkey(const std::string& value) {
  
  _impl_.presharedkey_.Set(value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_presharedkey() {
  
  return _impl_.presharedkey_.Mutable(GetArenaForAllocation());
}
inline std::string* Request::release_presharedkey() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.preSharedKey)
  return _impl_.presharedkey_.Release();
}
inline void Request::set_allocated_presharedkey(std::string* presharedkey) {
  if (presharedkey != nullptr) {
    
  } else {
    
  }
  _impl_.presharedkey_.SetAllocated(presharedkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.presharedkey_.IsDefault()) {
    _impl_.presharedkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Request.preSharedKey)
}

// .rtech.liveapi.ChangeCamera changeCam = 4;
inline bool Request::_internal_has_changecam() const {
  return actions_case() == kChangeCam;
}
inline bool Request::has_changecam() const {
  return _internal_has_changecam();
}
inline void Request::set_has_changecam() {
  _impl_._oneof_case_[0] = kChangeCam;
}
inline void Request::clear_changecam() {
  if (_internal_has_changecam()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.changecam_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::ChangeCamera* Request::release_changecam() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.changeCam)
  if (_internal_has_changecam()) {
    clear_has_actions();
    ::rtech::liveapi::ChangeCamera* temp = _impl_.actions_.changecam_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.changecam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::ChangeCamera& Request::_internal_changecam() const {
  return _internal_has_changecam()
      ? *_impl_.actions_.changecam_
      : reinterpret_cast< ::rtech::liveapi::ChangeCamera&>(::rtech::liveapi::_ChangeCamera_default_instance_);
}
inline const ::rtech::liveapi::ChangeCamera& Request::changecam() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.changeCam)
  return _internal_changecam();
}
inline ::rtech::liveapi::ChangeCamera* Request::unsafe_arena_release_changecam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.changeCam)
  if (_internal_has_changecam()) {
    clear_has_actions();
    ::rtech::liveapi::ChangeCamera* temp = _impl_.actions_.changecam_;
    _impl_.actions_.changecam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_changecam(::rtech::liveapi::ChangeCamera* changecam) {
  clear_actions();
  if (changecam) {
    set_has_changecam();
    _impl_.actions_.changecam_ = changecam;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.changeCam)
}
inline ::rtech::liveapi::ChangeCamera* Request::_internal_mutable_changecam() {
  if (!_internal_has_changecam()) {
    clear_actions();
    set_has_changecam();
    _impl_.actions_.changecam_ = CreateMaybeMessage< ::rtech::liveapi::ChangeCamera >(GetArenaForAllocation());
  }
  return _impl_.actions_.changecam_;
}
inline ::rtech::liveapi::ChangeCamera* Request::mutable_changecam() {
  ::rtech::liveapi::ChangeCamera* _msg = _internal_mutable_changecam();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.changeCam)
  return _msg;
}

// .rtech.liveapi.PauseToggle pauseToggle = 5;
inline bool Request::_internal_has_pausetoggle() const {
  return actions_case() == kPauseToggle;
}
inline bool Request::has_pausetoggle() const {
  return _internal_has_pausetoggle();
}
inline void Request::set_has_pausetoggle() {
  _impl_._oneof_case_[0] = kPauseToggle;
}
inline void Request::clear_pausetoggle() {
  if (_internal_has_pausetoggle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.pausetoggle_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::PauseToggle* Request::release_pausetoggle() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.pauseToggle)
  if (_internal_has_pausetoggle()) {
    clear_has_actions();
    ::rtech::liveapi::PauseToggle* temp = _impl_.actions_.pausetoggle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.pausetoggle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::PauseToggle& Request::_internal_pausetoggle() const {
  return _internal_has_pausetoggle()
      ? *_impl_.actions_.pausetoggle_
      : reinterpret_cast< ::rtech::liveapi::PauseToggle&>(::rtech::liveapi::_PauseToggle_default_instance_);
}
inline const ::rtech::liveapi::PauseToggle& Request::pausetoggle() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.pauseToggle)
  return _internal_pausetoggle();
}
inline ::rtech::liveapi::PauseToggle* Request::unsafe_arena_release_pausetoggle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.pauseToggle)
  if (_internal_has_pausetoggle()) {
    clear_has_actions();
    ::rtech::liveapi::PauseToggle* temp = _impl_.actions_.pausetoggle_;
    _impl_.actions_.pausetoggle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_pausetoggle(::rtech::liveapi::PauseToggle* pausetoggle) {
  clear_actions();
  if (pausetoggle) {
    set_has_pausetoggle();
    _impl_.actions_.pausetoggle_ = pausetoggle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.pauseToggle)
}
inline ::rtech::liveapi::PauseToggle* Request::_internal_mutable_pausetoggle() {
  if (!_internal_has_pausetoggle()) {
    clear_actions();
    set_has_pausetoggle();
    _impl_.actions_.pausetoggle_ = CreateMaybeMessage< ::rtech::liveapi::PauseToggle >(GetArenaForAllocation());
  }
  return _impl_.actions_.pausetoggle_;
}
inline ::rtech::liveapi::PauseToggle* Request::mutable_pausetoggle() {
  ::rtech::liveapi::PauseToggle* _msg = _internal_mutable_pausetoggle();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.pauseToggle)
  return _msg;
}

// .rtech.liveapi.CustomMatch_CreateLobby customMatch_CreateLobby = 10;
inline bool Request::_internal_has_custommatch_createlobby() const {
  return actions_case() == kCustomMatchCreateLobby;
}
inline bool Request::has_custommatch_createlobby() const {
  return _internal_has_custommatch_createlobby();
}
inline void Request::set_has_custommatch_createlobby() {
  _impl_._oneof_case_[0] = kCustomMatchCreateLobby;
}
inline void Request::clear_custommatch_createlobby() {
  if (_internal_has_custommatch_createlobby()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_createlobby_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::release_custommatch_createlobby() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_CreateLobby)
  if (_internal_has_custommatch_createlobby()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_CreateLobby* temp = _impl_.actions_.custommatch_createlobby_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_createlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_CreateLobby& Request::_internal_custommatch_createlobby() const {
  return _internal_has_custommatch_createlobby()
      ? *_impl_.actions_.custommatch_createlobby_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_CreateLobby&>(::rtech::liveapi::_CustomMatch_CreateLobby_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_CreateLobby& Request::custommatch_createlobby() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_CreateLobby)
  return _internal_custommatch_createlobby();
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::unsafe_arena_release_custommatch_createlobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_CreateLobby)
  if (_internal_has_custommatch_createlobby()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_CreateLobby* temp = _impl_.actions_.custommatch_createlobby_;
    _impl_.actions_.custommatch_createlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_createlobby(::rtech::liveapi::CustomMatch_CreateLobby* custommatch_createlobby) {
  clear_actions();
  if (custommatch_createlobby) {
    set_has_custommatch_createlobby();
    _impl_.actions_.custommatch_createlobby_ = custommatch_createlobby;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_CreateLobby)
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::_internal_mutable_custommatch_createlobby() {
  if (!_internal_has_custommatch_createlobby()) {
    clear_actions();
    set_has_custommatch_createlobby();
    _impl_.actions_.custommatch_createlobby_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_CreateLobby >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_createlobby_;
}
inline ::rtech::liveapi::CustomMatch_CreateLobby* Request::mutable_custommatch_createlobby() {
  ::rtech::liveapi::CustomMatch_CreateLobby* _msg = _internal_mutable_custommatch_createlobby();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_CreateLobby)
  return _msg;
}

// .rtech.liveapi.CustomMatch_JoinLobby customMatch_JoinLobby = 11;
inline bool Request::_internal_has_custommatch_joinlobby() const {
  return actions_case() == kCustomMatchJoinLobby;
}
inline bool Request::has_custommatch_joinlobby() const {
  return _internal_has_custommatch_joinlobby();
}
inline void Request::set_has_custommatch_joinlobby() {
  _impl_._oneof_case_[0] = kCustomMatchJoinLobby;
}
inline void Request::clear_custommatch_joinlobby() {
  if (_internal_has_custommatch_joinlobby()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_joinlobby_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::release_custommatch_joinlobby() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_JoinLobby)
  if (_internal_has_custommatch_joinlobby()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_JoinLobby* temp = _impl_.actions_.custommatch_joinlobby_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_joinlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_JoinLobby& Request::_internal_custommatch_joinlobby() const {
  return _internal_has_custommatch_joinlobby()
      ? *_impl_.actions_.custommatch_joinlobby_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_JoinLobby&>(::rtech::liveapi::_CustomMatch_JoinLobby_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_JoinLobby& Request::custommatch_joinlobby() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_JoinLobby)
  return _internal_custommatch_joinlobby();
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::unsafe_arena_release_custommatch_joinlobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_JoinLobby)
  if (_internal_has_custommatch_joinlobby()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_JoinLobby* temp = _impl_.actions_.custommatch_joinlobby_;
    _impl_.actions_.custommatch_joinlobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_joinlobby(::rtech::liveapi::CustomMatch_JoinLobby* custommatch_joinlobby) {
  clear_actions();
  if (custommatch_joinlobby) {
    set_has_custommatch_joinlobby();
    _impl_.actions_.custommatch_joinlobby_ = custommatch_joinlobby;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_JoinLobby)
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::_internal_mutable_custommatch_joinlobby() {
  if (!_internal_has_custommatch_joinlobby()) {
    clear_actions();
    set_has_custommatch_joinlobby();
    _impl_.actions_.custommatch_joinlobby_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_JoinLobby >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_joinlobby_;
}
inline ::rtech::liveapi::CustomMatch_JoinLobby* Request::mutable_custommatch_joinlobby() {
  ::rtech::liveapi::CustomMatch_JoinLobby* _msg = _internal_mutable_custommatch_joinlobby();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_JoinLobby)
  return _msg;
}

// .rtech.liveapi.CustomMatch_LeaveLobby customMatch_LeaveLobby = 12;
inline bool Request::_internal_has_custommatch_leavelobby() const {
  return actions_case() == kCustomMatchLeaveLobby;
}
inline bool Request::has_custommatch_leavelobby() const {
  return _internal_has_custommatch_leavelobby();
}
inline void Request::set_has_custommatch_leavelobby() {
  _impl_._oneof_case_[0] = kCustomMatchLeaveLobby;
}
inline void Request::clear_custommatch_leavelobby() {
  if (_internal_has_custommatch_leavelobby()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_leavelobby_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::release_custommatch_leavelobby() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_LeaveLobby)
  if (_internal_has_custommatch_leavelobby()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_LeaveLobby* temp = _impl_.actions_.custommatch_leavelobby_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_leavelobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_LeaveLobby& Request::_internal_custommatch_leavelobby() const {
  return _internal_has_custommatch_leavelobby()
      ? *_impl_.actions_.custommatch_leavelobby_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_LeaveLobby&>(::rtech::liveapi::_CustomMatch_LeaveLobby_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_LeaveLobby& Request::custommatch_leavelobby() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_LeaveLobby)
  return _internal_custommatch_leavelobby();
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::unsafe_arena_release_custommatch_leavelobby() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_LeaveLobby)
  if (_internal_has_custommatch_leavelobby()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_LeaveLobby* temp = _impl_.actions_.custommatch_leavelobby_;
    _impl_.actions_.custommatch_leavelobby_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_leavelobby(::rtech::liveapi::CustomMatch_LeaveLobby* custommatch_leavelobby) {
  clear_actions();
  if (custommatch_leavelobby) {
    set_has_custommatch_leavelobby();
    _impl_.actions_.custommatch_leavelobby_ = custommatch_leavelobby;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_LeaveLobby)
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::_internal_mutable_custommatch_leavelobby() {
  if (!_internal_has_custommatch_leavelobby()) {
    clear_actions();
    set_has_custommatch_leavelobby();
    _impl_.actions_.custommatch_leavelobby_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_LeaveLobby >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_leavelobby_;
}
inline ::rtech::liveapi::CustomMatch_LeaveLobby* Request::mutable_custommatch_leavelobby() {
  ::rtech::liveapi::CustomMatch_LeaveLobby* _msg = _internal_mutable_custommatch_leavelobby();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_LeaveLobby)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetReady customMatch_SetReady = 13;
inline bool Request::_internal_has_custommatch_setready() const {
  return actions_case() == kCustomMatchSetReady;
}
inline bool Request::has_custommatch_setready() const {
  return _internal_has_custommatch_setready();
}
inline void Request::set_has_custommatch_setready() {
  _impl_._oneof_case_[0] = kCustomMatchSetReady;
}
inline void Request::clear_custommatch_setready() {
  if (_internal_has_custommatch_setready()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_setready_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::release_custommatch_setready() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetReady)
  if (_internal_has_custommatch_setready()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetReady* temp = _impl_.actions_.custommatch_setready_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetReady& Request::_internal_custommatch_setready() const {
  return _internal_has_custommatch_setready()
      ? *_impl_.actions_.custommatch_setready_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_SetReady&>(::rtech::liveapi::_CustomMatch_SetReady_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetReady& Request::custommatch_setready() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetReady)
  return _internal_custommatch_setready();
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::unsafe_arena_release_custommatch_setready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetReady)
  if (_internal_has_custommatch_setready()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetReady* temp = _impl_.actions_.custommatch_setready_;
    _impl_.actions_.custommatch_setready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setready(::rtech::liveapi::CustomMatch_SetReady* custommatch_setready) {
  clear_actions();
  if (custommatch_setready) {
    set_has_custommatch_setready();
    _impl_.actions_.custommatch_setready_ = custommatch_setready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetReady)
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::_internal_mutable_custommatch_setready() {
  if (!_internal_has_custommatch_setready()) {
    clear_actions();
    set_has_custommatch_setready();
    _impl_.actions_.custommatch_setready_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_SetReady >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_setready_;
}
inline ::rtech::liveapi::CustomMatch_SetReady* Request::mutable_custommatch_setready() {
  ::rtech::liveapi::CustomMatch_SetReady* _msg = _internal_mutable_custommatch_setready();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetReady)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetMatchmaking customMatch_SetMatchmaking = 14;
inline bool Request::_internal_has_custommatch_setmatchmaking() const {
  return actions_case() == kCustomMatchSetMatchmaking;
}
inline bool Request::has_custommatch_setmatchmaking() const {
  return _internal_has_custommatch_setmatchmaking();
}
inline void Request::set_has_custommatch_setmatchmaking() {
  _impl_._oneof_case_[0] = kCustomMatchSetMatchmaking;
}
inline void Request::clear_custommatch_setmatchmaking() {
  if (_internal_has_custommatch_setmatchmaking()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_setmatchmaking_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::release_custommatch_setmatchmaking() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetMatchmaking)
  if (_internal_has_custommatch_setmatchmaking()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetMatchmaking* temp = _impl_.actions_.custommatch_setmatchmaking_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setmatchmaking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetMatchmaking& Request::_internal_custommatch_setmatchmaking() const {
  return _internal_has_custommatch_setmatchmaking()
      ? *_impl_.actions_.custommatch_setmatchmaking_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_SetMatchmaking&>(::rtech::liveapi::_CustomMatch_SetMatchmaking_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetMatchmaking& Request::custommatch_setmatchmaking() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetMatchmaking)
  return _internal_custommatch_setmatchmaking();
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::unsafe_arena_release_custommatch_setmatchmaking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetMatchmaking)
  if (_internal_has_custommatch_setmatchmaking()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetMatchmaking* temp = _impl_.actions_.custommatch_setmatchmaking_;
    _impl_.actions_.custommatch_setmatchmaking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setmatchmaking(::rtech::liveapi::CustomMatch_SetMatchmaking* custommatch_setmatchmaking) {
  clear_actions();
  if (custommatch_setmatchmaking) {
    set_has_custommatch_setmatchmaking();
    _impl_.actions_.custommatch_setmatchmaking_ = custommatch_setmatchmaking;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetMatchmaking)
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::_internal_mutable_custommatch_setmatchmaking() {
  if (!_internal_has_custommatch_setmatchmaking()) {
    clear_actions();
    set_has_custommatch_setmatchmaking();
    _impl_.actions_.custommatch_setmatchmaking_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_SetMatchmaking >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_setmatchmaking_;
}
inline ::rtech::liveapi::CustomMatch_SetMatchmaking* Request::mutable_custommatch_setmatchmaking() {
  ::rtech::liveapi::CustomMatch_SetMatchmaking* _msg = _internal_mutable_custommatch_setmatchmaking();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetMatchmaking)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetTeam customMatch_SetTeam = 15;
inline bool Request::_internal_has_custommatch_setteam() const {
  return actions_case() == kCustomMatchSetTeam;
}
inline bool Request::has_custommatch_setteam() const {
  return _internal_has_custommatch_setteam();
}
inline void Request::set_has_custommatch_setteam() {
  _impl_._oneof_case_[0] = kCustomMatchSetTeam;
}
inline void Request::clear_custommatch_setteam() {
  if (_internal_has_custommatch_setteam()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_setteam_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::release_custommatch_setteam() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetTeam)
  if (_internal_has_custommatch_setteam()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetTeam* temp = _impl_.actions_.custommatch_setteam_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setteam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetTeam& Request::_internal_custommatch_setteam() const {
  return _internal_has_custommatch_setteam()
      ? *_impl_.actions_.custommatch_setteam_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_SetTeam&>(::rtech::liveapi::_CustomMatch_SetTeam_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetTeam& Request::custommatch_setteam() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetTeam)
  return _internal_custommatch_setteam();
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::unsafe_arena_release_custommatch_setteam() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetTeam)
  if (_internal_has_custommatch_setteam()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetTeam* temp = _impl_.actions_.custommatch_setteam_;
    _impl_.actions_.custommatch_setteam_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setteam(::rtech::liveapi::CustomMatch_SetTeam* custommatch_setteam) {
  clear_actions();
  if (custommatch_setteam) {
    set_has_custommatch_setteam();
    _impl_.actions_.custommatch_setteam_ = custommatch_setteam;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetTeam)
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::_internal_mutable_custommatch_setteam() {
  if (!_internal_has_custommatch_setteam()) {
    clear_actions();
    set_has_custommatch_setteam();
    _impl_.actions_.custommatch_setteam_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_SetTeam >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_setteam_;
}
inline ::rtech::liveapi::CustomMatch_SetTeam* Request::mutable_custommatch_setteam() {
  ::rtech::liveapi::CustomMatch_SetTeam* _msg = _internal_mutable_custommatch_setteam();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetTeam)
  return _msg;
}

// .rtech.liveapi.CustomMatch_KickPlayer customMatch_KickPlayer = 16;
inline bool Request::_internal_has_custommatch_kickplayer() const {
  return actions_case() == kCustomMatchKickPlayer;
}
inline bool Request::has_custommatch_kickplayer() const {
  return _internal_has_custommatch_kickplayer();
}
inline void Request::set_has_custommatch_kickplayer() {
  _impl_._oneof_case_[0] = kCustomMatchKickPlayer;
}
inline void Request::clear_custommatch_kickplayer() {
  if (_internal_has_custommatch_kickplayer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_kickplayer_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::release_custommatch_kickplayer() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_KickPlayer)
  if (_internal_has_custommatch_kickplayer()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_KickPlayer* temp = _impl_.actions_.custommatch_kickplayer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_kickplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_KickPlayer& Request::_internal_custommatch_kickplayer() const {
  return _internal_has_custommatch_kickplayer()
      ? *_impl_.actions_.custommatch_kickplayer_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_KickPlayer&>(::rtech::liveapi::_CustomMatch_KickPlayer_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_KickPlayer& Request::custommatch_kickplayer() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_KickPlayer)
  return _internal_custommatch_kickplayer();
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::unsafe_arena_release_custommatch_kickplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_KickPlayer)
  if (_internal_has_custommatch_kickplayer()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_KickPlayer* temp = _impl_.actions_.custommatch_kickplayer_;
    _impl_.actions_.custommatch_kickplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_kickplayer(::rtech::liveapi::CustomMatch_KickPlayer* custommatch_kickplayer) {
  clear_actions();
  if (custommatch_kickplayer) {
    set_has_custommatch_kickplayer();
    _impl_.actions_.custommatch_kickplayer_ = custommatch_kickplayer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_KickPlayer)
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::_internal_mutable_custommatch_kickplayer() {
  if (!_internal_has_custommatch_kickplayer()) {
    clear_actions();
    set_has_custommatch_kickplayer();
    _impl_.actions_.custommatch_kickplayer_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_KickPlayer >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_kickplayer_;
}
inline ::rtech::liveapi::CustomMatch_KickPlayer* Request::mutable_custommatch_kickplayer() {
  ::rtech::liveapi::CustomMatch_KickPlayer* _msg = _internal_mutable_custommatch_kickplayer();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_KickPlayer)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetSettings customMatch_SetSettings = 17;
inline bool Request::_internal_has_custommatch_setsettings() const {
  return actions_case() == kCustomMatchSetSettings;
}
inline bool Request::has_custommatch_setsettings() const {
  return _internal_has_custommatch_setsettings();
}
inline void Request::set_has_custommatch_setsettings() {
  _impl_._oneof_case_[0] = kCustomMatchSetSettings;
}
inline void Request::clear_custommatch_setsettings() {
  if (_internal_has_custommatch_setsettings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_setsettings_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::release_custommatch_setsettings() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetSettings)
  if (_internal_has_custommatch_setsettings()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetSettings* temp = _impl_.actions_.custommatch_setsettings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetSettings& Request::_internal_custommatch_setsettings() const {
  return _internal_has_custommatch_setsettings()
      ? *_impl_.actions_.custommatch_setsettings_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_SetSettings&>(::rtech::liveapi::_CustomMatch_SetSettings_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetSettings& Request::custommatch_setsettings() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetSettings)
  return _internal_custommatch_setsettings();
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::unsafe_arena_release_custommatch_setsettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetSettings)
  if (_internal_has_custommatch_setsettings()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetSettings* temp = _impl_.actions_.custommatch_setsettings_;
    _impl_.actions_.custommatch_setsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setsettings(::rtech::liveapi::CustomMatch_SetSettings* custommatch_setsettings) {
  clear_actions();
  if (custommatch_setsettings) {
    set_has_custommatch_setsettings();
    _impl_.actions_.custommatch_setsettings_ = custommatch_setsettings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetSettings)
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::_internal_mutable_custommatch_setsettings() {
  if (!_internal_has_custommatch_setsettings()) {
    clear_actions();
    set_has_custommatch_setsettings();
    _impl_.actions_.custommatch_setsettings_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_SetSettings >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_setsettings_;
}
inline ::rtech::liveapi::CustomMatch_SetSettings* Request::mutable_custommatch_setsettings() {
  ::rtech::liveapi::CustomMatch_SetSettings* _msg = _internal_mutable_custommatch_setsettings();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetSettings)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SendChat customMatch_SendChat = 18;
inline bool Request::_internal_has_custommatch_sendchat() const {
  return actions_case() == kCustomMatchSendChat;
}
inline bool Request::has_custommatch_sendchat() const {
  return _internal_has_custommatch_sendchat();
}
inline void Request::set_has_custommatch_sendchat() {
  _impl_._oneof_case_[0] = kCustomMatchSendChat;
}
inline void Request::clear_custommatch_sendchat() {
  if (_internal_has_custommatch_sendchat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_sendchat_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::release_custommatch_sendchat() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SendChat)
  if (_internal_has_custommatch_sendchat()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SendChat* temp = _impl_.actions_.custommatch_sendchat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_sendchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SendChat& Request::_internal_custommatch_sendchat() const {
  return _internal_has_custommatch_sendchat()
      ? *_impl_.actions_.custommatch_sendchat_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_SendChat&>(::rtech::liveapi::_CustomMatch_SendChat_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SendChat& Request::custommatch_sendchat() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SendChat)
  return _internal_custommatch_sendchat();
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::unsafe_arena_release_custommatch_sendchat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SendChat)
  if (_internal_has_custommatch_sendchat()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SendChat* temp = _impl_.actions_.custommatch_sendchat_;
    _impl_.actions_.custommatch_sendchat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_sendchat(::rtech::liveapi::CustomMatch_SendChat* custommatch_sendchat) {
  clear_actions();
  if (custommatch_sendchat) {
    set_has_custommatch_sendchat();
    _impl_.actions_.custommatch_sendchat_ = custommatch_sendchat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SendChat)
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::_internal_mutable_custommatch_sendchat() {
  if (!_internal_has_custommatch_sendchat()) {
    clear_actions();
    set_has_custommatch_sendchat();
    _impl_.actions_.custommatch_sendchat_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_SendChat >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_sendchat_;
}
inline ::rtech::liveapi::CustomMatch_SendChat* Request::mutable_custommatch_sendchat() {
  ::rtech::liveapi::CustomMatch_SendChat* _msg = _internal_mutable_custommatch_sendchat();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SendChat)
  return _msg;
}

// .rtech.liveapi.CustomMatch_GetLobbyPlayers customMatch_GetLobbyPlayers = 19;
inline bool Request::_internal_has_custommatch_getlobbyplayers() const {
  return actions_case() == kCustomMatchGetLobbyPlayers;
}
inline bool Request::has_custommatch_getlobbyplayers() const {
  return _internal_has_custommatch_getlobbyplayers();
}
inline void Request::set_has_custommatch_getlobbyplayers() {
  _impl_._oneof_case_[0] = kCustomMatchGetLobbyPlayers;
}
inline void Request::clear_custommatch_getlobbyplayers() {
  if (_internal_has_custommatch_getlobbyplayers()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_getlobbyplayers_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::release_custommatch_getlobbyplayers() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  if (_internal_has_custommatch_getlobbyplayers()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_GetLobbyPlayers* temp = _impl_.actions_.custommatch_getlobbyplayers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_getlobbyplayers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& Request::_internal_custommatch_getlobbyplayers() const {
  return _internal_has_custommatch_getlobbyplayers()
      ? *_impl_.actions_.custommatch_getlobbyplayers_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_GetLobbyPlayers&>(::rtech::liveapi::_CustomMatch_GetLobbyPlayers_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_GetLobbyPlayers& Request::custommatch_getlobbyplayers() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  return _internal_custommatch_getlobbyplayers();
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::unsafe_arena_release_custommatch_getlobbyplayers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  if (_internal_has_custommatch_getlobbyplayers()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_GetLobbyPlayers* temp = _impl_.actions_.custommatch_getlobbyplayers_;
    _impl_.actions_.custommatch_getlobbyplayers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_getlobbyplayers(::rtech::liveapi::CustomMatch_GetLobbyPlayers* custommatch_getlobbyplayers) {
  clear_actions();
  if (custommatch_getlobbyplayers) {
    set_has_custommatch_getlobbyplayers();
    _impl_.actions_.custommatch_getlobbyplayers_ = custommatch_getlobbyplayers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::_internal_mutable_custommatch_getlobbyplayers() {
  if (!_internal_has_custommatch_getlobbyplayers()) {
    clear_actions();
    set_has_custommatch_getlobbyplayers();
    _impl_.actions_.custommatch_getlobbyplayers_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_GetLobbyPlayers >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_getlobbyplayers_;
}
inline ::rtech::liveapi::CustomMatch_GetLobbyPlayers* Request::mutable_custommatch_getlobbyplayers() {
  ::rtech::liveapi::CustomMatch_GetLobbyPlayers* _msg = _internal_mutable_custommatch_getlobbyplayers();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_GetLobbyPlayers)
  return _msg;
}

// .rtech.liveapi.CustomMatch_SetTeamName customMatch_SetTeamName = 20;
inline bool Request::_internal_has_custommatch_setteamname() const {
  return actions_case() == kCustomMatchSetTeamName;
}
inline bool Request::has_custommatch_setteamname() const {
  return _internal_has_custommatch_setteamname();
}
inline void Request::set_has_custommatch_setteamname() {
  _impl_._oneof_case_[0] = kCustomMatchSetTeamName;
}
inline void Request::clear_custommatch_setteamname() {
  if (_internal_has_custommatch_setteamname()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_setteamname_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::release_custommatch_setteamname() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_SetTeamName)
  if (_internal_has_custommatch_setteamname()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetTeamName* temp = _impl_.actions_.custommatch_setteamname_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_setteamname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_SetTeamName& Request::_internal_custommatch_setteamname() const {
  return _internal_has_custommatch_setteamname()
      ? *_impl_.actions_.custommatch_setteamname_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_SetTeamName&>(::rtech::liveapi::_CustomMatch_SetTeamName_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_SetTeamName& Request::custommatch_setteamname() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_SetTeamName)
  return _internal_custommatch_setteamname();
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::unsafe_arena_release_custommatch_setteamname() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_SetTeamName)
  if (_internal_has_custommatch_setteamname()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_SetTeamName* temp = _impl_.actions_.custommatch_setteamname_;
    _impl_.actions_.custommatch_setteamname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_setteamname(::rtech::liveapi::CustomMatch_SetTeamName* custommatch_setteamname) {
  clear_actions();
  if (custommatch_setteamname) {
    set_has_custommatch_setteamname();
    _impl_.actions_.custommatch_setteamname_ = custommatch_setteamname;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_SetTeamName)
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::_internal_mutable_custommatch_setteamname() {
  if (!_internal_has_custommatch_setteamname()) {
    clear_actions();
    set_has_custommatch_setteamname();
    _impl_.actions_.custommatch_setteamname_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_SetTeamName >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_setteamname_;
}
inline ::rtech::liveapi::CustomMatch_SetTeamName* Request::mutable_custommatch_setteamname() {
  ::rtech::liveapi::CustomMatch_SetTeamName* _msg = _internal_mutable_custommatch_setteamname();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_SetTeamName)
  return _msg;
}

// .rtech.liveapi.CustomMatch_GetSettings customMatch_GetSettings = 21;
inline bool Request::_internal_has_custommatch_getsettings() const {
  return actions_case() == kCustomMatchGetSettings;
}
inline bool Request::has_custommatch_getsettings() const {
  return _internal_has_custommatch_getsettings();
}
inline void Request::set_has_custommatch_getsettings() {
  _impl_._oneof_case_[0] = kCustomMatchGetSettings;
}
inline void Request::clear_custommatch_getsettings() {
  if (_internal_has_custommatch_getsettings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.actions_.custommatch_getsettings_;
    }
    clear_has_actions();
  }
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::release_custommatch_getsettings() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Request.customMatch_GetSettings)
  if (_internal_has_custommatch_getsettings()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_GetSettings* temp = _impl_.actions_.custommatch_getsettings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.actions_.custommatch_getsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rtech::liveapi::CustomMatch_GetSettings& Request::_internal_custommatch_getsettings() const {
  return _internal_has_custommatch_getsettings()
      ? *_impl_.actions_.custommatch_getsettings_
      : reinterpret_cast< ::rtech::liveapi::CustomMatch_GetSettings&>(::rtech::liveapi::_CustomMatch_GetSettings_default_instance_);
}
inline const ::rtech::liveapi::CustomMatch_GetSettings& Request::custommatch_getsettings() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Request.customMatch_GetSettings)
  return _internal_custommatch_getsettings();
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::unsafe_arena_release_custommatch_getsettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rtech.liveapi.Request.customMatch_GetSettings)
  if (_internal_has_custommatch_getsettings()) {
    clear_has_actions();
    ::rtech::liveapi::CustomMatch_GetSettings* temp = _impl_.actions_.custommatch_getsettings_;
    _impl_.actions_.custommatch_getsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_custommatch_getsettings(::rtech::liveapi::CustomMatch_GetSettings* custommatch_getsettings) {
  clear_actions();
  if (custommatch_getsettings) {
    set_has_custommatch_getsettings();
    _impl_.actions_.custommatch_getsettings_ = custommatch_getsettings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Request.customMatch_GetSettings)
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::_internal_mutable_custommatch_getsettings() {
  if (!_internal_has_custommatch_getsettings()) {
    clear_actions();
    set_has_custommatch_getsettings();
    _impl_.actions_.custommatch_getsettings_ = CreateMaybeMessage< ::rtech::liveapi::CustomMatch_GetSettings >(GetArenaForAllocation());
  }
  return _impl_.actions_.custommatch_getsettings_;
}
inline ::rtech::liveapi::CustomMatch_GetSettings* Request::mutable_custommatch_getsettings() {
  ::rtech::liveapi::CustomMatch_GetSettings* _msg = _internal_mutable_custommatch_getsettings();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Request.customMatch_GetSettings)
  return _msg;
}

inline bool Request::has_actions() const {
  return actions_case() != ACTIONS_NOT_SET;
}
inline void Request::clear_has_actions() {
  _impl_._oneof_case_[0] = ACTIONS_NOT_SET;
}
inline Request::ActionsCase Request::actions_case() const {
  return Request::ActionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestStatus

// string status = 1;
inline void RequestStatus::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& RequestStatus::status() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.RequestStatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestStatus::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rtech.liveapi.RequestStatus.status)
}
inline std::string* RequestStatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.RequestStatus.status)
  return _s;
}
inline const std::string& RequestStatus::_internal_status() const {
  return _impl_.status_.Get();
}
inline void RequestStatus::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestStatus::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestStatus::release_status() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.RequestStatus.status)
  return _impl_.status_.Release();
}
inline void RequestStatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.RequestStatus.status)
}

// -------------------------------------------------------------------

// Response

// bool success = 1;
inline void Response::clear_success() {
  _impl_.success_ = false;
}
inline bool Response::_internal_success() const {
  return _impl_.success_;
}
inline bool Response::success() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Response.success)
  return _internal_success();
}
inline void Response::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void Response::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.Response.success)
}

// .google.protobuf.Any result = 2;
inline bool Response::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool Response::has_result() const {
  return _internal_has_result();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Response::_internal_result() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Response::result() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.Response.result)
  return _internal_result();
}
inline void Response::unsafe_arena_set_allocated_result(
    ::PROTOBUF_NAMESPACE_ID::Any* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.Response.result)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Response::release_result() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Response::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.Response.result)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Response::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Response::mutable_result() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.Response.result)
  return _msg;
}
inline void Response::set_allocated_result(::PROTOBUF_NAMESPACE_ID::Any* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.Response.result)
}

// -------------------------------------------------------------------

// LiveAPIEvent

// fixed32 event_size = 1;
inline void LiveAPIEvent::clear_event_size() {
  _impl_.event_size_ = 0u;
}
inline uint32_t LiveAPIEvent::_internal_event_size() const {
  return _impl_.event_size_;
}
inline uint32_t LiveAPIEvent::event_size() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LiveAPIEvent.event_size)
  return _internal_event_size();
}
inline void LiveAPIEvent::_internal_set_event_size(uint32_t value) {
  
  _impl_.event_size_ = value;
}
inline void LiveAPIEvent::set_event_size(uint32_t value) {
  _internal_set_event_size(value);
  // @@protoc_insertion_point(field_set:rtech.liveapi.LiveAPIEvent.event_size)
}

// .google.protobuf.Any gameMessage = 3;
inline bool LiveAPIEvent::_internal_has_gamemessage() const {
  return this != internal_default_instance() && _impl_.gamemessage_ != nullptr;
}
inline bool LiveAPIEvent::has_gamemessage() const {
  return _internal_has_gamemessage();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& LiveAPIEvent::_internal_gamemessage() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.gamemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& LiveAPIEvent::gamemessage() const {
  // @@protoc_insertion_point(field_get:rtech.liveapi.LiveAPIEvent.gameMessage)
  return _internal_gamemessage();
}
inline void LiveAPIEvent::unsafe_arena_set_allocated_gamemessage(
    ::PROTOBUF_NAMESPACE_ID::Any* gamemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gamemessage_);
  }
  _impl_.gamemessage_ = gamemessage;
  if (gamemessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rtech.liveapi.LiveAPIEvent.gameMessage)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LiveAPIEvent::release_gamemessage() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.gamemessage_;
  _impl_.gamemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LiveAPIEvent::unsafe_arena_release_gamemessage() {
  // @@protoc_insertion_point(field_release:rtech.liveapi.LiveAPIEvent.gameMessage)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.gamemessage_;
  _impl_.gamemessage_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LiveAPIEvent::_internal_mutable_gamemessage() {
  
  if (_impl_.gamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.gamemessage_ = p;
  }
  return _impl_.gamemessage_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LiveAPIEvent::mutable_gamemessage() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_gamemessage();
  // @@protoc_insertion_point(field_mutable:rtech.liveapi.LiveAPIEvent.gameMessage)
  return _msg;
}
inline void LiveAPIEvent::set_allocated_gamemessage(::PROTOBUF_NAMESPACE_ID::Any* gamemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gamemessage_);
  }
  if (gamemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamemessage));
    if (message_arena != submessage_arena) {
      gamemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamemessage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gamemessage_ = gamemessage;
  // @@protoc_insertion_point(field_set_allocated:rtech.liveapi.LiveAPIEvent.gameMessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace liveapi
}  // namespace rtech

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rtech::liveapi::PlayerOfInterest> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rtech::liveapi::PlayerOfInterest>() {
  return ::rtech::liveapi::PlayerOfInterest_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <thirdparty/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_events_2eproto
